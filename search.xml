<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>退役？</title>
    <url>/2013-01-07-Retired/</url>
    <content><![CDATA[<p>杭州比赛之后颓了两个月，补补课考考试，已经水得不知还配得上“退役”两个字否。
Final的名额大致已出，大陆的名额基本上就是各赛区前6加复旦。天津的第7就是命吧。
好多感慨 <a
href="http://www.cnblogs.com/CSGrandeur/archive/2012/08/27/2659120.html">这篇文章（链接）</a>已经说得差不多了，做了很多自己觉得比较满意的事情，不过历史的洗涤与社会的选择下，最终留给我的，许只是天津的这块金牌了吧。</p>
<h2 id="section"><span id="more"></span></h2>
<p>或许是上天觉得中南时候未到，几代人曾一度更加的逼近Final的入场券，却一次次在边沿被淘汰。
群里聊天，尹师兄说，感觉自己大学因为参加了ACM才没白读。回想起来，连续三年的暑假都在集训中，先是小白，再是拼命，再是带新人，还考了计算机的研，逃跑似的离开了自动化，几乎就是自己对自己本科四年的否定，如果没有ACM，就好像这四年不曾来过。
想起自己的计算几何列表还没完成，想总结一篇好一点的专题都没底气。
今年学校的ACM有了些不错的成绩，新人中的宣传也比去年给力多了。曾经说，这样努力发展下去，三年时间中南应该能够进Final。今年依然欠了一些运气，那么，看你们的了。
没了ACM，突然心里空空的，也许就是这几天有点抑郁的原因吧。
作为一个经历中南7代ACMer，承前启后贯穿发展史的老人（最后装一下。。），以这么篇短短的文章谢幕，是有那么点不好意思。如果有机会有精力，再讲故事。</p>
]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ACM，关于CSU</title>
    <url>/2013-07-07-About-ACM-About-CSU/</url>
    <content><![CDATA[<p>原帖地址：<a
href="http://tieba.baidu.com/p/2432943599">http://tieba.baidu.com/p/2432943599</a></p>
<p>作者： 郭大侠爱写代码</p>
<hr />
<p>前言：
即将进入研二，ACM的事情也渐渐远去，记忆终将模糊，但那段奋斗永远让人热血沸腾。开个贴讲讲ACM与中南的故事，当是宣泄，也当是一种宣传吧。多年不写作文，也不知如今的文笔能否打动更多的有志青年为中南ACM梦想而奋斗。
用时间序好了，不定时更新。一层楼对应一个时期或一年，有补充就在那层楼的回复中。也许真写起来故事不长，就这样吧。</p>
<span id="more"></span>
<h3 id="年">1947年</h3>
<p>ACM(Association for Computing Machinery
)本不是一个比赛，美国计算机协会是一个世界性的计算机从业员专业组织，创立于1947年，是世界上第一个科学性及教育性计算机学会。ACM每年都出版大量计算机科学的专门期刊，有各种各样的国际会议，读研的同学们也许接触过这方面的东西。</p>
<h3 id="年-1">1970年</h3>
<p>ICPC (ACM/ICPC) International Collegiate Programming Contest</p>
<p>先发一段简介： ACM 国际大学生程序设计竞赛 是由美国计算机协会 (ACM)
主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近
30 多年的发展，ACM
国际大学生程序设计竞赛已经发展成为最具影响力的大学生计算机竞赛。赛事目前由
IBM 公司赞助。</p>
<p>美国德克萨斯 A&amp;M 大学1970年承办了首届比赛。</p>
<h3 id="年-2">1977 年</h3>
<p>在 ACM
计算机科学会议期间举办了首次总决赛，并演变成为目前的一年一届的多国参与的国际性比赛。迄今已经举办了34届。</p>
<p>这个比赛不知道是不是一开始就是这样设计的，
那时候很多程序设计语言都是“婴儿时代”，好比C语言是1972年，java更是90年代。
如今的比赛规则是：三个参赛选手组队，只能使用一台普通PC，在5个小时（一般是<code>9:00~14:00</code>）完成7~12个程序设计题目。（打个比方，一个简单的题目是，系统往你的程序送若干组整数对
<code>a</code>,<code>b</code>，你返回给系统对应的结果<code>a+b</code>）。程序得出的结果如果都正确，系统会告诉你你的程序"Accepted"或者"YES"，如果有任何地方不正确，系统会告诉你"Wrong
Answer"，还有其他的内存泄漏、时间超出限制时间等等结果，都是一个比赛系统自动判定的，可以理解为一个黑盒，运行你的程序，往里送数据，另一边出结果，和预先设定的结果进行一一比对。每做正确一个题目，工作人员会根据系统的提示拿来一个和题目对应颜色的气球放到你队伍的位置上（高档次比赛的气球是能飘起来的～～所以用绳子绑气球，国内的大多比赛是用塑料杆。。），这个气球一方面给队员鼓励和信心，另一方面方便“观察战场”，看别的队伍做出了哪个题，可以“捡软柿子捏”，还有就是确实挺好玩，比赛完拿一大堆气球的话，你会看到围观比赛mm们崇拜的目光～～哈。</p>
<p>补充：比赛有个“罚时”(Penalty)的概念，首先做的题多的队伍排名更高，做出题目数量相同的队伍，由罚时来判断。比如C(题号)题在第30分钟做完，做错了2次，第三次得到了”YES"，那么这时的罚时是30+20*2=70，20是ACM比赛约定俗成的系数，错一次罚20，不过如果这题到最后都没"YES"，那么这道题是不罚时的。相同题数的队伍，罚时少的排名更靠前。</p>
<p>比赛是9:00~14:00，所以午饭是在赛场内解决的。小比赛自备干粮，大比赛会发午饭，有时候还很给力，去年参加天津比赛，连大葱油饼都出来了……</p>
<p>比赛可以带任何纸质资料，比如代码模板（这样实现一些特定功能就不至于非要默写了），但是不可以带电子设备，也就是说比赛只能使用安排的那台PC这一个带电的东西</p>
<h3 id="section">1978~1995</h3>
<p>单独把这段时期作为一章，因为在1995年之前，ICPC没有中国队的身影。
ACM/ICPC早期只是美国大学生之间的比赛，而后来陆续有欧洲国家的参与。到了90年代，美国ICPC的竞技水平不再是一家独大，ICPC也逐渐全球化。</p>
<p>这里要说一个与ACM/ICPC密切相关的比赛，即IOI（International Olympiad
in
Informatics）信息学奥林匹克竞赛（国际），NOI全国青少年信息学奥林匹克竞赛（国家），NOIP全国青少年信息学奥林匹克联赛（省）。
我们现在基本明白ACM/ICPC是大学生的比赛，其实高中生也有程序设计的比赛，就像我们曾经知道的数学竞赛、物理竞赛、化学竞赛、生物竞赛等等，在大约2009年之前也一样能保送大学的比赛（那年是不是有个新政策，各种学科竞赛不能直接保送了）。
这个比赛不是三人组队，而是"单挑“，貌似有笔试，也有上机，初期大多数用Pascal，现在也有很多用C/C++。
我国1995年开始了OI的征程，这是有里程碑意义的。你想啊，高中搞完OI的学生（想想数学竞赛的孩子有多厉害，你就能理解OI的学生比考计算机二级都费劲的本科生要牛X多少了。。），上了大学，不搞搞ACM？。
当然大多OI牛人就保送去清华北大上交复旦等等等等了，这也是咱中南ACM这么可怜的一部分原因（也没那么可怜啦，当然这个后面会说）。</p>
<p>1996年，中国开始ACM/ICPC的征程。（未完待续）</p>
<h3 id="section-1">1996~2002</h3>
<p>1996年，上海大学一位教授注意到了ACM/ICPC这项国际赛事对大学生尤其是工程类大学生的重大益处，在与亚洲区负责人的沟通后，这一年在上海大学大陆第一次迎来了本土的区域赛。</p>
<p>区域赛——ACM的选拔过程是，每个学校派出若干代表队（和往年成绩等很多非确定因素挂钩决定这个代表队名额个数）参加区域赛，区域赛成绩优秀的若干学校获得参加世界总决赛的资格，总决赛一个学校只能参加一支队伍，所以像清华上交等学校每年都会为总决赛进行校内PK。</p>
<p>2002年之前这几年大陆一直是仅有上海这一个赛区。经验积累中，中国在ACM比赛中的成绩逐渐提高，参赛的学校和队伍规模也逐步扩大，2002年是一个里程碑式的年份，不仅仅是上海交通大学取得了中国大学在ACM的第一个世界冠军，也是影响了后来每一代ACMer的大神刘汝佳值得纪念的一年。</p>
<p>刘汝佳——高中即参加NOI（信息学竞赛），2001年在上海的区域赛获得冠军，2002年的总决赛中代表清华大学取得世界第四。汝哥曾讲，当时参加总决赛前，根本没有多少资料可做，就只吧之前的总决赛题一遍一遍的做。也许经历过第一代ACMer缺少各方面资料和指导的经历，使其致力于帮助指导国内的ACMer学习算法和准备竞赛，出版的《算法艺术与信息学竞赛》成为中国ACM界的经典。江湖传言，也许是这本书封面以黑色为主，也许是这本书刚出的时候没有ISBN，所以被圈内称为”黑书“。其算法介绍已经相当全面且晦涩难懂，求虐可以买一本。。接下来的连续几年还为信息学竞赛和ACM区域赛出了很多优质题目。当然之后很多年也在为各大赛事提供指导和出题。对本帖有兴趣的朋友可以注意一下这个大神，下文还会提到。</p>
<h3 id="section-2">2003~2005</h3>
<p>故事终于要和中南有关了。。</p>
<p>2003年和2005年，分别出现了国内的两大OJ（Online
Judge)，即POJ（北京大学）和HOJ（杭州电子科技大学）。</p>
<p>OJ——在线评测系统。前面说过，ACM是提交自己的（一般是C/C++）程序给系统对应题目，系统运行程序并处理预定的数据，判断输出结果正确性并返回给提交者。为了方便训练，OJ应运而生，ACM做题训练，就是用OJ。</p>
<p>这里顺便介绍比赛使用的PC<sup>2</sup></p>
<p>PC<sup>2</sup>
——一般是用于局域网中，直到现在区域赛还使用的PC<sup>2</sup>
系统，PC<sup>2</sup>
是加州州立大学开发的ACM比赛系统，这个系统和OJ很大一点不同是可以进行人工干预。懂编程的同学应该知道类似
double的精度 和
拓扑排序多解等问题，同样正确的程序可能会输出有偏差的结果，人工干预大多时候就是处理这样的情况。</p>
<p>但是PC<sup>2</sup> 真心没OJ好用，尤其在Windows下的PC<sup>2</sup>
，一些无法解决的问题让人崩溃。所以除了区域赛，很多比赛还是使用OJ在局域网里用的。</p>
<p>有了国人自己的OJ，也是有里程碑意义的，这让国内ACMer有了更适合自己的训练系统，加上高中OI系列竞赛的蓬勃发展，大学的ACM竞赛开始了爆发式的发展。</p>
<p>敢为人先的湖南在ACM的发展中真的落后了，终于省内各个大学的一些学生开始发现这项比赛。中南出现了第一代ACMer。</p>
<p>这个时候在中南搞ACM还是纯粹的民间活动，就好像电竞爱好者在校门口网吧参加撸啊撸比赛一样。没有经费，没有指导老师，没有奖励政策。</p>
<p>参加一场区域赛，经济上也是不容易的，一个队三个人，用2011年去大连赛区打比方吧，火车票大约2000，参赛费1000，住宿费1200。在2003那个时候，中南的ACMer真的是一群热血青年，他们热爱这项比赛，自费参加。而高富帅北大清华，一个赛区就能去三四个队伍，浙大复旦甚至参加国外的东京、新竹、雅加达等赛区。能参加更多的队伍对于积累经验是相当重要的（有木有看进击的巨人。。845年和850年战斗水准完全不同吧。。炮灰也是有重大意义的。。。）</p>
<p>不能说一定是人家学校给力，毕竟都是有个发展的过程，想必他们90年代刚开始参与的时候，和我们那几年的境遇差不多吧。
中南的ACM起步晚，想追上ACM牛校，确实需要时间。</p>
<p>这几年国内崛起的一位新星，就是不得不说的大神 楼天成（楼教主）。
楼教主的经历真可以用传奇来形容，几乎包揽国内外各大程序设计赛事的。。。冠军！
楼教主2004年通过OI竞赛保送至清华大学，OI金牌、两届百度之星冠军、一届oogle
code jam冠军，top
coder追至排名第一。在后来的2009年，ACM/ICPC世界总决赛中惜败对手取得第二名。第一个以清华应届毕业生身份得到美国互联网大牛“不存在的网站”的Offer。是国内外众多ACMer的偶像级人物。
其更多神迹可百度之。</p>
<p>2004年湖南省开始了省程序设计竞赛。那时候省赛还是算法老教授出题，题目也许学术味比较浓厚。
省赛——省内每个学校派出【至多】四支队伍参赛，学校排名按照四支队伍的题数总和和总罚时评比。
省赛和区域赛一点很大不同，就是对学校的评价标准。ACM区域赛对一个学校的排名取决于这个学校比赛名次最高的队伍。
记得第一届省赛的团体第一是湖大，后来几年的团体第一大多就都是国防科大了。中南如何呢？哈，后面说。</p>
<p>2005年对于中南ACM来说也是个里程碑意义的年份，这一年学工办的黎主任主持创办了三大竞赛协会——ACM、机器人、智能车。学校也开始了对ACM竞赛的越来越多的支持。</p>
<p>中南大学ACM爱好者协会——以我了解，中南的社团一般是从校团委申请，然后归学社联管理，记得大一时候入团是交20元入团费，以帮助社团日常运营。而ACM协会是学工办办起的，作为竞赛发展社团，不收会费，那么也就没有钱给学社联咯。。当年黎主任也和团委交涉过，所以ACM协会挂靠在了科协，但还是和学社联有所合作。
至于后来，因为不收会费，实在是木有钱，所以还是独立行动了。。（以上内容仅为对史料理解，准确性有待考察）。</p>
<h3 id="section-3">2006~2008</h3>
<p>中南的第一代大神成长史。</p>
<p>很多创造辉煌战绩的ACM选手都出身高中OI竞赛，保送至六大（清华北大等等六个ACM传统强校），在大学继续参加ACM比赛。</p>
<p>而中南的这一代大神基本上人人都是从大一学C语言程序设计开始接触编程。</p>
<p>这个时候中南的ACM爱好者协会已初具规模，我所能追溯到的中南最早的ACM大牛就是姚总。</p>
<p>那个时候中南ACM协会分六大部门，姚总是其中一个部门的部长，在那时已有数百题的题量。</p>
<p>【小插曲。。】
题量——虽然任何考试和比赛都并不提倡题海战术，但是题量往往能够体现一个人付出了多少努力，ACM选手竞赛水平和训练的题量也很有关系。在那个时候，完成400题在国内已能跻身高手行列（当然现在是远远不够了）。楼教主接受采访曾说当年计划完成2000题，后来也做到了，一代高手背后也是相当漫长而艰苦的历程。</p>
<p>姚总那个时代中南ACM水平确切如何已不可考，而那一年，赵教
以新人的姿态进入了ACM的世界。</p>
<p>赵教当年当然还称不上教头，带着对姚总的膜拜，努力奋斗着。</p>
<p>中南在第一届省赛之后那一年，开始了本校的校赛，也是省内最早一批开始举办校赛的学校之一。每年校赛在3月举行，07年校赛姚总负责了出题工作，赵教的表现也引起了“老人们”的注意。</p>
<p>训练基本上就是 刷题-总结算法 +
比赛-总结经验，那时候姚总和赵教基本上是一个月100题的进度。</p>
<p>假期赵教在HOJ（杭电OJ）刷题的时候，看到了另一个中南的帐号也在疯狂的刷题，通过站内信，发现这个帐号的主人宿舍竟然在同一栋楼，于是
木南 被发现了！</p>
<p>姚总、赵教、木南
的相识，开启了中南ACM走出湖南，与强校PK的新篇章。</p>
<p>【百度空间那个坑爹的改革，几个前辈的博客从世界上消失了……资料不可考，所以故事的具体年份或许会有错乱。。】
那应该是08年，ACM协会一直在努力宣传竞赛，带新人入门，在这个过程中，赵教注意到一个新人——罗神。罗神那个时候还是个小小小小鸟，但是对数学的敏感和对问题条理的思维，是单靠训练无法达到的。</p>
<p>暑假之后，一年一度的省赛临近，为了培养新人，赵教和罗神组队。
这一年省赛成绩依然平淡无奇，赵教和罗神的队伍因为运气和一些失误只得到了2等奖，但是赵教在博客中肯定的说，罗神在ACM竞赛一定有不可估量的发展。
而赵教的博客有一条湘大谢教练的回复，评价赵教很有教练的风范。事实也确如此，赵教对于中南ACM的发展史绝不仅仅是拿到奖牌挣得荣誉，同时也致力于发展中南ACM，对新人的发现、引导，对训练的组织等等付出许多努力。其博客上的图论（数据结构、离散数学等学科的重点知识）题目列表标注了分类和简介，成为很多（不仅是中南）ACMer学习转载的经典博文，图论代码模板流传至今。</p>
<p>从能够考察的史料看，08年我们省赛参加了三支队伍，一个二等奖两个三等奖，ICPC区域赛两个银奖两个铜奖。那么，下一年目标：区域赛金奖。</p>
<p>补充：省赛的团体成绩是第三。</p>
<p>那几年应该是ACM在中国影响力扩大最快的几年，由于参赛规模的扩大，区域赛增加了网络赛“海选”环节，即在区域现场赛之前，通过一场在网上进行的比赛对学校进行筛选，成绩靠前的学校会根据特定的规则获得参加现场赛的若干名额。
这三年时间国内的赛区数也逐步增加到了5个，且08年的其中一场是前无古人后无来者的“惨绝人寰”，是在中科大的合肥赛区，这一年设置了这个“特别赛区”，为了让更多的学校有机会进军总决赛，5个赛区特别开设了这样一个“不允许已经出线过的高校参与排名的特别赛区”，而因为出线名额只有一个，那场面可以想象。那场比赛根据史料记载应该是
华中科技大学取得了那个参加世界总决赛的名额。</p>
<p>这几年IT企业的比赛也逐渐兴起，谷歌公司的google code
jam，百度公司的百度之星。都是用算法题在网上层层选拔，最终选出几十名选手前往公司总部参加总决赛（谷歌决赛当然是去美国了）。百度的总决赛比较有意思，比如写当年还很火的
反恐精英
的AI（AI就是人工智能）。上文中也说了，楼教主拿了两个百度之星冠军，一个google
code
jam冠军。当然冠军总是很耀眼的，不过对于更多ACMer来说，在圈子里值得炫耀的一个荣誉就是在比赛选拔中进入前xx名的选手，可以得到公司寄来的纪念T恤。那个时候，能有一件这样的T恤穿出来参加比赛神马的，果断是被膜拜的大牛。</p>
<h3 id="年-3">2009年</h3>
<p>大约从办校赛开始就有了教练，不过中南ACM的教练模式和大多数学校相似，教练并不是全职教练，而是还要忙于日常教学工作的老师或教授。教练更多的是提供训练条件，解决经费，预约场地，联系比赛，而没有太多的直接指导，具体的训练往往是老人带新人。</p>
<p>那个时候我们的教练是余老师，人很和善，在中南ACM发展初期没有资料积累的情况下从各处寻找了许多资料，还办讲座宣传竞赛。</p>
<p>不知道09年是不是第一次暑期集训，但是能找到的最早的集训手册就是09年的了。这一年从政策上争取到了一次学校官方的集训，不过由于用地紧张，不得不寄人篱下，暑期集训的训练机房是借的湖大的。。湖大的经费分配和我们不大相同，ACM这部分是相当可观，那时的训练条件也自然比我们好很多。</p>
<p>暑期集训除了培养新人选拔校队，更是主力队员备战下半年的省赛和区域赛。训练是高强度并专注的，且算法学习对于个人发展也是有相当大的意义，于是暑期集训有了信息院、软件院主力队员可用集训代替本科大实习的传统政策。</p>
<p>这一年的主力是06级，新人主要来自07、08级。不过07级的罗神就是个比较“超前”的新人。</p>
<p>助理教练为姚总和赵教，队长为木南。助理教练和副队长
有另外几个前辈，由于没有直接接触过，就不再细说。</p>
<p>07级的伟哥这时候还是被虐的水准。另外同寝室的双jie（捷和杰）上余老师的课的时候了解到了ACM，也参与到暑期集训中来。</p>
<p>08级能听说暑期集训并来参加实属不易，我那个时候是完全没有听说ACM的任何消息的，宣传不力啊。有NOIP背景的大象，有阳仔，有小邱等六人参加集训。</p>
<p>集训总人数44人。</p>
<p>目标金奖不是随便说说，这时候的罗神俨然已羽翼丰满跻身主力，赵教已是图论高手，木南也犀利无比。姚总准备退役了。</p>
<p>这一年省赛拿到了单队冠军，不过团体排名依然是第三。</p>
<p>在区域赛还稍显稚嫩的
赵教、木南、罗神，在合肥赛区稳定发挥，但到最后半小时，排名还在银奖区。一道可做的题还在紧张地敲着代码。20分钟...10分钟...5分钟...提交！系统返回了
"WA"（Wrong
Answer）...4分钟...3分钟...2分钟...调试后重新提交...1分钟...“YES”！想必当时三个人高兴得拥抱在一起了。
中南ACM的第一枚区域赛金牌，学校排名第八，这一年中南展现了不一样的实力，也收获了不错的运气。</p>
<h3 id="年-4">2010年</h3>
<p>09年拿到了金牌，虽然学校排名第八有一些运气，但距离拿到总决赛入场券的梦想并不再遥远。</p>
<p>ACM is a
game，玩的时候认认真真去玩，结束之后认认真真继续接下来的生活、奋斗。赵教在09年的比赛之后退役，准备出国留学。</p>
<p>或许由于连续两年成绩进步的鼓舞，这一年的校赛特别热闹。</p>
<p>刚刚考了2月计算机二级的郭小侠宿舍里飘进了一张校赛的宣传单，于是决定去玩一玩。图书馆借了本看不懂的算法书，拉上同班一个同学和隔壁班一小mm就报了名。</p>
<p>不知道用<code>while(scanf()!=EOF)</code>读数据，不知道数据可以边读边处理直接输出而开大数组，不知道<code>qsort</code>可以排序而不用写俩<code>for</code>循环去冒泡，不知道。。。
什么都不知道，直到校赛最后几分钟，小mm都急哭了，0题收场。糗大了……</p>
<p>校赛刚一结束就接到了暑期集训报名通知。原来还有集训啊。郭小侠从小学开始就喜欢参加各种竞赛，虽然对ACM什么都不会，不过或许暑假“培训”一下就会了～～（很多新人和郭小侠一样自动把“集训”脑补成了“培训”）。</p>
<p>郭小侠自当不认识余教练，但是一看就知道是个管事儿的老师，于是就问校赛没做出题。。还能参加暑假集训吗，咱写代码好快的，就是不会算法。余老师哭笑不得着说，算法是最根本的，怎么能不会呢。</p>
<p>虽然后来知道，其实那时候参加集训的政策还是很宽容的。</p>
<p>郭小侠找了校赛群里认识的伟哥私聊，求进集训啊。</p>
<p>伟哥09集训的时候可能和这时候的郭小侠差不多，但是郭小侠不知道伟哥这一年来付出了怎样的努力，课都几乎跷光了（当然是不提倡的，但这个精神真让人感动啊）。这时候的伟哥今非昔比，一方面负责了校赛、集训报名等很多工作，另一方面也即将单人10年集训的助理教练，在校队中也是独当一面，比赛的“单兵作战能力”堪比兵长（呃，兵长乱入。。和本帖无关人物。反正就是很厉害了）。</p>
<p>集训的报名需要填一个表格，表格的最后一栏是“参与ACM竞赛的目标”。</p>
<p>那时郭小侠还不知道ACM后面有什么省赛区域赛总决赛，于是雄心壮志地写下“刷新中南ACM历史成绩”。</p>
<p>于是暑期集训在长沙酷热的暑假中展开了，10年的集训终于在本校的机房进行——科技楼四楼机房，很多同学应该在那里做过上机实验。但毕竟还是借的机房，软件不能随便改，书本资料每天拿去走的时候要带走，中午还要关门。南校的孩子们一到中午就会纠结是大老远跑回南校还是在本部游荡。
暑假的天气，大中午南校本部一趟差不多衣服就全湿了。郭小侠在本部图书馆带空调的的电子阅览室充了点钱，每天中午就算是有了着落。</p>
<p>日子是充实快乐的，但是也不得不说新人有很多的纠结。有问题可以问学长，但是杯具就存在于，弱得连问题都没得问。
集训手册除了简单题列表外，基本上做题就是抄代码的节奏。天天做题，却除了写代码更熟练，没有发现任何明显的进展。集训快结束的某一次训练赛，郭小侠才在做某道完全会做却不知怎么存得下数据的题目的时候，被木南前辈告知C语言有<code>__int64</code>这么个东西（<code>__int64</code>，是表示比较大的整数的一种变量，初学者在做超过10<sup>9</sup>
的整数的时候如果不知道这个变量就会不知所措）。</p>
<p>没资料，没引导，几乎全靠自己。所谓师傅领进门，修行在个人，门都进不去还怎么搞。郭小侠暗自下决心，等自己成为伟哥他们那样的大牛之后，一定要想办法找到让新人入门的方法，让中南后来的ACMer不再在初学时进展得那么困难，浪费那么多没有必要的时间。</p>
<p>这一年的集训有76人，每三五天就会有一场练习赛来看大家的学习进度，并作为最终选拔校队的参考。集训一上来第一场比赛，郭小侠就备受打击——29名，要知道这年集训可是有09级的学弟的。</p>
<p>09年就已参加过集训的大象、小邱、阳仔等等几个同年级的同学在集训一开始就遥遥领先，也得到了木南、伟哥、捷哥和杰哥等一干助理教练的认可。郭小侠真是羡慕嫉妒恨啊，虽然进展缓慢而辛苦，但不断努力，总不断在进步。</p>
<p>一次次比赛，慢慢的，第十几，第几，甚至有一次冲到了前三（不过那次是小邱阳仔几个有一部分没参加。。。），集训不断有人请假，有人放弃退出，但郭小侠在完成了暑期实习（大二这个是小实习，且又不是主力队员，就不用考虑代替实习的问题了）之后的那天早晨，坐着校车从湘潭直奔校本部车队，下车飞奔到科技楼四楼，终于没错过集训最后一场比赛。</p>
<p>集训最终并没有刷掉多少人，因为太多人是自己放弃了。郭小侠终于如愿进入了20人的校队（20人是包括助理教练等老队员在内的）。</p>
<p>余老师去美国交流学习了，于是换了新的教练陈老师。这一年的校队名单是陈老师宣布的，而郭小侠认识ACM的教练也便从陈老师这个时代开始。</p>
<p>即使进了校队，也并不是多么可喜可贺，毕竟新队员们还是清楚自己有几斤几两，中南的ACM还在成长，校队也非个个高手。</p>
<p>接下来就是省赛的备战，一如既往的没有场地。为了集中训练，大象凭借软件院ACM团体的领头身份在铁道校区借得了一个勉强容下校队的小机房。
对于校本部这边的郭小侠一干人等，就比较辛苦了。周末哪有校车可坐，17路挤得要爆炸，而每周末要在铁道校区机房集合，是因为区域赛的网络选拔赛（上文有描述，用于筛选学校确定参加区域现场赛的名额）基本就安排在9月、10月的各个周末。</p>
<p>ACM是三人组队的团体项目，所以校队的训练也会组队进行。和队员互相不熟悉的新人们，组队就由伟哥来指派了。于是郭小侠认识了韩小帅和凌小艺。凌小艺在做项目方面也算小牛一只了（项目是做比如我们用的QQ之类这样的软件，而ACM做的算法是解决如何让QQ这软件运行得更快之类的问题），韩小帅皮肤略黑，双眼很有神，放到校队里真可以算“队草”一枚了。</p>
<p>不过区域赛的网赛，对于三个小菜鸟来说，简直是逆天的难。写俩for循环就不错了，你给出个最小生成树，谁晓得去翻赵教的模板，更别说默写了。</p>
<p>慢慢的郭小侠觉得这么下去意义不大，跑铁道校区太费时间，做网络赛也给校队带不来什么贡献，反正在网上做，何必非要跑这么远呢。于是就向伟哥请求网赛在宿舍做了。</p>
<p>郭小侠是不知道其实前辈们更注重的是训练的态度，阳仔就一直坚持往铁道跑。不过话说回来，阳仔还做的动那些题的说，终究还是水平不及人，这一年也没能参加省赛，更不用说区域赛。</p>
<p>这年罗神的队伍是 木南、罗神，区域赛时又请了姚总出山助阵。</p>
<p>伟哥的队伍则是 伟哥、开仙、大象。
伟哥和大象算全能型的吧，数学院的开仙就专攻数论了（开仙在新人时代是相当犀利，师大一年一度的个人赛中开仙压过了罗神和伟哥的说～～）。</p>
<p>2010年是中南ACM竞赛成绩的一次高潮，上半年除了校赛，省内也有了参加湘潭邀请赛的传统（邀请省内高校参赛，规模算个小省赛了），罗神的一队轻松夺冠，伟哥的二队好像是第二或第三，力压群雄。</p>
<p>每年省赛区域赛这段时间，都伴随着另一个牵动人心的事情——保研。
那时候省赛的一等奖还可以保研，罗神大概已经打算找工作，压力便不太大。伟哥就比较着急了。保研虽是九月底十月初公示，但通过一些直接途径，10月25之前省里保研工作的门还是没关的。但是最揪心的就是，这年的省赛时间从10月初推到了10月31日。</p>
<p>较早来临的杭州赛区，纠结于保研的伟哥自当去争取个银奖以上。可惜很遗憾，只拿到了铜奖。</p>
<p>快到省赛，也马上就要确认省赛名单，这时候真是“半路杀出个程咬金”，师大附中刚毕业进中南的10级小曹突然出现在校内ACM群里，陈老师安排罗神与其面谈一下。结果就是，有NOIP背景的08级的乐乐参加省赛的位置被小曹替掉了。</p>
<p>原来小曹NOIP因为失误没拿到省一等奖而参加高考来的中南，但水平完全是湖南省一的水平，曾参加一个亚太地区的OI比赛拿到金牌（这比赛不甚了解，不过也挺牛的，只是这个比赛和高校录取不怎么挂钩）。</p>
<p>省赛来临，由于研究生不能参加省赛，于是罗神与捷哥组队，伟哥还是原队。那年湘大谢教练在博客评论说
如果罗神和伟哥组队，这年的单队冠军必是中南，不然还是有些难度的。</p>
<p>然而罗神就是罗神，没有前辈木南、赵教
的队伍依然拿了全省单队冠军。伟哥的队伍也相当给力，拿了单队第四。
10年省赛刷新了“万年老三”的历史成绩，中南拿到了团体第二。</p>
<p>高兴之余，不免还有伟哥的伤感——迟来的省一等奖已来不及保研。</p>
<p>工作是要找了，不过还是要先专心打好区域赛，对得起一年多来的努力。</p>
<p>成都赛区和福州赛区都赢得了 两支队伍的名额。</p>
<p>成都赛区伟哥的队伍好歹是赢了罗神一把，拿了银奖。罗神这边多少有些失误，虽然是银奖但是名次靠后些。</p>
<p>成都之后就是福州赛了，最后一战。</p>
<p>【小插曲】ACM区域赛规定，每年同一支队伍之多参加两个国内赛区。</p>
<p>成都赛区必然会有新人队出场。罗神在群里问了一句谁想参加区域赛。郭小侠一个精神（果断是像中国好声音里哈林那样“选我选我选我”！），就毛遂自荐了。新人一般都很难拿到成绩，所以重在参与，积累经验，对来年很有好处。</p>
<p>不过令人失望的是，罗神私聊中说，学校报销很多经费参赛，还是应该尽力拿到成绩的。也没有多说，郭小侠自知拿奖还完全不可能。</p>
<p>去参赛的最终是小曹、阳仔、小邱。意料之中，没得奖。。</p>
<p>罗神、木南、姚总在福州赛区大显身手。
一开场罗神队伍做题飞快，几乎每道题都是1Y（1Y的意思是第一次提交代码就正确，而没有Wrong
Answer之类的结果造成罚时）。
最后大家都知道，D题（题号）做出来就能拿到总决赛入场券了！可罗神的思路总有那么一点点不通。氛围越来越紧张，最后一小时，最后半小时，最后几分钟，敲着代码，思考着算法。终于，裁判宣布比赛结束，而那道题，还是差了一点点。</p>
<p>如果说前一年的金牌多少有点运气，那么这一年仅仅拿到金牌就是缺了点运气。依然学校排名第八，而和总决赛梦想仅一步之遥。</p>
<p>这一年是中南ACM的大丰收，而队员中又是几家欢喜几家愁。</p>
<p>罗神和伟哥一起找工作去了。（顺便一提，罗神面试时候给考官解释一个牛X的数学问题把考官听傻了）</p>
<p>补充：伟哥队伍的成绩也本有机会更好些，三个人的队伍一个人完全压在了数论上，而运气不好的是两场区域赛没有遇到开仙的数论题。。
还是补充一下。。虽然不太重要的信息：罗神在福州赛区最后搞的那个题的题号是不是“D”记不清了，也可能是“E”吧。。。</p>
<h3 id="section-4">2010~2011</h3>
<p>罗神大小比赛的成绩和在湖南ACM界的各类活动（出题，博客，群内讨论神马的），渐渐赢得了省内许多ACMer称其为“教主”的美誉。10年中南ACM在湖南也确实取得了压倒性优势，罗神也几乎代表着这个时候湖南ACM的最高水平。</p>
<p>百度之星这年的晋级赛有个给疯狂坦克写AI的环节，伟哥拿了个华中赛区的第一名。</p>
<p>没能参加10年任何一场大比赛的郭小侠，对ACM是否还要坚持的信心有点动摇。凌小艺和韩小帅对继续做ACM的态度也并不乐观。本身是自动化专业的郭小侠，因为专业课不同，搞个二叉树就纠结了好几天，刚好年底看到了智能小车的通知，于是打算去打个酱油看看。
智能小车搞得怎么样就不再详述，但是郭小侠看到了智能车比赛的条件竟然比ACM好太多，有自己的训练基地，主力队员甚至有自己的位置放电脑放资料。似乎郭小侠内心还是站在ACM这一边的，心中更多的是嫉妒。</p>
<p>[一个不用粗括号的小插曲。。。小程序猿的逆袭]
郭小侠和隔壁班一小mm认识大半年了，关系一直没什么进展。年底时候，要做单片机课程设计。已经搞过ACM和负责智能小车编程的郭小侠，弄起这个来轻松无比。而那小mm简直可以用完全不会来形容。某天中午，电话：“搞不定了找我啊”“不用，应该能搞定”。吃晚饭前，郭小侠接到似乎意料之中的电话，“我搞不定了。。。”，果断二话不说，南校直奔民主楼。一来二去，郭小侠有了女朋友。</p>
<p>2010~2011的两年之交，发生了不少变化。
中南ACM发展这几年，一直是老人指导，新人辈出的稳定节奏。而10年底的“巨变”几乎一下子把中南的ACM水平丢回了刚刚开始的时候——因为断层。
姚总和木南是肯定退役了，ICPC要求满足&lt;=22岁或&lt;=研究生一年级。罗神真心打算去找工作了。开仙身处数学院，忙于新的学习生活，也仅仅在网上给新人指点一下数学问题。捷有点幸运地拿到了保外名额，杰果断考外校了。最想留下继续ACM的伟哥想保研却保不了，也工作去了。06级走了，07级也走了。而对中南ACM继续的打击是，阳仔等几个即将成为绝对主力的08级一干人等，有的工作有的考研，也这么莫名其妙的散了，形容这个时候——“中南无人”。</p>
<h3 id="年-5">2011年</h3>
<p>11年初，距离罗神他们毕业还有一段时间，无论怎样，中南ACM总要有接班人。简直可以脑补前辈们扫了一遍校队群成员，然后目光定格在头像亮起的郭小侠，叹了口气的场景。。（当然不至于了，好歹郭小侠在10年底湖大一年一度的新人赛还赢了100块大洋）。</p>
<p>即将委以重任，罗神终于亲自和郭小侠面谈了一次，并把中南ACM爱好者协会的印章交给了郭小侠。得此印即为协会之主席，此时中南大学ACM爱好者协会
包括主席在内总人数为——1人。。。</p>
<p>也许是前辈把印章给罗神之后，一方面因为学校有竞赛辅导员组织校赛和发集训通知等等，另一方面罗神忙于备战比赛，忘了协会的事情，一两年过来，协会无人打理，已经名存实亡了。</p>
<p>于郭小侠而言，虽然并没有决心把ACM继续下去，但是既然担此重任，无论协会是什么状态，都要把协会重新做起来。协会能做的远不止曾经做的那些，这是一个很好的途径和窗口，一定能极大带动中南ACM的发展。</p>
<p>首先三件事 第一件事，把协会6个部门精简为4个部门。
第二件事，把校队“残存”的朋友们拉上，“当哪个部长，自己选把”。
第三件事，4月校赛临近，开宣讲会，顺便招兵买马。</p>
<p>校赛的宣讲会是很有意义的，这也算是参加智能小车比赛学的一招吧。。至少告诉参赛的新人一些ACM的基础东西，使之不至于像郭小侠第一次参加校赛那样即使题目会做，怎么也做不对。至少说明EOF是什么，说明不要把答案存到一个数组里最后再输出。。。</p>
<p>ACMer并非都善于管理，郭小侠找来了当过学工办助理的好哥们儿彭小山帮忙，通过招新得到了小宇、小易等很多很有行动力的小朋友。</p>
<p>兵马齐备，协会可以开始基本的运转了。不过那时候郭小侠还有很多没弄明白的东西，比如只有一个印章，怎么就说明是主席了呢，又不是古代拿个官印什么的，好歹学校有个登记吧。协会的经费哪里来，又不收费。协会和学社联神马关系，和团委有没有关系，上级是谁。。。一堆问题存在郭小侠脑海里，不过把ACM工作做好要紧，这些问题慢慢解决。</p>
<p>上文说过OnlineJudge（在线评测系统），中南为什么没有呢。这个时候国内出现了一个开源项目，是华科（HUST）几个学生毕业设计做的OnlineJudge系统，另一个学校的一个老师发现了这个系统，并继续改进，作为一个开源项目发布了。这几年很多学校开始对这个开源项目进行二次开发，作为自己学校的OJ系统。</p>
<p>捷
爱好摄影，擅长美工，杰有点极客风格，擅长多种技术，两人一起对HUSTOJ重做美工，功能二次开发，并通过陈老师向学校申请服务器，中南有了自己的OnlineJudge系统（acm.csu.edu.cn/OnlineJudge），并交给了不懂ssh不懂shell不懂php不懂。。的郭小侠。。。</p>
<p>【小插曲】现在的这个OJ网址的OJ不是当时捷和杰做的了，直接使用了最新的HUSTOJ原版，因为有功能更新，而老的美工模板在新版本HUSTOJ下无法使用。</p>
<p>郭小侠深知中南ACM最缺的不是大牛指导带领，而是氛围、凝聚力。如果08级精锐仍在，没有07级的庇护也不用怕。如果更多的人参与ACM，就会有更好的竞争氛围，有竞争，就有更大的进步。</p>
<p>上大学之后生活就颓废很多的郭小侠深深地觉得，要不是参加ACM，自己现在似乎什么都不会，ACM能帮人找到方向，最不济，能让人更快更好的学会编程。大到搞好成绩把中南名气打出去，小到让每个人拥有多一份很好的技能，发展ACM竞赛，一定是极好的。</p>
<p>校赛的第一谁都没有想到，是一个来自湘雅生物科学的姓罗的家伙带领的队伍。此罗
并非 罗神，是09级的学生，这让郭小侠很好奇。</p>
<p>校赛之后，就是传统的暑期集训报名了。</p>
<p>群里突然冒出一个10级小孩子，没参加校赛，想要参加集训。莫不是又是班长坑爹，没给发校赛通知。</p>
<p>【小插曲】真不是仇视班长，相信很多班长还是认真负责的。但有多少次，ACM协会花不少钱打印了足够多的通知交给辅导员，由班长发给每个宿舍一份，绝对是覆盖全部信息院和软件院的，就是希望比飞信的通知更郑重，说明更具体，但总有班长拿了通知之后真就当广告传单了，根本没有发给同学们，这些班长不知道，一个生活没有目标的同学，碰巧看到这个通知，可能会改变他的一生。
还记得当年飘进郭小侠宿舍的校赛通知么。</p>
<p>这个10级的孩子就是小斌斌。</p>
<p>许多高校都有自己的ACM月赛，对校内外ACM交流和活跃校内ACM氛围都很有好处，刚好中南也有了OJ，郭小侠也计划着把月赛办起来。</p>
<p>小斌斌能不能参加集训，刚好可以用五月月赛看看。</p>
<p>小斌斌问郭小侠，有没有什么入门资料。这一刻郭小侠仿佛看到了一年前的自己，也是这么问过伟哥，但是当时什么都没有。这段时间郭小侠刚好意外发现了
刘汝佳 大神
2009年新出版的《算法竞赛入门经典》，因为封面是白色的，就被称为“白书”了。果然多年之后更了解ACM的讲述方法，不再如黑书晦涩难懂。循序渐进，完全是新人的福音。郭小侠果断把这个资料介绍给了小斌斌，并强调了一些曾经坑了郭小侠几个月的烂资料，一定不能看。</p>
<p>小斌斌很好学，时常在群里问问题，从问题也可以看出他做白书的进展。一开始也是新人们常问的“怎么处理题目中所谓的文件结尾啊”（又是EOF，其实就是End
Of File），“<code>scanf("%c"...)</code>怎么才能不读回车啊”
等等。但是随着做题越来越深入，问的问题慢慢的让郭小侠也觉得可以适当讨论一下了。</p>
<p>那时候从学校借的服务器（只能远程登录，不能进入机房），时不时的就挂掉，挂掉了还不知道为什么，要多方面联系到管理员，费好几天才能恢复。</p>
<p>于是，5月月赛进行到一半，服务器就这么巧的挂掉了。不过郭小侠发现那时候宿舍的电信网竟然有独立IP，果断在自己笔记本上架上OJ，勉强把五月月赛进行到底。虽然五月月赛是纯粹的新人参加，不过小斌斌已然在新人中名列前茅（第一或第二？）。碰巧陈老师让郭小侠简单说一下了解的比较有前景的新人（那时候集训的人数一般是
准主力年级（09）&gt;主力年级（08）&gt;完全太年轻年级(10)
),所以10级的集训队员选择需要有所考虑。没参加校赛的小斌斌自然破格进入了集训。</p>
<p>这年集训郭小侠特别建议搞了一场“摸底”赛，先看看队员水平。摸底赛出了大量题目，有点马拉松的味道，不过除了最后两三题，基本上没有什么算法，是绝对的新人题。</p>
<p>又一个没有见过的新人遥遥领先拿到了第一，09级的小小苏，校赛那个姓罗的冠军大约是第二吧，小斌斌是不是第三就不记得了。</p>
<p>集训中郭小侠认识了09级姓罗的那个校赛冠军，个子不高，说是小正太吧有有不少胡子，一问年龄吓一跳——26岁。开始郭小侠不相信，不过后来证实确实如此。姓罗的为人挺好，说话是沉稳中带着滑稽，还有那么些霸气，让人信任又忍俊不禁，因为种种原因岁数不小了又参加了高考，不过绝对是正式录取的正规本科生，大学之前就已做多年写程序的工作，工程经验丰富，校赛很多题都没用套路出牌，而是很奇葩的暴力解法竟然通过了题目。因为年龄，慢慢的大家都亲切地称之为“罗大叔”。</p>
<p>09级的小小苏校赛时候用的java，貌似c语言做ACM是临时学的，没什么算法经验，摸底赛竟然那么厉害，还是很有天分的。</p>
<p>集训时候的组队赛小小苏组了同是09级的建军，建军身材笔挺样貌端正，还真有点军人风范。思维不错，做ACM的风格和小小苏也有几分相似。</p>
<p>10级的小斌斌一直非常活跃，在集训QQ群里话很多，有时候郭小侠都受不了了直接让他闭嘴。</p>
<p>凌小艺确定是找工作实习去了，韩小帅也打算找工作，不过实习时间和集训并不冲突，也参加了集训。
按往年情况，主力队员在集训就是组队训练了，可是郭小侠看来看去，情况并不乐观。</p>
<p>人无远虑，必有近忧，大学一直安逸的郭小侠没有了解过保研是怎么一回事，这个暑假过完就是大四了，而86+的加权平均成绩在自动化的学霸天地里完全是被虐成渣的节奏。考研是不怕，就是太累。带着协会忙了这么久，郭小侠又想起了看到罗神福州失利那时，决心继续前辈们要把中南带进世界总决赛的梦想。如果这年ACM能保研，再真正认认真真奋斗一年，这个梦想应该是很有希望实现的。</p>
<p>可是看这年的团队，保研谈何容易。因为一年前的辉煌战绩，11年的集训吸引了更多的人，加上协会的多方努力和许多改革，这一年的新人比过去犀利的多，但新人毕竟是新人，这一年的老队员简直是几年来最弱。</p>
<p>勉强还能撑一下门面的，是还没有离开的大象、小曹和小邱这个铁三角，大象只拿过区域赛银奖，心有不甘，小曹NOIP失利只有二等奖，又打算本科结束留学，搞ACM得奖多点筹码，小邱则希望拿奖保研。</p>
<p>除了铁三角，看看其他队员，罗大叔做项目多做算法少，比赛发挥很不稳定，韩小帅要找工作要实习，下半年很难静心训练参赛，新人们再牛也是小菜鸟，郭小侠的保研之路堪忧啊。</p>
<p>这一年校队在本部的居多，大家可不想再往铁道跑，而铁道的机房也不一定还能借。眼看区域赛的网络赛即将拉开帷幕，校队找不到地方集中训练，更重要的是找不到地方做网络赛。难道要都呆在寝室里做，用QQ讨论？</p>
<p>还好网赛是周末，陈老师决定大家带上自己的笔记本，到陈老师的实验室来做网赛。实验室不大，校队一来显得格外拥挤。不过这都不重要，有同一个地方，有网线有电源，有校队，梦想便可以继续。</p>
<p>【小插曲】算法——不是相关专业的同学可能看这个词会比较郁闷。在编程方面来说，不能直接理解为“计算的方法”，不过倒是可以理解为“让计算机处理问题的方法”。
比如1000内猜一个数，我只提示“高了”还是“低了”，如果从1猜到1000，那么如果运气不好的话，数字刚好是1000，就要猜1000次，而如果先猜500，如果提示低了就猜750，又提示高了就猜625，这样至多猜log<sub>2</sub>(1000)大约不到10次，就猜中了，那么这个策略，就可以理解为一种算法。</p>
<p>郭小侠深知新人才是希望，比赛经验很重要，一定要让有毅力有决心的新人多参赛，不要有有心奋斗的队员像自己去年那样只能做观众。</p>
<p>省赛临近，郭小侠也开始和新队员进行交流，一方面了解进展，一方面也让新人了解中南ACM的情况，比如关于总决赛，关于梦想。</p>
<p>那天晚上，郭小侠看到了小斌斌的博客——Staginner，解释为“Stay as a
Beginner”——副标题赫然写着“我要把中南带进世界总决赛！”</p>
<p>11年的省赛比以往时候来得更早一些，9月中旬，郭小侠最终还是带上了充满灵气的菜鸟小斌斌。</p>
<p>“判负圈”——“SPFA啊”——“不错，基础知识可以”</p>
<p>“单源非负边最短路”——“SPFA啊”——“还行，知道不止Dijkstra可以做”</p>
<p>“棋盘最短路个数”——“SPFA啊”——“你怎么什么都SPFA”——“我只学过SPFA啊”</p>
<p>我勒个去…… 当年赵教眼中的罗神是不是也这么可爱。</p>
<p>省赛一个图论题题目描述数据范围给错，导致数组开小，结果不给RuntimeError而给Time
Limit
Exceed，一道动态规划明明会做却调代码调到最后没出结果，无奈郭小侠二等奖。</p>
<p>按学校保研政策改革，11年是最后一次省一直接保研。</p>
<p>铁三角作为撑门面的一队，好歹拿了个省一，小邱顺利拿到保研资格。</p>
<p>团体成绩回到了千年老三的位置。</p>
<p>时间不等人，马上开始准备考研还是去9月底的大连赛区再搏一把？郭小侠本是纠结的，但是觉得，如果不搏一搏，未来回忆这时，一定会感到遗憾吧。罗大叔也希望通过竞赛保研，于是和郭小侠一起踏上了大连的征途。</p>
<p>途中郭小侠了解了更多关于罗大叔的事情，罗大叔13岁开始编程，那年家里买了小霸王学习机，罗大叔发现学习卡里有个BASIC语言，于是就玩了起来……情何以堪，我们小时候用学习机干什么来着，何况至今不知道白武士的旋风腿是怎么发出来的。。</p>
<p>罗大叔又讲了来长沙上学后继续找了个工作的事，那时在湘雅附近看到个招聘广告，要求有Linux开发背景，罗大叔做了很久MFC，这Linux开发可不熟，赶紧买了本书，国庆节狂看七天，然后去应聘自称有丰富开发经验，和考官对答如流，顺利赢得工作，6000一个月，现在已经在长沙买了房，按揭还款中。郭小侠已经听呆了。</p>
<p>比赛前宾馆里，郭小侠又向罗大叔学习了一些面向对象的知识，什么构造函数、析构函数之类，受益匪浅，对后来郭小侠竞赛的代码风格产生了深远的影响。</p>
<p>之前说过罗大叔比赛状态是不稳定的，题目对口了爆发起来不得了，题目不对口了也会被虐成狗。大连赛区是郭小侠第一次参加区域赛，了解过前辈的水平和成绩，明白即使是三个自己组队，这个时候的水平想拿银奖也很难。</p>
<p>罗大叔太奇葩了，开场就敲题，不编译就提交，错了两次好歹是通过了。。然后就和最后一题那个全场没队伍做的题掐上了。。
掐到比赛快结束，郭小侠对C题那个动态规划终于有了比较明晰的思路，这是好歹混个铜奖的希望，拿着键盘敲啊敲。最后5分钟，调试，提交，WrongAnswer。。。调试。。提交。。调试。。提交。。比赛结束。。。省赛就是调一个动态规划没出来，大连依然如此。。。这就是传说中的“打铁”么，Honorable
Mention。</p>
<p>比赛结束后，罗大叔恍然大悟地“噢！最后一题tmd看错了，不是个水题”，一旁的郭小侠和另一个队友那个汗啊……</p>
<p>大连到北京转车，郭小侠退掉了回长沙的票，买了回家的。思考一下吧，接下来怎么办。</p>
<p>如果找工作，9月这时候时间很充足，比罗神伟哥当年情况好很多。</p>
<p>不过郭小侠的父母和郭小侠本人都比较倾向于读研。</p>
<p>读控制类吗？郭小侠一直不喜欢这个学科，当初也是父亲让选的自动化，什么电机拖动、自动控制原理，说难也不难，但完全不感兴趣。</p>
<p>考计算机？考外校还是本校？。。。</p>
<p>晚上，郭小侠半发呆状开着一个个网页，看一个个他人的选择，考研的备战历程，偶然右下角小斌斌的头像亮起，随便聊了起来。突然又想起小斌斌博客上那句话——“我要把中南带进世界总决赛！”——也是自己的梦想。</p>
<p>07级的走光了，08级的很多队员似乎失去了奋斗的信心，各自散去。如果这一年08级一个不留，09级、10级是否会一样，断层，继续断层，两枚金牌之后，梦想就永远只是梦想了吗？</p>
<p>留下。</p>
<p>何必那么多为什么，中南信息院还不至于对不起求学的我们。留下，为了中南ACM共同的梦想，为了新人们的渴望。</p>
<p>买了第二天的火车票，郭小侠回到长沙。</p>
<p>自动化的学生考计算机，这年计算机还是全国统考，没有中南自主出题，陌生的组成原理、操作系统、计算机网络，郭小侠却觉得是那么亲切，好像这些东西上辈子就刻在脑海里一样，是被自动化虐得太久吗，考研专业课的复习，虽然辛苦，可更多的是相见恨晚。</p>
<p>郭小侠边考研，边放心不下ACM协会，因为早就有很多的计划等待实现，即使考研也拦不住。</p>
<p>清华的区域赛金牌选手是大一学生，而我们往往是大三大四甚至研一，生源我们是没法改变的，我们没有高中OI选手，但我们可以在大一新生入学的时候告诉他们，你们的大学生活有多一种选择——ACM！</p>
<p>9月中旬，中南的第一次ACM新生宣讲会；</p>
<p>10月，中南的第一次ACM新人赛；</p>
<p>11月，中南的第一次有外校参加的正式月赛；</p>
<p>这过程中，郭小侠也搞清楚了ACM协会的历史由来，并在学工办重新建立了ACM协会正式档案；</p>
<p>盖公章提供学校官方证明，在人人网开通了认证中南大学ACM爱好者协会公共主页；</p>
<p>建立ACM校内外交流QQ群，加强与全省ACMer交流（到2013的现在已不止全省，群里还隐藏着一些世界级神牛）；</p>
<p>招新，壮大ACM协会；</p>
<p>这一年湘大一队的水平力压全省，大家都很好奇我大中南和湖大何以不及湘大ACM，甚至连湖南唯一进过WordFinal的国防科大也败给湘大。这支队伍当然付出了巨大的艰辛与努力，但是当看到他们队员博客提到，“赛前训练那几天直接【睡】在机房”的时候，郭小侠眼中的这句话是“赛前训练那几天直接睡在【机房】”</p>
<p>某天，一个身影直奔民主楼院长办公室。
郭小侠找吴院长“喝了个茶”。吴院长态度和蔼，并表示了对ACM工作的支持，也解释了ACM机房的事情学院也在努力，确实受限于学校的一些条件，但ACM竞赛有机房这一天不远了。</p>
<p>除了大动态，期间小活动也不断，协会组织知识串讲，让刚了解ACM的新人们不必等到暑假的集训，而是常常能得到ACM前辈的指导，还有真正的类似新人希望的“培训”的感觉，懂的人一句话，顶自己看一个月书。</p>
<p>郭小侠希望，中南把月赛办起来，办成传统。把宣讲会搞起来，搞成常规。把知识串讲系统起来，帮新人入门。</p>
<p>期间小宇和小易在工作中做了很大的贡献，而小宇也是这一年ACM校队队员，郭小侠打算有一天把协会主席工作传递给小宇。</p>
<p>另一边，区域赛也在火热进行中，不过火热是别人的火热，11年中南的ACM，除了小邱由于参加保研复试而由大象请开仙出山助阵，在上海赛区做出全场没其他队伍通过的数学神题轰动一时
之外，再无亮点。</p>
<p>省赛团体第三，区域赛二铜，结束了这一年ACM的赛季。</p>
<p>【大大大补丁。。。】</p>
<p>前文说到后面还会提刘汝佳大神，把这么重要的剧情给忘了。</p>
<p>10年、11年、12年，可能还有13年今年，湖南程序设计竞赛的题目是请刘汝佳来出题的，10年的时候伟哥听说这个消息，果断搞来了黑书的各种相关资料。这给二叉树还没搞懂的郭小侠直接看晕了。这时候还没人知道白书已悄悄出版，而一年后拿到白书的郭小侠发现，做完白书的大约350题所学会的算法，面对10年省赛几乎是可以AK的节奏啊！</p>
<p>11年刘汝佳老师来了一趟长沙，在省赛前开了一场宣讲会（教练培训会），站在宏观发展的角度让大家看到了关于ACM更广阔的世界，列举了几个ACM总决赛的题目，也让大家了解到总决赛的题也没有难到我们无法做。同时也提到，湖南程序设计竞赛要发展，省赛的难度也不会一成不变。11年的题比起10年确实难度有一定提升，至少把做完了白书和10年省赛题的郭小侠打击得够惨。
【小插曲】AK的意思是一场比赛所有题都正确做出，1Y的意思是一道题第一次提交就正确了。</p>
<p>一边考研一边顾着协会的郭小侠，依然抽空做一些ACM题，进展缓慢但至少不至于半年后变得生疏重头再来。深知比赛队友一定要找真正愿意坚持努力下去的，并且尽早确定，有目的有计划地训练。菜鸟时代的郭小侠找过一些队员希望组队而被拒绝，如今来找郭小侠组队的人，郭小侠
一 一
婉拒，因为心中已有人选。新人小斌斌和小小苏，虽然这时候还不及经历更多的老人的水平，但郭小侠看得到他们的聪明，看得到他们远超越他人的努力，自己作为助理教练亲自带出的队员，更值得信任。</p>
<p>郭小侠与小斌斌商定，每天小斌斌要完成一份pdf总结，总结当天ACM学习内容，作为督促。小斌斌的进步速度完全超乎想像，一个又一个算法地攻克，串讲中给新人讲解，给月赛出题，几个月下来已近年底，俨然有了些高手风范。又到一年一度的湖大新人赛，小斌斌果断拿了个冠军，这年奖金涨了？小斌斌拿了200块。。比一年前郭小侠的多诶。。</p>
<p>小小苏倒没这么疯狂，自己做着网上找的分类列表。一次次个人赛，和小斌斌势均力敌，谁得第一都说不定。小斌斌、小小苏、罗大叔、建军一直包揽着校内各类比赛的前四名。</p>
<p>关于下一年的暑期集训，郭小侠已经有了一个大计划，首先就是集训手册的改变。</p>
<p>09年开始存在集训手册，而备受关注的部分就是训练题目列表。</p>
<p>09年题目少而精，数量和类型不足，10年题目有了极大丰富但稍显杂乱，11年题目对10年题目有部分改变，并添加了很多题目，看上去更像直接堆砌，良莠不齐，难题、偏题都不适合新人训练。</p>
<p>于是郭小侠开始了一项大工程——对三年集训手册存在的题目和从网上找到的应该添加的算法题目列表，用尽可能多的方法解答，并分析思路，对算法和难度进行细致的分类，对题目列表增删改，为每道选上的题目用标准代码格式和比较好的命名习惯、函数封装
完成题解代码，描述解题方法。让集训手册每道题出现在合理的位置，起到应有的作用，符合暑期集训的任务量。题解供新人参考，作为学习的代码模板，可学习实现方法，可总结打印使用，不至于因为知道算法描述却不知如何用代码实现而阻挡训练的步伐。这项工作也让郭小侠接触了一些曾经不了解的算法，边学边做，寻找最优解决方案。作为集训手册的编写者，了解手册上的每一道题，手册的题目列表才真正有了意义。</p>
<h3 id="年-6">2012年</h3>
<p>考研初试最难一年（2013计算机有中南自主命题了），复试变严格头一年（这一年开始刷一半，学硕录取10人），郭小侠有惊无险地通过了。小斌斌和小小苏很高兴地给“老大”办了一场组队纪念赛。</p>
<h4 id="组队">组队</h4>
<p>郭小侠的QQ头像是Wall-E（机器人总动员，本世纪初皮克斯最优秀动画片），而小斌斌的头像也改成了“清洁工”M-O，于是就拉上小小苏做“电焊工”Burn-E了，队名就取作——CSU_BMW。</p>
<p>真正的组队才刚刚开始，团队配合还有很多不足，年初的大小比赛还是被虐不断，但队伍的改变让郭小侠自己都觉得神奇，就是极强的自适应调整性，比赛一场比一场默契。2010之后，真是久违了小斌斌小小苏这样的选手。</p>
<h4 id="小试牛刀">小试牛刀</h4>
<p>还是一年一度的湘潭邀请赛，中南拿了邀请赛第二个冠军（上一次就是10年的罗神了）。而由郭小侠撮合的罗大叔和建军组起的队伍，也拿了第三。</p>
<h4 id="集训临近">集训临近</h4>
<p>这时候余老师也已回国，
给大家带来了一个惊天好消息，集训能用上机房了！ACM训练专用机房，负责人是余老师。这意味着中南的ACMer有了自己的家，有了一个基地，一个不用被管理员进行各种限制的自己的地方。要不要去机房睡一晚上以作纪念呢？。。。</p>
<h4 id="租房">租房</h4>
<p>郭小侠和小小苏的宿舍在校本部，小斌斌还在南校，队伍联系并不方便。集训前三个人一合计，就在后湖租了个房。小斌斌高兴地说，暑假能吹空调了！</p>
<h4 id="机房来了">机房来了</h4>
<p>7月，机房装修完毕，余老师把机房和机房交换机柜的钥匙交到了郭小侠手里。回想这么多年，那一刻，郭小侠的心情很复杂。</p>
<p>有白板，有投影仪，有打印机，有指纹签到机，有55台电脑和1个带电脑的讲台，虽然都是08年的旧电脑，但已经很满足，还有两台全新大块头戴尔服务器！！！复杂的心情很快被喜悦代替，几天后即将开始集训。BMW三个人马上忙活起来。卡线钳网线水晶头螺丝刀白板擦白板笔，郭小侠检查每台机器的网络，查看网线编号对应机器，换水晶头换接口。小斌斌查看不能启动的机器，大概是机器许久没有通电，扣一下BIOS电池就都好了。小小苏研究了机房机器的联想网络同传系统，给机房统一装上了Win7专业版和ACM训练相关软件。。。</p>
<p>忙活一天下来，看着所有机器同时启动，闪动启动界面，进入系统……心中莫名的激动。准备好了，迎接一个不一样的集训！、</p>
<h4 id="集训前">集训前</h4>
<p>郭小侠的“大工程”也将完工，刚好做完毕设，用毕设的标准排版制作了12年集训手册，不断回忆自己的“菜鸟时代”需要什么，不断修改集训手册的内容，并设想着集训的计划，不是枯燥的日复一日的比赛练习，要分组，要讲解，要减少让新人措手不及的比赛频率，还不能本末倒置，把握好度。</p>
<h4 id="集训">集训</h4>
<p>集训热热闹闹地开始了，对于BMW三人组来说，每天的生活是差不多的，安排好新人的训练任务，听“半新人”给新人讲解自己专门学习的特定算法，做练习或阶段性的比赛，中午叫个“小厨房”的外卖，晚上一起去“湘厨家菜馆”点个香菇炒肉，茄子炒蛋，简单、忙碌、充实。</p>
<p>暑假长沙的天和10年、11年一样，很蓝，还有很大很大块的白云，很美。</p>
<p>小小苏给集训制作了局域网内的集训主页，让队员们可以查看当天的任务，下载不断更新的算法学习文档。</p>
<p>郭小侠搭建了华科大神Isun制作的开源项目VirtualJudge，可以从不同的OJ抓取题目放在一起做，还可以把某场比赛的Ranklist导入系统，因为Ranklist带有每个队伍做出某个题目的时间，利用这个可以把Ranklist变成一个比赛动态Ranklist在5个小时中变化的“录像”，把自己训练时候做的比赛的Ranklist与“录像”结合，就仿佛和当年比赛的队伍同台竞技。</p>
<p>集训快结束的某次训练赛，用VirtualJudge，模拟了罗神当年离Final一步之遥的比赛。从始至终BMW一直紧挨着罗神队伍的下面一名。而最后时刻，BMW选择了和罗神当时做的不同的另一道题目，是个计算几何。郭小侠完成了这道题目，然而比较无语的是在HOJ提交是WA，但去UVA（西班牙的著名OJ，与ICPC合作作为ACM比赛的题目存档OJ）提交就正确了。“标程没加eps，OJ又不给Special
Judge，坑爹”。</p>
<p>【小插曲】eps是指一个很小的10<sup>(-6~-12)</sup>
的小数，用于修正double的浮点精度。SpecialJudge是OJ中用来通过另外一个程序解决问题的多解问题，而不需要人工干预，比如拓扑排序，比如可承受double精度范围。</p>
<p>至少这给了郭小侠不少信心，郭小侠+小斌斌+小小苏的队伍，不弱于罗神+木南+姚总
当年。</p>
<h4 id="校队选拔赛">校队选拔赛</h4>
<p>校队选拔赛从没有过，往年集训都是根据平时频繁的比赛进行综合参考而指定名单。有压力才有动力，凭实力说话才应该是选拔校队的标准，郭小侠在集训一开始就告诉大家，校队要用比赛来选。当然集训期间还是进行了若干次比赛作为一定的参考。为了避免偶然性，最后的选拔赛进行两场，取每场前10名，第一场前10在第二场不计排名，且两场从始至终封榜，第二场结束公布结果。考验的不止是水平，还有心态。</p>
<p>一年来ACM协会各项工作的展开有了显著的收效——校队平均年龄降低，平均水平提高。至少可以保证，这一年刚选出的校队，每个人都会写线段树……（往年是做不到的，比如当年二叉树都不会的郭小侠）</p>
<h4 id="省赛">省赛</h4>
<p>按照省赛的规定，研一的郭小侠是不能亲自参赛了。时间在国庆节之后，于是郭小侠为队员们准备了充实的“国庆七天乐”。按照省赛老人带新人的传统，小斌斌、小小苏、罗大叔、建军分别领衔四支队伍。郭小侠从各处找来其他省程序设计竞赛的题目、数据、题解，完全模拟省赛的环境（省赛用PC<sup>2</sup>
，年轻队员没什么比赛经历，基本上只知道OJ），七天每天一场标准时间的比赛。</p>
<p>小斌斌和小小苏每天训练之余要做一件事，就是要看个一两集的《轩辕剑》（胡歌那个），这导致的结果是，省赛中南四支代表队的名字是——盘古斧、女娲石、神农鼎、伏羲琴。。。</p>
<p>意料之中？意料之外？建军这边差一点点，拿了二等奖的第一名，于是2012年湖南省第八届"蓝狐杯"大学生计算机程序设计竞赛，中南大学拿了三个一等奖，一个二等奖，第一次【团体第一】！</p>
<p>晚上建军的QQ签名改成了“这都是命啊！”，有些遗憾和心酸。建军已经成绩保研外校，这句话是真心的对于ACM的遗憾。</p>
<p>罗大叔的保研大业还在坎坷之中。2012年中南取消了对学科竞赛省一直接保研的政策，而大叔的课程成绩还没有进入年级30%，想保研，还要区域赛的银奖以上。</p>
<h4 id="区域赛">区域赛</h4>
<p>BMW三个人除了打了两年酱油的郭小侠，小斌斌和小小苏其实接触ACM的时间并不算久，再好的天分和努力也终究受到时间的限制，为备战区域赛，不得不明确分工去学习算法。于是郭小侠暑期集训进行一半之后就开始专攻计算几何了，小斌斌专搞“冷门”算法（其实不冷门，甚至很热门，只是对于中南这样的ACM弱校，splay、dancinglinks这样的东西基本都是“大后期”），小小苏则搞图论和动态规划（小小苏照着赵教博客的图论列表做了个遍，又学习了各种奇葩图论题，超越当年的赵教还是应该能做到的）。</p>
<p>按照传统，为了保证当年的成绩，一队一般会去两个赛区。小小苏的女朋友在杭州上学，小斌斌的女朋友在北京，刚好也为了两场区域赛之间能隔一段时间，于是选择了中间隔着金华赛区的
天津赛区 和 杭州赛区。</p>
<h4 id="天津">天津</h4>
<p>天津赛区争取到了两支队伍的名额，于是郭小侠、罗大叔一行六人开赴天津。</p>
<p>火车上大家也谈论着OJ要不要自己开发一个，郭小侠还想用PHP，小小苏说用java，罗大叔说用C++（C++做网站。。有倒是有，效率还比PHP高，郭小侠不得不再膜拜一下罗大叔）。又谈到来年校赛出题，郭小侠说，咱就出个麻烦点的计算几何，搞个三维凸包，问怎么放平地上高度最小，balabalabala。。。。</p>
<p>天津赛区的热身赛，郭小侠去参加教练会了。</p>
<p>【小插曲】队员参加教练会和教练晚宴也算中南的传统了，陈老师为了节约经费，尽量让校队能多参加一个赛区，陈老师没有参加任何一场“免费旅游”，比赛都是队员自己去，队长负责处理需要教练的相关事宜，各赛区送的教练礼品陈老师也一般让队员们自己分了（金华的火腿，天津的麻花……）。</p>
<p>教练会完，热身赛没结束，郭小侠也赶过来凑一下热闹，以校队第一高的水题通过率果断切掉一道水题。。。</p>
<p>没想到瞎搞一通，热身赛拿了个第三名。也算个好彩头吧。</p>
<p>第二天正赛，一开场小斌斌果断敲起代码，交了一次错误之后赶紧调整马上就通过了，郭小侠一看题，不用解释也明白了，第一题是判断麻将是否胡牌，这小小苏和小斌斌可是棋牌高手。同场的
朝鲜金日成综合大学代表队据说不会玩麻将，第一题纠结到下半场。</p>
<p>紧接着郭小侠的水题1Y率不是盖的，两道水题轻松通过。</p>
<p>【小插曲】水题顺利通过对队伍的鼓励性是很大的。ACM赛场上一些不弱的队伍因为水题卡很久而严重影响成绩的案例屡见不鲜。</p>
<p>小小苏搞着DP，和小斌斌讨论着一个图论，郭小侠发现了计算几何题。</p>
<p>这个计算几何题其实更算是一个高中几何题，郭小侠明明知道结果应该是算一个角度范围的区间覆盖，但就是脑袋迷糊总是想错那个角度的计算方法。</p>
<p>小小苏的DP和那道图论卡了挺久，快要最后一小时的时候郭小侠随便编了点数据，小苏苏发现了DP题代码的问题，竟然是一句下标标反了，DP题通过。小斌斌也突然灵感爆棚，把拿到图论刷掉了。</p>
<p>这时候郭小侠的计算几何代码已经成型，但还是脑袋迷糊纠结那个角度怎么回事。小斌斌和小小苏继续读题，发现另一个图论题，小小苏知道模型是什么，也知道这个题……肯定做不出来。而小斌斌一声惊喜，想通了一道题的模型，就是陈立杰大神在江湖中流传的后缀自动机！比赛前小斌斌刚好准备了份模版，配合着小小苏的数据，把这道决定金牌的难题切掉了。</p>
<p>【小插曲】陈立杰——高二学生，codeforces全球排名第五，入选国家OI集训队，发明后缀自动机。可能是因为codeforces的排名，高三意外得到google总部的offer。</p>
<p>历史惊人的相似，最后半小时，代码已成型，这道几何题通过，就是WordFinal的入场券。郭小侠调试着代码，明明心里就是那么清楚题目的模型，提交就是那么令人痛苦的Wrong
Answer。倒计时。。。比赛结束。。。</p>
<p>小斌斌的小女友突然冒了出来。呃，这工作人员让进的？。。。无所谓了，反正比赛结束了，后面还有杭州赛区。</p>
<p>晚上颁奖前，志愿者告诉郭小侠看到了最终结果，是金奖。</p>
<p>【小插曲。。。这个还要不要插】志愿者——比赛主办方安排的学生为参赛队伍提供咨询和引导服务。</p>
<p>是金奖啊，小斌斌一听到，一下子抱住了郭小侠。</p>
<p>学校排名第七，金。郭小侠的妈妈发来短信问结果，郭小侠回复仅有一个字，“金”，这条短信郭小侠的妈妈很久都没有删。</p>
<p>学校排名第七，刷新了中南ACM区域赛成绩记录，跨在了WordFinal资格的线上，一切皆有可能。</p>
<p>另一边的罗大叔很遗憾，为了照顾罗大叔保研，安排参加了两场区域赛，到此为止两铜，罗大叔也要考研了。</p>
<p>回到长沙，天津的题目已经放在了杭电OJ上，郭小侠行云流水地敲完了那道几何题的代码，提交，Accepted！艹……</p>
<h4 id="金华">金华</h4>
<p>还是用VirtualJudge系统，BMW做了一场模拟比赛，新队员小宇、小琦等几个队伍也一起做。</p>
<p>郭小侠看到了什么？我勒个去，这不是去天津火车上郭小侠打算出的题么！凸多面体放地上的最低高度，最小阴影面积……这辈子没见过这么巧的事。</p>
<p>金华的题做的很顺，时间到，BMW赫然出现在模拟Ranklist上第三名。小琦哭笑不得着说“老大，你们去金华赛区多好”。</p>
<p>小琦是郭小侠在中南大学贴吧发现的，那是11年暑假，郭小侠的妈妈突然喊郭小侠，说贴吧有个小孩发帖找ACM队友。郭小侠对这种事情是很敏感的，中南ACM很缺这么有主动性的孩子，果断找其加QQ私聊。这个发帖的孩子就是11年入学的小琦，做过NOIP，物理院。11年集训郭小侠带小琦认识了一下陈老师和校队，小琦很白很帅很腼腆。。。12年进入校队，训练很努力。</p>
<p>训练毕竟是训练，和正式比赛有很大不同，不过这场训练确实又给郭小侠增添了不少信心。</p>
<h4 id="杭州">杭州</h4>
<p>杭州的比赛简直是一场惨剧。小小苏开场就发现了几道水题，迅速敲起来，错了若干次，不过好歹是顺利通过了。郭小侠没水题做了，不过惊喜发现有两道计算几何，一道简单的顺利通过，差点拿FirstBlood。另一道复杂些，换着思路交了6次才通过，不过这道题全场没几个队伍过的，看到YES那一刻高兴地叫了一声。小斌斌的Splay也有了用武之地，也是一个没几个队伍通过的题目。这时候虽然和排名靠前的许多队伍一样是7题，但是无论是远在长沙的看直播的校队和教练，还是现场的BMW，都看到了Final的希望，因为两道全场过了几十个队伍的题目，还没做，而通过的两道题目，通过的队伍很少。</p>
<p>【小插曲】FirstBlood——就是dota或者LOL的一血，用在了ACM的比赛中，表示某道题全场第一个通过，2012年华为赞助国内ACM赛事，一血队伍有800元奖金。</p>
<p>造化弄人，一道是能想出的方法要开4GB内存，天方夜谭只好放弃，另一道是刚好没有做过的一个模型，最后半小时郭小侠和小斌斌才讨论清楚思路，小斌斌线段树更熟练些，就开敲。只过这一题，是进不了Final的，但至少能多保一个金奖。最后5分钟，敲完，本地运行RE(RuntimeError，内存溢出之类问题），找问题，问题在哪，这么熟悉的线段树为什么会RE，调试，RE，调试，RE……5，4，3，2，1……比赛结束。</p>
<p>原来小斌斌的女朋友从北京赶来一直坐在看台上，小小苏的女朋友也在外面等着。比赛结束，失落。小斌斌和小小苏带女朋友游杭州去了，郭小侠还要完成教练的工作，参加颁奖典礼。</p>
<p>两道题做出来就是亚军，没做出来就是……银奖的第一名。。。</p>
<p>WordFinal只能指望天津的第七名了，希望还在。</p>
<p>09、10两年的大陆Final名额是19个，11年骤然缩减到16个造成大陆委员会的极度不满，那年闹得沸沸扬扬很不愉快但没有改变结果。</p>
<p>12年大陆有22.5个slot（关于slot是否等于名额数这个问题一直存在分歧，我也不太明白），而大陆5个赛区排名前七的学校正是19个，按照年初亚洲ACM/ICPC主席对大陆委员会的承诺，中南应该能进Final，但是真正结果如何，依然是未知数。</p>
<h4 id="协会">协会</h4>
<p>年初，郭小侠已把协会交给了小宇，但依然为协会的工作出谋划策。小宇整理了协会工作，并将4个部门精简为3个。对于这个改变，郭小侠很高兴，高兴看到小宇的行动力，和协会工作分配的更合理化。</p>
<p>宣讲会、知识串讲、新人赛等等，有了一年来工作的积累和专用机房这个大本营，工作进展的更顺利，效果也更好。美中不足的是，11年中南ACM的低谷，也许影响了新人参与ACM的信心。</p>
<p>新人的积极性和主动性，似乎也不如多年以前。条件好了，为什么反而不懂得珍惜了？有时候郭小侠会把这种现象归罪于现在的孩子的娇贵。但却也一直找不到答案。中南不再像多年以前那个ACM条件很差却英雄辈出的时代，像姚总赵教他们那样坚持、努力、疯狂的队员越来越少。前辈们恨不得睡在机房，而如今有了机房，坚持来训练的却寥寥无几。</p>
<p>坚持的人，有，像小琦，小安，小宇等等，可郭小侠觉得，付出了这么多努力，中南有了这么好条件，为什么差不多生源（没什么OI选手）的电子科大一年能有6个金牌队伍，中南却没多少人愿意去为ACM奋斗，去疯狂？！</p>
<p>【补充】杭州赛区那个“4G内存题”为什么放弃呢。那道题最直观的思路是将坐标旋转45度后用线段树或树状数组进行统计，但数据量很大，直接开数组要开到4GB，想压缩又非常之麻烦且没有思路。我们现在用的大多电脑内存条只有2GB，把一台电脑的内存开满跑程序，想想都不现实。虽然这肯定不是正解，但赛后有人写题解的时候，真的就用这方法通过了，原因是写完代码才去看数据范围，发现4G好大但既然写了就提交一下试试看，竟然YES了！一方面是可能题目提供的测试数据并没有达到题目描述的极限，也就是实际使用不到4GB内存。另一方面是，那场区域赛的判题机可能是4+GB的。。。</p>
<h3 id="年-7">2013年</h3>
<h4 id="梦断">梦断</h4>
<p>1月初，ACM/ICPC亚洲区主席博客公布了2013年亚洲WordFinal资格。</p>
<p>大陆17支队伍进入世界总决赛。香港大学、香港中文大学占用大陆名额（在海外赛区取得很优秀的成绩），但在大陆区域赛名次不计，这样杭州赛区第八的复旦成了第七，出于对ICPC的贡献（11年上海赛区主办方，12年成都赛区出题），优先获得世界总决赛资格。这样活生生地把天津赛区同是第七的中南大学挡在了总决赛门外。</p>
<p>伟哥10年曾说过，没什么好抱怨的，如果有实力去拿区域赛冠军，谁也不能让你进不了决赛。</p>
<h4 id="退役">退役</h4>
<p>郭小侠在中南ACM经历了好多了，从当年的姚总到12级新来的小遒，足足经历了中南七代ACMer，能说的太多，以至于退役时想写篇文章以表纪念却双手放在键盘上敲不出一个字。</p>
<p>蓦然回首，想起三年前填写集训报名表那最后一栏，“刷新中南ACM历史成绩”，做到了，释然了，结束，不过是微微一笑。</p>
<p>小小苏学习成绩很好（拿了国奖？），不用ACM的金奖也保了研，不过忙于比赛，没时间联系学校，保的本校研究生，郭小侠觉得收了小小苏的导师是幸运的。</p>
<p>小斌斌是想去北京找女朋友的，成绩很好保内也不成问题，保外就有点点危险，10级的小斌斌在ACM还年轻，郭小侠一直觉得小斌斌坚持ACM一两年，一定超越罗神，何况博客上那句“我要把中南带进世界总决赛”的目标还没实现呢。小斌斌是有点纠结，继续参赛和考研。</p>
<h4 id="新篇章">新篇章</h4>
<p>郭小侠曾问副会长彭小山，小宇之后协会应该给谁呢。当年小琦来协会的时候，副会长彭小山就告诉郭小侠，小琦现在年轻，但是做人很稳，一两年成熟一些之后，是最佳人选。</p>
<p>13年，小宇渐渐把协会的事情交给了小琦。当年郭小侠是协会和训练新人两部分一个人抓，后来把协会交给了小宇，把训练新人交给了小斌斌，如今似乎协会和训练新人又到了小琦一个人身上。</p>
<p>这一年的新人发展状况还是有点令人担忧，比起小斌斌、小小苏、罗大叔、建军一代，差了不少，也就小琦还有点当年羽翼略丰的小斌斌的影子。老人还是不能一下都走光啊，小斌斌决定参加下半年的比赛，和小琦组队。</p>
<p>小琦你们加油啊，争取实现小斌斌博客上那句话。</p>
<h4 id="毕业季">毕业季</h4>
<p>转眼又一代人毕业了，毕业典礼上张校长还特地点名表扬了一些优秀的努力奋斗的毕业生，罗大叔也在内，那几天老队员QQ群里都在调侃罗大叔，真遗憾年初结婚没去围观，不过“好父亲”真让罗大叔囧了一下，哪这么快生孩子。。。</p>
<hr />
<p>这个帖子的故事到这里差不多就结束了，中南ACM的故事还有年轻人去续写，希望她的故事未来是辉煌的，嗯，一定是。</p>
<hr />
<p>人物后记</p>
<p>姚总：研究生毕业工作，公司我忘了。。</p>
<p>赵教：卡内基梅隆大学Master，留美工作，google公司</p>
<p>木南：本校研究生师从蔡自兴教授，毕业，有读博计划</p>
<p>罗神：本科毕业工作，深信服，深圳</p>
<p>伟哥：本科毕业工作，阿里巴巴旗下（淘宝？），杭州</p>
<p>开仙：本校应用数学研究生在读，（数学院导师，我就不了解了……）</p>
<p>捷：保外，华中科技大学研究生，后加入阿里巴巴</p>
<p>杰：华南理工研究生，得到腾讯和网易游戏实习offer</p>
<p>大象：本科毕业工作，腾讯，深圳</p>
<p>彭小山：（ACM协会副主席）实习一年，湖大金融直博，后放弃直博并创业</p>
<p>韩小帅：（ACM协会部长之一）本科毕业工作，华为，深圳</p>
<p>凌小艺：（ACM协会部长之一）本科毕业工作，腾讯，深圳</p>
<p>小邱：保研本校，师从邹北骥教授，研究生在读</p>
<p>阳仔：考入浙江大学软件院，研究生在读</p>
<p>乐乐：（ACM协会部长之一）教改班保研本校，师从王建新教授，研究生在读，继续为ACM协会做了不少贡献</p>
<p>小曹：已得腾讯实习offer，准备之后出国留学</p>
<p>罗大叔：考研协和医学院失败，保持工作，未放弃考研</p>
<p>建军：保送中科院，今年9月研究生入学</p>
<p>小小苏：成绩优异保研本校，师从王建新教授，今年9月研究生入学</p>
<p>小斌斌：成绩优异，是否保外未知，已得金山实习offer，下半年比赛主要为带新人，不会投入太多时间训练</p>
<p>郭小侠：考研本校，师从邹北骥教授，研究生在读</p>
<p>——————————本帖结束，谢谢观看——————————</p>
<p>中南ACM的历史当然远不止有文中出现的角色，中南ACM的每一步发展，都有着你们清晰的足迹。</p>
<p>谨以本帖纪念为中南大学ACM奋斗的那些日子，致所有曾为CSU-ACM共同梦想奋斗的前辈们。</p>
]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>CSGrandeur的WebGL学习——WebGL教程</title>
    <url>/2015-05-20-CSGrandeur&#39;s-WebGL-Learning--WebGL-Tutorial/</url>
    <content><![CDATA[<p>在线查看：<a
href="http://csgrandeur.gitbooks.io/webgl-learn/content/">http://csgrandeur.gitbooks.io/webgl-learn/content/</a></p>
<p>源码演示：<a
href="http://csgrandeur.github.io/csgrandeur-webgl-learn/Application/Test/1.html">http://csgrandeur.github.io/csgrandeur-webgl-learn/Application/Test/1.html</a></p>
<p>离线epub：<a
href="http://csgrandeur.github.io/csgrandeur-webgl-learn/Application/webgl-learn.epub">http://csgrandeur.github.io/csgrandeur-webgl-learn/Application/webgl-learn.epub</a></p>
<p>离线mobi：<a
href="http://csgrandeur.github.io/csgrandeur-webgl-learn/Application/webgl-learn.mobi">http://csgrandeur.github.io/csgrandeur-webgl-learn/Application/webgl-learn.mobi</a></p>
<p>离线pdf：<a
href="http://csgrandeur.github.io/csgrandeur-webgl-learn/Application/webgl-learn.pdf">http://csgrandeur.github.io/csgrandeur-webgl-learn/Application/webgl-learn.pdf</a></p>
<p><del>在线版本会及时更新，离线版本在有较大改动时更新。</del></p>
<p><strong>内容来自 Learning WebGL
，他的网站是：http://learningwebgl.com</strong>。我修改了代码适用到gl-matrix
2.x的版本，把操作dom的代码改成jQuery了。教程没有纯翻译，看着原版理解着写着，不明白的问题在搜了之后补充上了，自己觉得太明白的问题删减掉了。</p>
<p><del>之后学习的内容会开辟新的章节更新。如有问题欢迎指正。</del></p>
<p>时光荏苒，造化弄人，我现在不搞这个了，也不会再更新了，大家加油<code>^_^</code>。</p>
<span id="more"></span>
<p>——————————以下是教程前言——————————</p>
<h1 id="简介">简介</h1>
<h2 id="webgl是什么">WebGL是什么</h2>
<p>HTML5是当前HTML的新标准，其中一个特性就可以用JavaScript写调用显卡的程序，在新的网页元素Canvas上显示华丽的3D效果，开发WebGL主要使用
JavaScript语言。</p>
<p>我学WebGL目前有两点目的：</p>
<p>Web应该是跨平台最舒服的手段了，没有哪个现代操作系统（哪怕手机系统）不配浏览器吧，HTML5的到来，感觉Web前途一片光明。
JavaScript开发3D好像舒服很多啊，用C++写OpenGL，编译老半天，调试一步一步扯得蛋疼。
当然这两点目的可能很傻很天真，不过学点有用的东西总是好的，也不必太较真儿了。</p>
<h2 id="学习webgl需要什么基础">学习WebGL需要什么基础</h2>
<p>开始学习WebGL时我的基础：</p>
<p>具备一点PHP、HTML、JS的基础知识，做过几个Web的小项目。
做过几年程序设计竞赛，对C/C++语言还算比较熟悉。
跟着《OpenGL编程指南》第八版学过一点入门知识，懵懂了解可编程渲染管线的概念。
建议：</p>
<p>至少具备一些基本的编程技能，理解变量、函数等基础知识。
不必担心对Web相关领域的陌生，毕竟那不是重点，也不会成为学习WebGL过程中的难点。
WebGL的学习过程和OpenGL是相似相通的，所以也不必担心是否需要OpenGL的基础知识</p>
<h2 id="这本书干什么">这本书干什么</h2>
<p>这本书是我学习WebGL过程的记录，会根据学习的经验写成教程的形式。</p>
<p>第一章是“Learning
WebGL”的内容，部分是翻译，部分是自己不懂的地方查阅资料补充的，也省略了一些觉得不必解释过细的内容，可以理解为“Learning
WebGL”的一个中文版。</p>
<p>这本书的GitBook主页：https://www.gitbook.com/book/csgrandeur/webgl-learn</p>
<p>对应的Github主页：https://github.com/CSGrandeur/csgrandeur-webgl-learn</p>
<p>代码演示：http://csgrandeur.github.io/WebGL_Learn_Code</p>
<h2 id="参考">参考</h2>
<p>Learning WebGL 他的网站是：http://learningwebgl.com 。</p>
]]></content>
  </entry>
  <entry>
    <title>Windows下sublime+Latex+IEEE模板配置方法</title>
    <url>/2015-06-11-windows-sublime-latex-ieee/</url>
    <content><![CDATA[<h3 id="装好sublime-text3">装好<a
href="http://www.sublimetext.com/">Sublime Text</a>3</h3>
<p>去<a href="http://www.sublimetext.com/">官网</a> ### <a
href="https://packagecontrol.io/installation">Package Control</a> 下载<a
href="https://packagecontrol.io/Package%20Control.sublime-package">Package
Control.sublime-package</a>，放到sublime的Installed
Packages文件夹里（在sublime中Preferences-&gt;Browse
Packages，上层目录就能看到Installed Packages文件夹）。</p>
<p>重启sublime，如果在Perferences-&gt;package settings中看到package
control这一项，则安装成功。</p>
<span id="more"></span>
<h3 id="安装latextools">安装LaTeXTools</h3>
<p>在sublime中ctrl+shift+P，输入install
package，确认后输入LaTeXTools，再确认就自动安装了。详细文档可去看<a
href="https://github.com/SublimeText/LaTeXTools">GitHub主页</a>。 ###
安装<a href="http://tug.org/texlive/">TeX Live</a> 在<a
href="http://tug.org/texlive/">官网</a>七拐八拐的能找到镜像站链接下载完整iso，不过也可以用很容易找到的install-tl-windows.exe直接装，安装时它会自己下载需要的文件。
如果用iso的话，打开里面的install-tl-advanced.bat，一样安装。 ### 安装<a
href="http://www.sumatrapdfreader.org/free-pdf-reader.html">SumatraPDF</a>
<a
href="http://www.sumatrapdfreader.org/free-pdf-reader.html">SumatraPDF</a>免费轻量级的阅读器，LaTeXTools和它整合的很好，能在编辑过程中互相定位文本位置。装好之后打开windows命令行（左下角右键-命令提示符，或者win+R输入cmd），执行如下指令：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sumatrapdf.exe -inverse-search &quot;\&quot;E:\Documents\PortableSoftwares\Sublime\sublime_text.exe\&quot; \&quot;%f:%l\&quot;&quot;</span><br></pre></td></tr></table></figure>
这个指令是指定SumatraPDF逆向搜索的目标，即我们装好的Sublime，这样就可以在编译好的PDF中，双击文本，定位到sublime里源文件对应行。这里的路径是我自己sublime的安装位置，根据具体安装路径修改。
### 下载<a
href="http://www.ieee.org/publications_standards/publications/authors/author_templates.html">IEEE模板</a>
IEEE的<a
href="http://www.ieee.org/publications_standards/publications/authors/author_templates.html">Article
Templates and Instructions</a>，下载<a
href="http://www.ieee.org/documents/IEEEtran.zip">WIN OR MAC LaTeX2e
Transactions Style File</a>。 ### 配置
sublime中，Preferences-&gt;Package
Settings-&gt;LaTeXTools-&gt;Reconfigure LaTeXTools and migrate
settings，会初始化配置文件。</p>
<p>然后Preferences-&gt;Package Settings-&gt;LaTeXTools-&gt;Settings -
User，修改windows部分，下面例子中的路径都是我自己安装的路径，根据具体安装位置修改：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;windows&quot;: &#123;</span><br><span class="line">        // Path used when invoking tex &amp;amp; friends; &quot;&quot; is fine for MiKTeX</span><br><span class="line">        // For TeXlive 2011 (or other years) use</span><br><span class="line">        // &quot;texpath&quot; : &quot;C:\\texlive\\2011\\bin\\win32;$PATH&quot;,</span><br><span class="line">        &quot;texpath&quot; : &quot;D:/Tools/texlive/2014/bin/win32&quot;,</span><br><span class="line">        // TeX distro: &quot;miktex&quot; or &quot;texlive&quot;</span><br><span class="line">        &quot;distro&quot; : &quot;texlive&quot;,</span><br><span class="line">        // Command to invoke Sumatra. If blank, &quot;SumatraPDF.exe&quot; is used (it has to be on your PATH)</span><br><span class="line">        &quot;sumatra&quot;: &quot;E:/Documents/PortableSoftwares/SumatraPDF/SumatraPDF.exe&quot;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
现在在sublime中打开一个IEEE下载的模板，比如bare_jrnl_compsoc.tex，ctrl+b编译一下试试看。</p>
<p>编译成功的话，就可以写文章了，复制一个模板和IEEE的LaTeX类文件IEEEtran.cls到任意文件夹，开写。</p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 题解</title>
    <url>/2014-01-15-LeetCode-OJ-Solution/</url>
    <content><![CDATA[<p>LeetCode OJ is a platform for preparing technical coding
interviews.</p>
<p>LeetCode OJ 是为与写代码有关的技术工作面试者设计的训练平台。</p>
<p>LeetCode OJ:<a
href="http://oj.leetcode.com/">http://oj.leetcode.com/</a></p>
<span id="more"></span>
<p>默认题目顺序为题目添加时间倒叙，本文题解顺序与OJ题目顺序一致（OJ会更新，至少目前一致。。。）。
习惯大括号换行，遇到大括号默认不换行的样例代码，导致有的换行有的没换行，实在懒得一个个改……</p>
<hr />
<p>2015.11.17更新：今天又看leetcode，发现题目列表终于有编号了。
咦，新题目加锁了，要25 dollar一个月的捐赠……</p>
<hr />
<p>Made By：<a href="http://blog.csgrandeur.com/">CSGrandeur</a>: <a
href="http://blog.csgrandeur.com/2014-01-15-LeetCode-OJ-Solution/">LeetCode
题解</a></p>
<hr />
<h3 id="implement-trie-prefix-tree"><a
href="https://leetcode.com/problems/implement-trie-prefix-tree/">208.Implement
Trie (Prefix Tree)</a></h3>
<blockquote>
<p>20170209</p>
</blockquote>
<p>基本字典树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *nex[<span class="number">26</span>];</span><br><span class="line">        <span class="type">bool</span> word;</span><br><span class="line">        <span class="built_in">Node</span>()&#123;<span class="built_in">memset</span>(nex, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(nex)), word = <span class="literal">false</span>;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node;</span><br><span class="line">            p = p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : prefix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="course-schedule"><a
href="https://leetcode.com/problems/course-schedule/">207.Course
Schedule</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>先构造个图。一开始没想拓扑排序的事，就用DFS来判断的，标记-1表示<code>尚未考察</code>，0表示<code>暂没结果</code>，1表示<code>确认可选修</code>。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; fst, nex, v;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ok;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ok[i] != <span class="number">-1</span>) <span class="keyword">return</span> ok[i];</span><br><span class="line">        ok[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = fst[i]; j != <span class="number">-1</span>; j = nex[j])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">DFS</span>(v[j]))</span><br><span class="line">                <span class="keyword">return</span> ok[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ok[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        fst.<span class="built_in">resize</span>(numCourses + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        ok.<span class="built_in">resize</span>(numCourses + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            nex.<span class="built_in">push_back</span>(fst[prerequisites[i].first]);</span><br><span class="line">            fst[prerequisites[i].first] = nex.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            v.<span class="built_in">push_back</span>(prerequisites[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = numCourses - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            numCourses -= <span class="built_in">DFS</span>(i);</span><br><span class="line">        <span class="keyword">return</span> !numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="reverse-linked-list"><a
href="https://leetcode.com/problems/reverse-linked-list/">206.Reverse
Linked List</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>好像又是老题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="isomorphic-strings"><a
href="https://leetcode.com/problems/isomorphic-strings/">205.Isomorphic
Strings</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>思路一是两个map互相映射，出现矛盾则说明不同构。两个map用于解决其中一个串可能有多个字符对应另一个串同一个字符，只用一个map则会掉这个坑。、</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">mp1</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span>, <span class="title">mp2</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp1[s[i]]) mp1[s[i]] = t[i];</span><br><span class="line">            <span class="keyword">if</span>(!mp2[t[i]]) mp2[t[i]] = s[i];</span><br><span class="line">            <span class="keyword">if</span>(mp1[s[i]] != t[i] || mp2[t[i]] != s[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路二是把俩字符串按同一规则转换，转换后字符串直接比较。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">convert</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">mp</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp[s[i]]) mp[s[i]] = p ++;</span><br><span class="line">            s[i] = mp[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">convert</span>(s);</span><br><span class="line">        <span class="built_in">convert</span>(t);</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="count-primes"><a
href="https://leetcode.com/problems/count-primes/">204.Count
Primes</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>筛素数，以前比赛时候写的滚瓜烂熟的，现在竟然忘了还复习一下……
从2开始把每个其倍数都标记成合数，然后往后枚举，枚举到的没标记的一定是素数（如果它是合数，它的质因数肯定比它小，而比它小的质数的倍数都已经标记过了），继续标记其所有倍数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">pr</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ret ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt; n; j += i)</span><br><span class="line">                    pr[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-linked-list-elements"><a
href="https://leetcode.com/problems/remove-linked-list-elements/">203.Remove
Linked List Elements</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>好像又是老题，开头加个哨兵节点就不用担心head节点被删除的情况了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(ListNode *p = pre; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="happy-number"><a
href="https://leetcode.com/problems/happy-number/">202.Happy
Number</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>直接思路是用哈希记录判循环，降低空间复杂度可以用两个值一个每次算一步，另一个每次算两步来判循环。
还有个方法是只要大于 6 就一直进行，能保证计算结束，不知道怎么证明的。
代码放传统思路。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SumSquare</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += (x % <span class="number">10</span>) * (x % <span class="number">10</span>);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">count</span>(n))</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(n);</span><br><span class="line">            n = <span class="built_in">SumSquare</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">count</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bitwise-and-of-numbers-range"><a
href="https://leetcode.com/problems/bitwise-and-of-numbers-range/">201.Bitwise
AND of Numbers Range</a>*</h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>二进制从左往右看，当遇到某位不相等的时候，最终结果后面的位都会是0，因为在<code>n~m</code>之间，连续的数字中这些位肯定会出现0。题目巧在如果思路转换为求二进制最长相同前缀，代码就很简单了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)</span><br><span class="line">        &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一种理解方式也很好，把n的右侧的1一一去掉，当n不大于m的时候，n剩下的就是那个相同前缀。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; m)</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="number-of-islands"><a
href="https://leetcode.com/problems/number-of-islands/">200.Number of
Islands</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>我一定是做了道假题。。DFS、BFS随便做，好陈旧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> row, col;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;grid, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y));</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nex = <span class="built_in">make_pair</span>(now.first + dx[i], now.second + dy[i]);</span><br><span class="line">                <span class="keyword">if</span>(nex.first &gt;= <span class="number">0</span> &amp;&amp; nex.first &lt; row &amp;&amp; nex.second &gt;= <span class="number">0</span> &amp;&amp; nex.second &lt; col &amp;&amp; grid[nex.first][nex.second] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    grid[nex.first][nex.second] = <span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(nex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    ret ++, <span class="built_in">BFS</span>(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-right-side-view"><a
href="https://leetcode.com/problems/binary-tree-right-side-view/">199.Binary
Tree Right Side View</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>二叉树层次遍历，加个层数标记。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *p;</span><br><span class="line">        <span class="type">int</span> layer;</span><br><span class="line">        <span class="built_in">Node</span>(TreeNode *p_, <span class="type">int</span> layer_):<span class="built_in">p</span>(p_), <span class="built_in">layer</span>(layer_)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">Node</span>(root, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Node now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(last != now.layer)</span><br><span class="line">            &#123;</span><br><span class="line">                last = now.layer;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(now.p-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now.p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(now.p-&gt;right, now.layer + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(now.p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(now.p-&gt;left, now.layer + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="house-robber"><a
href="https://leetcode.com/problems/house-robber/">198.House
Robber</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>简单的动态规划，两个数一个表示<code>上一个没rob</code>的当前最佳收益，另一个表示<code>上一个rob了</code>的，反复更新。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + m);</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="number-of-1-bits"><a
href="https://leetcode.com/problems/number-of-1-bits/">191.Number of 1
Bits</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>做过树状数组应该对<code>n&amp;(n-1)</code>很熟了，<code>n-1</code>让二进制末尾的1变0，这个1后面的0都变1，和<code>n</code>做按位与就相当于去掉了最后一个1，这样每次操作都能去掉一个1，一位一位统计就快多了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-bits"><a
href="https://leetcode.com/problems/reverse-bits/">190.Reverse
Bits</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>首先是最直接的方法，把所有bit放到新数中的对应位置。 题目提到一句“If
this function is called many times, how would you optimize
it?”是很值得思考的。直接的方法进行了32次操作，每个操作里有若干次位运算，这个数字是否可以优化呢？
一个可能思路是并行的分治。问题二分，并行用位运算实现，这样就<code>log(32)=5</code>次操作了。</p>
<p>直接思路：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++)</span><br><span class="line">            ret |= ((n &gt;&gt; i) &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并行分治思路：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n &amp; <span class="number">0x0000FFFF</span>) &lt;&lt; <span class="number">16</span> | (n &amp; <span class="number">0xFFFF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        n = (n &amp; <span class="number">0x00FF00FF</span>) &lt;&lt; <span class="number">8</span> | (n &amp; <span class="number">0xFF00FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n = (n &amp; <span class="number">0x0F0F0F0F</span>) &lt;&lt; <span class="number">4</span> | (n &amp; <span class="number">0xF0F0F0F0</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n = (n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (n &amp; <span class="number">0xCCCCCCCC</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n = (n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (n &amp; <span class="number">0xAAAAAAAA</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-array"><a
href="https://leetcode.com/problems/rotate-array/">189.Rotate
Array</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>空间复杂度不是<code>O(1)</code>的想都不要想。网上方法已经很多了，如：
1、后<code>k</code>个翻转，前面的翻转，再整个翻转。
2、前<code>k</code>个和后<code>k</code>个一一swap，就变成后<code>n-k</code>个做<code>k</code>旋转的子问题了，继续进行到结束。
3、把数组分成若干个以<code>k</code>为间隔的“子数组”，而且这个“子数组”是可以循环回去的，比如<code>1, 2, 3, 4, 5</code>,
<code>k=3</code>，“子数组”就是<code>1, 4, 2, 5, 3</code>，对它做<code>step=1</code>的右循环。
这里放 方法3 的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> readynum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; readynum &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + k; ; j = (j + k) % nums.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(tmp, nums[j]);</span><br><span class="line">                readynum ++;</span><br><span class="line">                <span class="keyword">if</span>(j == i)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="best-time-to-buy-and-sell-stock-iv"><a
href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">188.Best
Time to Buy and Sell Stock IV</a>*</h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>一开始思路是常规的记忆化搜索，状态记录为<code>[第i天价格][剩下k次][是否在买入状态]</code>，是否买入状态是二值的，所以内存主要在于天数和次数的取值，小trick是k取值过大时候，可缩小到天数的<code>1/2</code>。结果还是超内存了，虽然网上看到有类似解法没超内存，不过看最大那组数据，还是不适合开二维数组的。</p>
<p>这题有个特别之处，当考察第<code>i</code>天时，并不关心这是多少天了，而关心的只是当前的盈利情况和剩下多少次交易机会，于是数组缩小为次数<code>k</code>这一维。两个数组分别表示剩下<code>k</code>次的买入状态余额和非买入状态余额，状态方程是<code>buy[k]=max(buy[k], sell[k-1] - price); sell[k]=max(sell[k], buy[k] + price);</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.<span class="built_in">size</span>() / <span class="number">2</span>)</span><br><span class="line">            k = prices.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(k + <span class="number">1</span>, <span class="number">-0x3f3f3f3f</span>)</span>, <span class="title">sell</span><span class="params">(k + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> price : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = k; i &gt; <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                buy[i] = <span class="built_in">max</span>(buy[i], sell[i - <span class="number">1</span>] - price);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = k; i &gt; <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                sell[i] = <span class="built_in">max</span>(sell[i], buy[i] + price);</span><br><span class="line">                ret = <span class="built_in">max</span>(sell[i], ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="repeated-dna-sequences"><a
href="https://leetcode.com/problems/repeated-dna-sequences/">187.Repeated
DNA Sequences</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>没遇到网上说的内存问题，直接unordered_map过掉了。用字典树应该会比较快和稳定吧。
对每个长度为10的串进行统计，大于1次就做记录。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">bool</span>&gt; mp;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">10</span>; i &lt;= s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp = s.<span class="built_in">substr</span>(i - <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(tmp))</span><br><span class="line">                mp[tmp] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mp[tmp] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                mp[tmp] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="largest-number"><a
href="https://leetcode.com/problems/largest-number/">179.Largest
Number</a></h3>
<p>一开始用递归写了个复杂逻辑的comp函数，后来发现，主要确定两个字符串 a,
b 的 a+b 和 b+a 的大小关系，就能确定 a 和 b 的顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b &gt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector vs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            vs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(num));</span><br><span class="line">        <span class="built_in">sort</span>(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">atoi</span>(vs[<span class="number">0</span>].<span class="built_in">c_str</span>()) == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : vs) res += v;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="dungeon-game"><a
href="https://leetcode.com/problems/dungeon-game/">174.Dungeon
Game</a></h3>
<p>从左上角开始 DP 的话，无法做到既贪心当前最优，又保证路径最优。</p>
<p>从右下角开始 DP，则可以只考虑路径最优，dp[i][j]表示从(i,
j)位置到终点所需最小health值。</p>
<p>这道题也可以用二分答案来直接从左上角贪心，不过速度会慢很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = dungeon.<span class="built_in">size</span>(), cols = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vectordp</span>(rows);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">vector</span>(cols, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = cols - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; rows - <span class="number">1</span> &amp;&amp; j &lt; cols - <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) - dungeon[i][j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; rows - <span class="number">1</span>) dp[i][j] = <span class="built_in">max</span>(<span class="number">1</span>, dp[i + <span class="number">1</span>][j] - dungeon[i][j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; cols - <span class="number">1</span>) dp[i][j] = <span class="built_in">max</span>(<span class="number">1</span>, dp[i][j + <span class="number">1</span>] - dungeon[i][j]);</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(<span class="number">1</span>, -dungeon[i][j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分答案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = <span class="number">0x3f3f3f3f</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Test</span>(mid, dungeon)) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> mid, vector tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = tmp.<span class="built_in">size</span>(), cols = tmp[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j ++) &#123; <span class="keyword">if</span>(i &amp;&amp; j &amp;&amp; tmp[i - <span class="number">1</span>][j] + mid &gt; <span class="number">0</span> &amp;&amp; tmp[i][j - <span class="number">1</span>] + mid &gt; <span class="number">0</span>)</span><br><span class="line">                    tmp[i][j] = <span class="built_in">max</span>(tmp[i - <span class="number">1</span>][j] + tmp[i][j], tmp[i][j - <span class="number">1</span>] + tmp[i][j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &amp;&amp; tmp[i - <span class="number">1</span>][j] + mid &gt; <span class="number">0</span>)</span><br><span class="line">                    tmp[i][j] = tmp[i - <span class="number">1</span>][j] + tmp[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &amp;&amp; tmp[i][j - <span class="number">1</span>] + mid &gt; <span class="number">0</span>)</span><br><span class="line">                    tmp[i][j] = tmp[i][j - <span class="number">1</span>] + tmp[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i || j)</span><br><span class="line">                    tmp[i][j] = -mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[rows - <span class="number">1</span>][cols - <span class="number">1</span>] + mid &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-search-tree-iterator"><a
href="https://leetcode.com/problems/binary-search-tree-iterator/">173.Binary
Search Tree Iterator</a></h3>
<p>变形的非递归中序遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    stack s;</span><br><span class="line">    TreeNode *now;</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line">        now = root;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(now);</span><br><span class="line">            now = now-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        now = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode *tmp = now;</span><br><span class="line">        now = now-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(now);</span><br><span class="line">            now = now-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="factorial-trailing-zeroes"><a
href="https://leetcode.com/problems/factorial-trailing-zeroes/">172.Factorial
Trailing Zeroes</a></h3>
<p>阶乘的每个数中，每个因子 2 和每个因子 5 可以构成一个0，而 2 远比 5
多，比如 8 就有三个 2，于是统计因子 5 的个数。</p>
<p>让输入 n 迭代除以 5，第一次得到 5 的倍数的个数，第二次是 25
倍数的个数，最后得到所有因子 5 的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">            ret += n /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="excel-sheet-column-number"><a
href="https://leetcode.com/problems/excel-sheet-column-number/">171.Excel
Sheet Column Number</a></h3>
<p>比用Number算Title容易点，在算每一位时候记得加 1 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">titleToNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">            ret = ret * <span class="number">26</span> + c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="majority-element"><a
href="https://leetcode.com/problems/majority-element/">169.Majority
Element</a></h3>
<p>很有意思的题目，要求的数占超过一半，那么在O(n)时间里把不同的数抵消掉，“多数数”肯定会被留下来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">                x = num, cnt ++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt += num == x ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="excel-sheet-column-title"><a
href="https://leetcode.com/problems/excel-sheet-column-title/">168.Excel
Sheet Column Title</a></h3>
<p>跳过 0 的 26 进制，处理每一位的时候要减 1 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += (n - <span class="number">1</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            n = (n - <span class="number">1</span>) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="fraction-to-recurring-decimal"><a
href="https://leetcode.com/problems/fraction-to-recurring-decimal/">166.Fraction
to Recurring Decimal</a></h3>
<p>有边界数据，所以直接转成long long做，处理正负号。</p>
<p>对小数部分，每次求余数乘 10
再做下一位，当余数重复出现就是循环了。找重复用unordered_map。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        string ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num = numerator, deno = denominator, nm;</span><br><span class="line">        <span class="keyword">if</span>(num * deno &lt; <span class="number">0</span>) ret = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        num = <span class="built_in">abs</span>(num), deno = <span class="built_in">abs</span>(deno);</span><br><span class="line">        ret += <span class="built_in">to_string</span>(num / deno);</span><br><span class="line">        <span class="keyword">if</span>(num % deno == <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        unordered_map mp;</span><br><span class="line">        ret += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> now = num % deno * <span class="number">10</span>; now; )</span><br><span class="line">        &#123;</span><br><span class="line">            mp[now] = ret.<span class="built_in">length</span>();</span><br><span class="line">            ret += <span class="string">&#x27;0&#x27;</span> + now / deno;</span><br><span class="line">            now = now % deno * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(now))</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">insert</span>(mp[now], <span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                ret += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="compare-version-numbers"><a
href="https://leetcode.com/problems/compare-version-numbers/">165.Compare
Version Numbers</a></h3>
<p>按<code>.</code>分开，逐个按数字大小比较。
C++怎么就没个方便的split函数呢。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">vpos1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">vpos2</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">lp1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">lp2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        version1 += <span class="string">&quot;.&quot;</span>, version2 += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(vpos1 &lt; version<span class="number">1.l</span>ength() || vpos2 &lt; version<span class="number">2.l</span>ength())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">vnum1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">vnum2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            vpos1 = version<span class="number">1.f</span>ind(<span class="string">&quot;.&quot;</span>, lp1);</span><br><span class="line">            vpos2 = version<span class="number">2.f</span>ind(<span class="string">&quot;.&quot;</span>, lp2);</span><br><span class="line">            <span class="keyword">if</span>(vpos1 &lt; version<span class="number">1.l</span>ength())</span><br><span class="line">                vnum1 = <span class="built_in">atoi</span>(version<span class="number">1.</span><span class="built_in">substr</span>(lp1, vpos1 - lp1).<span class="built_in">c_str</span>()), lp1 = vpos1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(vpos2 &lt; version<span class="number">2.l</span>ength()) </span><br><span class="line">                vnum2 = <span class="built_in">atoi</span>(version<span class="number">2.</span><span class="built_in">substr</span>(lp2, vpos2 - lp2).<span class="built_in">c_str</span>()), lp2 = vpos2 + <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span>(vnum1 &gt; vnum2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vnum1 &lt;vnum2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximum-gap"><a
href="https://leetcode.com/problems/maximum-gap/">164.Maximum
Gap</a></h3>
<p>很久没碰过桶排序了，这道题有个很有意思的推理——把 n 个数放到 n
个桶里，两种情形，1、每个桶一个数。2、存在有多个数的桶，那也一定有其他的空桶。</p>
<p>这两种情况下，最大gap都是某个桶的最小值与它前面最近的有数的桶的最大值之差，所以避免了桶内排序，O(n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGap</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> minNum = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gap = <span class="built_in">ceil</span>((<span class="type">double</span>)(maxNum - minNum) / (nums.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> bcnt = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(gap == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">bucket</span>(bcnt, <span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">int</span> bsite = (nums[i] - minNum) / gap; </span><br><span class="line">            <span class="keyword">if</span>(bucket[bsite].first == <span class="number">-1</span> || bucket[bsite].first &gt; nums[i])</span><br><span class="line">                bucket[bsite].first = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(bucket[bsite].second == <span class="number">-1</span> || bucket[bsite].second &lt; nums[i])</span><br><span class="line">                bucket[bsite].second = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> last = minNum, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucket.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i].first != <span class="number">-1</span>)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, bucket[i].first - last);</span><br><span class="line">            <span class="keyword">if</span>(bucket[i].second != <span class="number">-1</span>)</span><br><span class="line">                last = bucket[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="find-peak-element"><a
href="https://leetcode.com/problems/find-peak-element/">162.Find Peak
Element</a></h3>
<p><code>O(logn)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="intersection-of-two-linked-lists"><a
href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160.Intersection
of Two Linked Lists</a></h3>
<p>先统计两个链表长度，将 长链表 对准 距离末尾 与短链表长度相同
位置，同步遍历返回交叉点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> na, nb;</span><br><span class="line">        ListNode *ha = headA, *hb = headB;</span><br><span class="line">        <span class="keyword">for</span>(na = nb = <span class="number">0</span>; ha || hb;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ha) na ++, ha = ha-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(hb) nb ++, hb = hb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(na &gt; nb) headA = headA-&gt;next, na --;</span><br><span class="line">        <span class="keyword">while</span>(nb &gt; na) headB = headB-&gt;next, nb --;</span><br><span class="line">        <span class="keyword">while</span>(headA != headB) headA = headA-&gt;next, headB = headB-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="min-stack"><a
href="https://leetcode.com/problems/min-stack/">155.Min Stack</a></h3>
<p>一开始做的是每个元素存两个数的数组，一个表示数值，一个表示“上一个最小值下标”。然后觉得这样的话，不是最小值的那些位置，其实浪费了空间。
还是用两个数组或者两个栈，一个存数，一个存最小值好了。
看Discuss里24ms的答案也没什么特别的，运行时间的浮动吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    stack v;</span><br><span class="line">    stack m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">empty</span>() || x &lt;= m.<span class="built_in">top</span>())</span><br><span class="line">            m.<span class="built_in">push</span>(x);</span><br><span class="line">        v.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!m.<span class="built_in">empty</span>() &amp;&amp; m.<span class="built_in">top</span>() == v.<span class="built_in">top</span>())</span><br><span class="line">            m.<span class="built_in">pop</span>();</span><br><span class="line">        v.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="find-minimum-in-rotated-sorted-array-ii"><a
href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">154.Find
Minimum in Rotated Sorted Array II</a></h3>
<p>首先如果首尾大量相同元素，那么“先去掉末尾连续相同元素”和“二分的时候nums[mid]==nums[left]时left++”这样的方法，都会退化为O(n)。于是尽可能想二分的方法，有了下面这个分治的方法，然而经不起推敲，其实即便分治，还是会退化成O(n)。贴上两种代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &gt;= nums[right])</span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[left]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[left]) left ++;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">findRelMin</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRelMin</span><span class="params">(vector&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right - <span class="number">1</span>) <span class="keyword">return</span> nums[left];</span><br><span class="line">        <span class="type">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] == nums[right - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">findRelMin</span>(nums, left, mid);</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">findRelMin</span>(nums, mid, right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s = left, e = right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[s]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == e ? nums[s] : nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="find-minimum-in-rotated-sorted-array"><a
href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153.Find
Minimum in Rotated Sorted Array</a></h3>
<p>二分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == nums.<span class="built_in">size</span>() ? nums[<span class="number">0</span>] : nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximum-product-subarray"><a
href="https://leetcode.com/problems/maximum-product-subarray/">152.Maximum
Product Subarray</a></h3>
<p>维护当前位置连续乘积的最大值 tmpp 和最小值 tmpn
，最大值和最小值都可能由三种情况得到：上一个数的
tmpp<em>A[i]，上一个数的 tmpn</em>A[i]，A[i]本身。</p>
<p>不断更新答案，最终输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmpp = A[<span class="number">0</span>], tmpn = A[<span class="number">0</span>], tmp, ans = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmpp;</span><br><span class="line">            tmpp = <span class="built_in">max</span>(<span class="built_in">max</span>(A[i], A[i] * tmpp), A[i] * tmpn);</span><br><span class="line">            tmpn = <span class="built_in">min</span>(<span class="built_in">min</span>(A[i], A[i] * tmp), A[i] * tmpn);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmpp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-words-in-a-string"><a
href="http://oj.leetcode.com/problems/reverse-words-in-a-string/">151.Reverse
Words in a String</a></h3>
<p>先翻转整个字符串，然后从前往后一个单词一个单词地再翻转一次，同时去除多余空格，等于是扫描两遍，O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseWords</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start != s.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(start != s.<span class="built_in">length</span>() &amp;&amp; s[start] == <span class="string">&#x27; &#x27;</span>) start ++;</span><br><span class="line">            <span class="keyword">for</span>(end = start; end != s.<span class="built_in">length</span>() &amp;&amp; s[end] != <span class="string">&#x27; &#x27;</span>; end ++);</span><br><span class="line">            <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; start &lt;= end - <span class="number">1</span>) s[j ++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = end - <span class="number">1</span>; start &lt; i; start ++, i --)</span><br><span class="line">                <span class="built_in">swap</span>(s[i], s[start]), s[j ++] = s[start];</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end) s[j ++] = s[start ++];</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="evaluate-reverse-polish-notation"><a
href="http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/">150.Evaluate
Reverse Polish Notation</a></h3>
<p>逆波兰表达式计算四则运算。用栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector &amp;tokens)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        stack s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i ++) &#123; <span class="keyword">if</span>(<span class="built_in">isdigit</span>(tokens[i][<span class="number">0</span>]) || tokens[i].<span class="built_in">length</span>() &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">atoi</span>(tokens[i].<span class="built_in">c_str</span>()));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a = s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">            b = s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span>(tokens[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: s.<span class="built_in">push</span>(b + a); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: s.<span class="built_in">push</span>(b - a); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: s.<span class="built_in">push</span>(b * a); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: s.<span class="built_in">push</span>(b / a); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="max-points-on-a-line"><a
href="http://oj.leetcode.com/problems/max-points-on-a-line/">149.Max
Points on a Line</a></h3>
<p>平面上一条直线最多穿过多少点。乍一看好熟悉的问题，做了这么久计算几何。。。却还真没做过这个小问题。</p>
<p>第一反应当然不能O(n^3)枚举了，枚举圆周好像也不行，毕竟是考察所有点，不是某个点。那么应该就是哈希斜率了吧。</p>
<p>肯定少不了竖直的线，哈希斜率这不像是这类OJ让写的题吧。。忘了map这回事了。</p>
<p>确定思路之后，还是看看别人博客吧，少走点弯路，然后就学习了还有unordered_map这么个东西，<a
href="http://blog.csdn.net/tontkeng/article/details/17244361">还有一个博客</a>
的思路挺好，避免double问题，把斜率转化成化简的x、y组成字符串。</p>
<p>再另外就是重叠的点了，想让题目坑一点，怎能少得了这种数据，单独处理一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a point.</span></span><br><span class="line"><span class="comment"> * struct Point &#123;</span></span><br><span class="line"><span class="comment"> *     int x;</span></span><br><span class="line"><span class="comment"> *     int y;</span></span><br><span class="line"><span class="comment"> *     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector &amp;points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">            <span class="type">int</span> tmpans = <span class="number">0</span>, same = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = points[j].x - points[i].x, y = points[j].y - points[i].y;</span><br><span class="line">                <span class="type">int</span> g = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">                <span class="keyword">if</span>(g != <span class="number">0</span>) x /= g, y /= g;</span><br><span class="line">                <span class="keyword">else</span> &#123;same ++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x = -x, y = -y;</span><br><span class="line">                string tmp = <span class="built_in">to_string</span>(x) + <span class="string">&quot; &quot;</span> + <span class="built_in">to_string</span>(y);</span><br><span class="line">                <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(tmp)) mp[tmp] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> mp[tmp] ++;</span><br><span class="line">                tmpans = <span class="built_in">max</span>(tmpans, mp[tmp]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(tmpans + <span class="number">1</span> + same, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a ? <span class="built_in">gcd</span>(b % a, a) : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sort-list"><a
href="http://oj.leetcode.com/problems/sort-list/">148.Sort List</a></h3>
<p>又长见识了，原来链表也可以O(nlogn)排序的。没往下想就查了一下，看到人说用归并，于是才开始想能不能实现。。。</p>
<p>O(n)找到中点，把中点的next变成NULL，对两部分递归。递归结束后对两部分归并，先找到newhead，即两部分的头部val较小的那个，然后归并就把小的从newhead往后续。</p>
<p>把最后的next赋值NULL，返回newhead。</p>
<p>又有空数据@_@.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            n ++, p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> head; n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(-- n)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        ListNode *tmp = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *nl = <span class="built_in">sortList</span>(head);</span><br><span class="line">        ListNode *nr = <span class="built_in">sortList</span>(tmp);</span><br><span class="line">        ListNode *newhead;</span><br><span class="line">        <span class="keyword">if</span>(nl-&gt;val &lt; nr-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            newhead = nl;</span><br><span class="line">            nl = nl-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newhead = nr;</span><br><span class="line">            nr = nr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = newhead;</span><br><span class="line">        <span class="keyword">while</span>(nl != <span class="literal">NULL</span> &amp;&amp; nr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nl-&gt;val &lt; nr-&gt;val) p-&gt;next = nl, p = p-&gt;next, nl = nl-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = nr, p = p-&gt;next, nr = nr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nl != <span class="literal">NULL</span>) p-&gt;next = nl, p = p-&gt;next, nl = nl-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(nr != <span class="literal">NULL</span>) p-&gt;next = nr, p = p-&gt;next, nr = nr-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="insertion-sort-list"><a
href="http://oj.leetcode.com/problems/insertion-sort-list/">147.Insertion
Sort List</a></h3>
<p>指针操作很烦啊。。暴力枚举插入位置，注意细节就能过了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">insertionSortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *newhead = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        newhead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; newhead-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *tmp = head-&gt;next;</span><br><span class="line">                head-&gt;next = newhead;</span><br><span class="line">                newhead = head;</span><br><span class="line">                head = tmp;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode *pre = newhead, *p = newhead-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;val &lt; head-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lru-cache"><a
href="http://oj.leetcode.com/problems/lru-cache/">146.LRU Cache</a></h3>
<p>新建数据类class Val，保存key、val和访问自增标记updatecnt。</p>
<p>用unordered_map更新数据，增加updatecnt，并把更新的数据放入队列，最关键是处理capacity满了的时候，队列依次出队，map中不存在的和updatecnt和最新数据不相等的项目都忽略，直到发现updatecnt和map中存的最新状态相等，则为(最近未使用)数据，出队后在map中erase。思路有点像STL队列实现版本的Dijkstra。</p>
<p><a
href="http://blog.csdn.net/doc_sgl/article/details/15378513">有一个博客</a>
的方法更好，map中存的是链表的节点指针，链表顺序表示访问情况，这样就把map内容和链表的每个节点一一对应了，没有冗余节点，且更新操作也是O(1)的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Val</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> updatecnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Val&gt; mp;</span><br><span class="line">    queue q;</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            mp[key].updatecnt ++;</span><br><span class="line">            q.<span class="built_in">push</span>(mp[key]);</span><br><span class="line">            <span class="keyword">return</span> mp[key].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            mp[key].val = value;</span><br><span class="line">            mp[key].updatecnt ++;</span><br><span class="line">            q.<span class="built_in">push</span>(mp[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">size</span>() == cap)</span><br><span class="line">            &#123;</span><br><span class="line">                Val tmp;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(tmp.key) &amp;&amp; tmp.updatecnt == mp[tmp.key].updatecnt)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mp.<span class="built_in">erase</span>(mp.<span class="built_in">find</span>(tmp.key));</span><br><span class="line">                mp[key].key = key;</span><br><span class="line">                mp[key].val = value;</span><br><span class="line">                mp[key].updatecnt = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(mp[key]);</span><br><span class="line">            &#125;</span><br><span class="line">            mp[key].key = key;</span><br><span class="line">            mp[key].val = value;</span><br><span class="line">            mp[key].updatecnt = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(mp[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-postorder-traversal"><a
href="http://oj.leetcode.com/problems/binary-tree-postorder-traversal/">145.Binary
Tree Postorder Traversal</a></h3>
<p>二叉树的非递归后序遍历，考研的时候非常熟悉了，现在写又要想好久。重点是关于右子树遍历时候需要一个标记，或者标记根节点出栈次数，或者标记右子树是否访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *visited;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(root), root = root-&gt;left;</span><br><span class="line">            root = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span> || visited == root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                visited = root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-preorder-traversal"><a
href="http://oj.leetcode.com/problems/binary-tree-preorder-traversal/">144.Binary
Tree Preorder Traversal</a></h3>
<p>前序遍历的非递归就容易多了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            root = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>) s.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>) s.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reorder-list"><a
href="http://oj.leetcode.com/problems/reorder-list/">143.Reorder
List</a></h3>
<p>找到中间位置，把中间之后的链表反转，两个指针一个从头一个从尾开始互插，奇偶和指针绕得有点晕，理清就好了。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode *pre, *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">            n ++, p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>) <span class="keyword">return</span>; n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        pre = p = head;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(n --) p = p-&gt;next, pre = pre-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tail = pre;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp1 = p-&gt;next, *tmp2 = tail-&gt;next;</span><br><span class="line">            p-&gt;next = tail;</span><br><span class="line">            tail-&gt;next = tmp1;</span><br><span class="line">            p = tmp1;</span><br><span class="line">            <span class="keyword">if</span>(p == tail || p == tmp2) <span class="keyword">break</span>;</span><br><span class="line">            tail = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="linked-list-cycle-ii"><a
href="http://oj.leetcode.com/problems/linked-list-cycle-ii/">142.Linked
List Cycle II</a></h3>
<p>设置两个指针<code>slow</code>和<code>fast</code>，从<code>head</code>开始，<code>slow</code>一次一步，<code>fast</code>一次两步，如果<code>fast</code>能再次追上<code>slow</code>则有圈。
设<code>slow</code>走了<code>n</code>步，则<code>fast</code>走了<code>2*n</code>步，设圈长度m，圈起点到<code>head</code>距离为<code>k</code>，相遇位置距离圈起点为<code>t</code>，则有：</p>
<p><code>n = k + t + pm;</code> (1)</p>
<p><code>2*n = k + t + qm;</code>(2)</p>
<p>这里p和q是任意整数。（不过fast速度是slow二倍，则肯定在一圈内追上，p就是0了）</p>
<p><code>2 * (1) - (2)</code>
得<code>k = lm - t;(l = q - 2 * p)</code></p>
<p>即 <code>k</code> 的长度是若干圈少了 <code>t</code> 的长度。
因此这时候，一个指针从<code>head</code>开始，另一个从相遇位置开始，都每次只走一步，当从<code>head</code>开始的指针走到圈开始位置时，两指针刚好相遇。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *slow, *fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            <span class="keyword">if</span>(slow == <span class="literal">NULL</span> || fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)</span><br><span class="line">            slow = slow-&gt;next, fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="linked-list-cycle"><a
href="http://www.cnblogs.com/CSGrandeur/admin/Linked%20List%20Cycle%20">141.Linked
List Cycle</a></h3>
<p>呃，时间逆序做的结果。。。成买一送一了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *slow, *fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            <span class="keyword">if</span>(slow == <span class="literal">NULL</span> || fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-break-ii"><a
href="http://oj.leetcode.com/problems/word-break-ii/">140.Word Break
II</a></h3>
<p>先递推，<code>dp[i] == true</code> 表示 <code>s</code> 中前
<code>i</code> 个字符的串是符合要求的，枚举位置 <code>i</code> ，对于
<code>i</code> 枚举位置 <code>j &lt; i</code>，如果
<code>dp[j] == true</code>且
<code>j ~ i</code>的串在字典中，则<code>dp[i] = true</code>。</p>
<p>同时对于这样的 <code>j</code>,
<code>i</code>，<code>site[i].push_back(j)</code>，即在 <code>i</code>
位置的可行迭代表中增加位置 <code>j</code>。</p>
<p>完成site之后，从尾部倒着DFS过去就得到了所有串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">DFS</span><span class="params">(<span class="type">const</span> string &amp;s, vector *site, <span class="type">int</span> ith)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; site[ith].<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector tmp;</span><br><span class="line">            string str = s.<span class="built_in">substr</span>(site[ith][i], ith - site[ith][i]);</span><br><span class="line">            <span class="keyword">if</span>(site[site[ith][i]].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp = <span class="built_in">DFS</span>(s, site, site[ith][i]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; tmp.<span class="built_in">size</span>(); j ++)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(tmp[j] + <span class="string">&quot; &quot;</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">wordBreak</span><span class="params">(string s, unordered_set &amp;dict)</span> </span>&#123;</span><br><span class="line">        vector *site = <span class="keyword">new</span> vector[s.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="type">bool</span> *dp = <span class="keyword">new</span> <span class="type">bool</span>[s.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">bool</span>) * s.<span class="built_in">length</span>());</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] == <span class="literal">true</span> &amp;&amp; dict.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i - j)))</span><br><span class="line">                   site[i].<span class="built_in">push_back</span>(j), dp[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFS</span>(s, site, s.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-break"><a
href="http://oj.leetcode.com/problems/word-break/">139.Word
Break</a></h3>
<p>参考Word Break II，对于dp标记，当dp[i]为true时候可以停止枚举后面的
j，优化一下常数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, unordered_set &amp;dict)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> *dp = <span class="keyword">new</span> <span class="type">bool</span>[s.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">bool</span>) * (s.<span class="built_in">length</span>() + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[j] &amp;&amp; dict.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i - j));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">length</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="copy-list-with-random-pointer"><a
href="http://oj.leetcode.com/problems/copy-list-with-random-pointer/">138.Copy
List with Random Pointer</a></h3>
<p>第一次遍历，把每个节点复制一份放到对应节点的下一个，即组成二倍长的链表：<code>ori1-&gt;copy1-&gt;ori2-&gt;copy2-&gt;...</code></p>
<p>第二次遍历，利用<code>复制节点总是对应节点的下一个节点</code>特性，将每个<code>ori-&gt;next-&gt;random</code>指向<code>ori-&gt;random-&gt;next</code>，中间判断一下空指针。</p>
<p>第三次遍历，把两个链表拆开，恢复原链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        RandomListNode *p = head, *newhead = <span class="literal">NULL</span>, *tmp;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(p-&gt;label);</span><br><span class="line">            tmp-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = tmp;</span><br><span class="line">            p = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newhead = head-&gt;next;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            tmp-&gt;random = p-&gt;random == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : p-&gt;random-&gt;next;</span><br><span class="line">            p = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = tmp-&gt;next;</span><br><span class="line">            p = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = p == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="single-number-ii"><a
href="http://oj.leetcode.com/problems/single-number-ii/">137.Single
Number II</a></h3>
<p>方法一：设置cnt[32]记录
32个比特位的1的个数，出现3次的数的对应位的1总数为3的倍数，则统计之后每个位对3取模，剩下的位为1的则对应个数为1的那个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = A[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">33</span>; tmp &gt;&gt;= <span class="number">1</span>, j ++)</span><br><span class="line">                cnt[j] += tmp &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++)</span><br><span class="line">            ans |= (cnt[i] % <span class="number">3</span>) &lt;&lt; i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：设置int one,
two模拟两位二进制来统计各比特位1次数，每当one和two对应二进制位都为1的时候把one和two都清零，最后剩下的one就是要求的数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            two |= one &amp; A[i];</span><br><span class="line">            one ^= A[i];</span><br><span class="line">            <span class="type">int</span> tmp = one &amp; two;</span><br><span class="line">            two ^= tmp;</span><br><span class="line">            one ^= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="single-number"><a
href="http://oj.leetcode.com/problems/single-number/">136.Single
Number</a></h3>
<p>一路异或过去就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            tmp ^= A[i];</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="candy"><a
href="http://oj.leetcode.com/problems/candy/">135.Candy</a></h3>
<p>时间复杂度
<code>O(n)</code>的方法还是容易想了，优化为空间复杂度<code>O(1)</code>的话也不难，只是思考代码的时候会有点绕。</p>
<p>上坡一步步来，下坡走个等差数列，波峰位置比较一下上坡时候记录的最大值和下坡求的的最大值，取较大的，具体看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector &amp;ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, i, j, start, nownum;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ratings.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || ratings[i] == ratings[i - <span class="number">1</span>]) </span><br><span class="line">                nownum = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])</span><br><span class="line">                nownum ++;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.<span class="built_in">size</span>() &amp;&amp; ratings[i + <span class="number">1</span>] &lt; ratings[i])</span><br><span class="line">            &#123;</span><br><span class="line">                start = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; ratings.<span class="built_in">size</span>() &amp;&amp; ratings[j] &lt; ratings[j - <span class="number">1</span>]; start++, j ++); </span><br><span class="line">                <span class="keyword">if</span>(start &gt; nownum)</span><br><span class="line">                    cnt += (start + <span class="number">1</span>) * start &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt += ((start - <span class="number">1</span>) * start &gt;&gt; <span class="number">1</span>) + nownum;</span><br><span class="line">                nownum = <span class="number">1</span>;</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt += nownum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="gas-station"><a
href="http://oj.leetcode.com/problems/gas-station/">134.Gas
Station</a></h3>
<p>证明题。</p>
<p>一、如果从 i 到 j 的时候理论计算气量刚好为负数，则 i ~ j
的加气站都不可以作为起点。</p>
<p>反证一下，从前往后去掉站，如果去掉的站能增加气，即正数，则结果更糟。如果去掉的站是负数，那么负数如果抵消了之前的正数，则在到
j 之前已经负数了，如果不能抵消之前的正数，那么结果还是更糟。</p>
<p>二、判断是否能成行，一个环的和为非负就可以。</p>
<p>假设环为正， 0 ~ j 刚好为负， j + 1 ~ k 刚好为负数，k + 1
之后为正，则 k + 1 为答案。</p>
<p>也反证一下，k + 1 出发，到gas.size() - 1都为正，则转回来到 j - 1
都会为正。如果到 j 时候为负，则整个环不可能为正，所以到 j
的时候也为正，剩下的一样。这样就能够成功转一圈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector &amp;gas, vector &amp;cost)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> i, ans, sum, all;</span><br><span class="line">       <span class="keyword">for</span>(i = ans = sum = all = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i ++)</span><br><span class="line">       &#123;</span><br><span class="line">           sum += gas[i] - cost[i];</span><br><span class="line">           all += gas[i] - cost[i];</span><br><span class="line">           <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123; sum = <span class="number">0</span>; ans = i + <span class="number">1</span>; &#125; &#125; <span class="keyword">return</span> all &gt;= <span class="number">0</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="clone-graph"><a
href="http://oj.leetcode.com/problems/clone-graph/">133.Clone
Graph</a></h3>
<p>label是唯一的，递归，用unordered_map标记。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, UndirectedGraphNode *&gt; mp;</span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span> || mp.<span class="built_in">count</span>(node-&gt;label)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        UndirectedGraphNode *tmp = <span class="keyword">new</span> <span class="built_in">UndirectedGraphNode</span>(node-&gt;label);</span><br><span class="line">        mp[node-&gt;label] = tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cloneGraph</span>(node-&gt;neighbors[i]);</span><br><span class="line">            tmp-&gt;neighbors.<span class="built_in">push_back</span>(mp[node-&gt;neighbors[i]-&gt;label]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="palindrome-partitioning-ii"><a
href="http://oj.leetcode.com/problems/palindrome-partitioning-ii/">132.Palindrome
Partitioning II</a></h3>
<p>O(n^2)的动态规划。</p>
<p><code>cutdp[i]</code> 表示前 <code>i</code> 个字符最小切割几次。</p>
<p><code>paldp[i][j] == true</code> 表示 <code>i ~ j</code> 是回文。</p>
<p>在枚举 i 和 i 之前的所有 j 的过程中就得到了 paldp[j][i]
的所有回文判断，而对于 i + 1，paldp[j][i + 1]可由 s[j]、s[i + 1]、dp[j +
1][i]在O(1)判断。</p>
<p>cutdp[i]为所有 j (j &lt; i)，当paldp[j + 1][i] true的 cutdp[j] +
1的最小值。注意一下边界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> paldp[s.<span class="built_in">length</span>()][s.<span class="built_in">length</span>()];</span><br><span class="line">        <span class="type">int</span> cutdp[s.<span class="built_in">length</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123; cutdp[i] = <span class="number">0x3f3f3f3f</span>; <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">-1</span>; j --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">at</span>(j + <span class="number">1</span>) == s.<span class="built_in">at</span>(i) &amp;&amp; (j + <span class="number">2</span> &gt;= i - <span class="number">1</span> || paldp[j + <span class="number">2</span>][i - <span class="number">1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    paldp[j + <span class="number">1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                    cutdp[i] = <span class="built_in">min</span>(cutdp[i], (j &gt;= <span class="number">0</span> ? (cutdp[j] + <span class="number">1</span>) : <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    paldp[j + <span class="number">1</span>][i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cutdp[s.<span class="built_in">length</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="palindrome-partitioning"><a
href="http://oj.leetcode.com/problems/palindrome-partitioning/">131.Palindrome
Partitioning</a></h3>
<p>O(n^2)动态规划，<code>paldp[i][j] == true</code>表示
<code>i ~ j</code> 是回文。这里DP的方法是基本的，不再多说。</p>
<p>得到paldp之后，DFS一下就可以了。因为单字符是回文，所以DFS的终点肯定都是解，所以不必利用其他的结构存储答案信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vectorres;</span><br><span class="line">    vector tmp;</span><br><span class="line">    <span class="type">bool</span> **paldp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(string s, <span class="type">int</span> ith)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ith == s.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = ith; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(paldp[ith][i])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(ith, i - ith + <span class="number">1</span>));</span><br><span class="line">                <span class="built_in">DFS</span>(s, i + <span class="number">1</span>);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">partition</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        paldp = <span class="keyword">new</span> <span class="type">bool</span>*[s.<span class="built_in">length</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            paldp[i] = <span class="keyword">new</span> <span class="type">bool</span>[s.<span class="built_in">length</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">                paldp[j][i] = s.<span class="built_in">at</span>(i) == s.<span class="built_in">at</span>(j) &amp;&amp; (j + <span class="number">1</span> &gt;= i - <span class="number">1</span> || paldp[j + <span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">DFS</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="surrounded-regions"><a
href="http://oj.leetcode.com/problems/surrounded-regions/">130.Surrounded
Regions</a></h3>
<p>周围四条边的O做起点搜索替换为第三种符号，再遍历所有符号把O换成X，第三种符号换回O。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    queue q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> width = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> height = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; width; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[<span class="number">0</span>][i] = <span class="string">&#x27;#&#x27;</span>, q.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">if</span>(board[height - <span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[height - <span class="number">1</span>][i] = <span class="string">&#x27;#&#x27;</span>, q.<span class="built_in">push</span>(<span class="built_in">pii</span>(height - <span class="number">1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; height - <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[i][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>, q.<span class="built_in">push</span>(<span class="built_in">pii</span>(i, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(board[i][width - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[i][width - <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>, q.<span class="built_in">push</span>(<span class="built_in">pii</span>(i, width - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pii now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) </span><br><span class="line">            &#123; </span><br><span class="line">               <span class="type">int</span> ty = now.first + dx[i]; </span><br><span class="line">               <span class="type">int</span> tx = now.second + dy[i]; </span><br><span class="line">               <span class="keyword">if</span>(tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; width &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; height &amp;&amp; board[ty][tx] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   board[ty][tx] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                   q.<span class="built_in">push</span>(<span class="built_in">pii</span>(ty, tx));</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sum-root-to-leaf-numbers"><a
href="http://oj.leetcode.com/problems/sum-root-to-leaf-numbers/">129.Sum
Root to Leaf Numbers</a></h3>
<p>遍历一遍加起来。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(TreeNode *now, <span class="type">int</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left == <span class="literal">NULL</span> &amp;&amp; now-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += tmp * <span class="number">10</span> + now-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(now-&gt;left, tmp * <span class="number">10</span> + now-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(now-&gt;right, tmp * <span class="number">10</span> + now-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-consecutive-sequence"><a
href="http://oj.leetcode.com/problems/longest-consecutive-sequence/">128.Longest
Consecutive Sequence</a></h3>
<p>方法一：一开始竟然想了并查集，其实绕弯了，多此一举。哈希+并查集，把每个数哈希，枚举每个数看相邻的数在不在数组里，并查集合并，只是并查集的复杂度要比O(1)大一些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp, cnt;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fa</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i == mp[i] ? i : (mp[i] = <span class="built_in">fa</span>(mp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            mp[num[i]] = num[i], cnt[num[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(num[i] + <span class="number">1</span>) &amp;&amp; <span class="built_in">fa</span>(num[i]) != <span class="built_in">fa</span>(num[i] + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[<span class="built_in">fa</span>(num[i] + <span class="number">1</span>)] += cnt[<span class="built_in">fa</span>(num[i])];</span><br><span class="line">                ans = <span class="built_in">max</span>(cnt[<span class="built_in">fa</span>(num[i] + <span class="number">1</span>)], ans);</span><br><span class="line">                mp[<span class="built_in">fa</span>(num[i])] = <span class="built_in">fa</span>(num[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：哈希+枚举相邻数。相邻的数在数组里的话，每个数至多访问一次；相邻的数不在数组里的话，枚举会中断。所以设哈希复杂度为O(1)的话，这个方法是严格的O(n)。</p>
<p>其实这个题的数据挺善良，如果出了<code>2147483647</code>,
<code>-2147483648</code>，那还是用long long 稳妥些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            vis[num[i]] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[num[i]] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = num[i]; vis.<span class="built_in">count</span>(j); j ++, cnt ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = num[i] - <span class="number">1</span>; vis.<span class="built_in">count</span>(j); j --, cnt ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-ladder-ii"><a
href="http://oj.leetcode.com/problems/word-ladder-ii/">127.Word Ladder
II</a></h3>
<p>用数组类型的队列，BFS过程中记录pre路径，搜完后迭代回去保存路径。</p>
<p>似乎卡了常数，用queue队列，另外存路径的方法超时了。</p>
<p>想更快就双向广搜吧。让我想起了POJ那个八数码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">int</span> pace;</span><br><span class="line">    <span class="type">int</span> pre;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(string s, <span class="type">int</span> pa, <span class="type">int</span> pr)</span><br><span class="line">    &#123;</span><br><span class="line">        str = s;</span><br><span class="line">        pace = pa;</span><br><span class="line">        pre = pr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">findLadders</span><span class="params">(string start, string end, unordered_set &amp;dict)</span> </span>&#123;</span><br><span class="line">        vector q;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(end, <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; dis;</span><br><span class="line">        dis[end] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">            Node now = q[i]; </span><br><span class="line">            <span class="keyword">if</span>(dis.<span class="built_in">count</span>(start) &amp;&amp; now.pace &gt;= dis[start])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; now.str.<span class="built_in">length</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                string tmp = now.str;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c ++) </span><br><span class="line">                &#123; </span><br><span class="line">                   tmp[j] = c; </span><br><span class="line">                   <span class="keyword">if</span>((dict.<span class="built_in">count</span>(tmp) || tmp == start) &amp;&amp; (!dis.<span class="built_in">count</span>(tmp) || dis[tmp] == now.pace + <span class="number">1</span>)) </span><br><span class="line">                   &#123; </span><br><span class="line">                       dis[tmp] = now.pace + <span class="number">1</span>; </span><br><span class="line">                       q.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(tmp, now.pace + <span class="number">1</span>, i)); </span><br><span class="line">                   &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; q[i].pace == dis[start]; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].str == start)</span><br><span class="line">            &#123;</span><br><span class="line">                vector tmp;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i; j != <span class="number">-1</span>; j = q[j].pre)</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(q[j].str);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-ladder"><a
href="http://oj.leetcode.com/problems/word-ladder/">126.Word
Ladder</a></h3>
<p>直接BFS。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string start, string end, unordered_set &amp;dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;string, <span class="type">int</span>&gt; pii;</span><br><span class="line">        unordered_set flag;</span><br><span class="line">        queue q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">pii</span>(start, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pii now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; now.first.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                string tmp = now.first;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> j = <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[i] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tmp == end) <span class="keyword">return</span> now.second + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dict.<span class="built_in">count</span>(tmp) &amp;&amp; !flag.<span class="built_in">count</span>(tmp))</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">pii</span>(tmp, now.second + <span class="number">1</span>));</span><br><span class="line">                        flag.<span class="built_in">insert</span>(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="valid-palindrome"><a
href="http://oj.leetcode.com/problems/valid-palindrome/">125.Valid
Palindrome</a></h3>
<p>做过刘汝佳 白书的人想必都知道ctype.h和isdigit(), isalpha(),
tolower(), toupper()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">char</span> &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="built_in">tolower</span>(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isdigit</span>(x) || <span class="built_in">isalpha</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &lt; j; i ++, j --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">valid</span>(s[i]) &amp;&amp; i &lt; s.<span class="built_in">length</span>()) i ++; <span class="keyword">while</span>(!<span class="built_in">valid</span>(s[j]) &amp;&amp; j &gt;= <span class="number">0</span>) j --;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j &amp;&amp; s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-maximum-path-sum"><a
href="http://oj.leetcode.com/problems/binary-tree-maximum-path-sum/">124.Binary
Tree Maximum Path Sum</a></h3>
<p>后续遍历，子问题为子树根节点向叶子节点出发的最大路径和。</p>
<p>即 l = DFS(now-&gt;left), r = DFS(now-&gt;right)。</p>
<p>此时，ans可能是
now-&gt;valid,可能是左边一路上来加上now-&gt;valid，可能是右边一路上来，也可能是左边上来经过now再右边一路下去，四种情况。</p>
<p>四种情况更新完ans后，now返回上一层只能是
now-&gt;valid或左边一路上来或右边一路上来，三种情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">DFS</span>(now-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">DFS</span>(now-&gt;right), <span class="number">0</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, l + r + now-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l + now-&gt;val, r + now-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="best-time-to-buy-and-sell-stock-iii"><a
href="http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">123.Best
Time to Buy and Sell Stock III</a></h3>
<p>前缀pre[i]处理 0 ~ i 买卖一次最优解，后缀suf[i]处理 i ~ prices.size()
- 1 买卖一次最优解。</p>
<p>所有位置pre[i] + suf[i]最大值为答案O(n)。</p>
<p>处理最优解的时候是维护前（后）缀prices最小（大）值，与当前prices做差后和前（后）缀最优解比较取最优，O(n)。</p>
<p>总复杂度O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">pre</span><span class="params">(prices.size())</span>, <span class="title">suf</span><span class="params">(prices.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, mtmp = <span class="number">0x3f3f3f3f</span>; i &lt; prices.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">           mtmp = i ? <span class="built_in">min</span>(mtmp, prices[i]) : prices[i]; </span><br><span class="line">           pre[i] = <span class="built_in">max</span>(prices[i] - mtmp, i ? pre[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = prices.<span class="built_in">size</span>() - <span class="number">1</span>, mtmp = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            mtmp = i != prices.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="built_in">max</span>(mtmp, prices[i]) : prices[i];</span><br><span class="line">            suf[i] = <span class="built_in">max</span>(mtmp - prices[i], i != prices.<span class="built_in">size</span>() - <span class="number">1</span> ? suf[i + <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre[i] + suf[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="best-time-to-buy-and-sell-stock-ii"><a
href="http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122.Best
Time to Buy and Sell Stock II</a></h3>
<p>可以买卖多次，把所有上坡差累加即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i ++) &#123; <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                ans += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="best-time-to-buy-and-sell-stock"><a
href="http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/">121.Best
Time to Buy and Sell Stock</a></h3>
<p>维护前（后）缀最小（大）值，和当前prices做差更新答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = prices.<span class="built_in">size</span>() - <span class="number">1</span>, mtmp = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            mtmp = <span class="built_in">max</span>(mtmp, prices[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(mtmp - prices[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="triangle"><a
href="http://oj.leetcode.com/problems/triangle/">120.Triangle</a></h3>
<p>竟然遇到了ACM递推入门题，想必无数ACMer对这题太熟悉了。</p>
<p>从下往上递推，一维数组滚动更新即可。这里懒省事，直接把原数组改了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector &amp;triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = triangle.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>(); j ++)</span><br><span class="line">                triangle[i][j] = <span class="built_in">min</span>(triangle[i][j] + triangle[i + <span class="number">1</span>][j], triangle[i][j] + triangle[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle.<span class="built_in">size</span>() == <span class="number">0</span> ? <span class="number">0</span> : triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="pascals-triangle-ii"><a
href="http://oj.leetcode.com/problems/pascals-triangle-ii/">119.Pascal's
Triangle II</a></h3>
<p>滚动数组递推，从后往前以便不破坏上一层递推数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">ans</span><span class="params">(rowIndex + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i ++) &#123; <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[j] = (i == <span class="number">0</span> || j == <span class="number">0</span> || j == i ? <span class="number">1</span> : ans[j] + ans[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="pascals-triangle"><a
href="http://oj.leetcode.com/problems/pascals-triangle/">118.Pascal's
Triangle</a></h3>
<p>递推。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">generate</span><span class="params">(<span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        vector v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(i == <span class="number">0</span> || j == <span class="number">0</span> || j == i ? <span class="number">1</span> : v[i - <span class="number">1</span>][j] + v[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            v.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="populating-next-right-pointers-in-each-node-ii"><a
href="http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">117.Populating
Next Right Pointers in Each Node II</a></h3>
<p>题目要求空间复杂度O(1)，所以递归、队列等传统方法不应该用。</p>
<p>本题可以利用生成的next指针来横向扫描，即得到一层的next指针之后，可以利用这一层的next指针来给下一层的next指针赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode *<span class="title">findNext</span><span class="params">(TreeLinkNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span> &amp;&amp; head-&gt;left == <span class="literal">NULL</span> &amp;&amp; head-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode *head, *last, *nexhead;</span><br><span class="line">        <span class="keyword">for</span>(head = root; head != <span class="literal">NULL</span>; head = nexhead)</span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="built_in">findNext</span>(head);</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;left != <span class="literal">NULL</span>) nexhead = head-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> nexhead = head-&gt;right;</span><br><span class="line">            <span class="keyword">for</span>(last = <span class="literal">NULL</span>; head != <span class="literal">NULL</span>; last = head, head = <span class="built_in">findNext</span>(head-&gt;next))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;left != <span class="literal">NULL</span> &amp;&amp; head-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(last == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(last-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">                    last-&gt;right-&gt;next = head-&gt;left != <span class="literal">NULL</span> ? head-&gt;left : head-&gt;right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                    last-&gt;left-&gt;next = head-&gt;left != <span class="literal">NULL</span> ? head-&gt;left : head-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="populating-next-right-pointers-in-each-node"><a
href="http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node/">116.Populating
Next Right Pointers in Each Node</a></h3>
<p>不用考虑连续的空指针，就不用额外实现找下一个子树非空节点，比Populating
Next Right Pointers in Each Node II 容易处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode *head, *nexhead, *last;</span><br><span class="line">        <span class="keyword">for</span>(head = root; head-&gt;left != <span class="literal">NULL</span>; head = nexhead)</span><br><span class="line">        &#123;</span><br><span class="line">            nexhead = head-&gt;left;</span><br><span class="line">            last = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(last != <span class="literal">NULL</span>) last-&gt;right-&gt;next = head-&gt;left;</span><br><span class="line">                last = head;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="distinct-subsequences"><a
href="http://oj.leetcode.com/problems/distinct-subsequences/">115.Distinct
Subsequences</a></h3>
<p>典型动态规划。dp[i][j] 表示 T 的前 j 个字符在 S 的前 i
个字符中的解。</p>
<p>对于dp[i + 1][j + 1]，由两部分组成：</p>
<p>一、 j + 1 对应到 S 前 i 个字符中的解，忽略 S 的第 i + 1 个字符。</p>
<p>二、判断 S 的第 i + 1 个字符是否和 T 的第 j + 1
个字符相同，如果相同，则加上dp[i][j]，否则不加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.<span class="built_in">length</span>() &lt; T.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">dp</span><span class="params">(S.length() + <span class="number">1</span>, vector(T.length() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; T.<span class="built_in">length</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(S[i] == T[j]) dp[i + <span class="number">1</span>][j + <span class="number">1</span>] += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[S.<span class="built_in">length</span>()][T.<span class="built_in">length</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="flatten-binary-tree-to-linked-list"><a
href="http://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">114.Flatten
Binary Tree to Linked List</a></h3>
<p>题意是优先左子树靠前，且排成一列用右子树指针，不管val的大小关系。</p>
<p>后序遍历一遍即可，递归返回子树中尾节点指针，注意各种条件判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">DFS</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left == <span class="literal">NULL</span> &amp;&amp; now-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> now;</span><br><span class="line">        TreeNode *leftok = <span class="literal">NULL</span>, *rightok = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>) leftok = <span class="built_in">DFS</span>(now-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>) rightok = <span class="built_in">DFS</span>(now-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftok != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            leftok-&gt;right = now-&gt;right;</span><br><span class="line">            now-&gt;right = now-&gt;left;</span><br><span class="line">            now-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> rightok ? rightok : leftok;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> rightok;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="path-sum-ii"><a
href="http://oj.leetcode.com/problems/path-sum-ii/">113.Path Sum
II</a></h3>
<p>传统递归，把路径上的数字插入vector，终点判断是否插入答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> goal;</span><br><span class="line">    vectorv;</span><br><span class="line">    vector curv;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(TreeNode *now, <span class="type">int</span> cursum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        curv.<span class="built_in">push_back</span>(now-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left == <span class="literal">NULL</span> &amp;&amp; now-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cursum + now-&gt;val == goal)</span><br><span class="line">            &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(curv);</span><br><span class="line">                curv.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>) <span class="built_in">DFS</span>(now-&gt;left, cursum + now-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>) <span class="built_in">DFS</span>(now-&gt;right, cursum + now-&gt;val);</span><br><span class="line">        curv.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">pathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        goal = sum;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="built_in">DFS</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="path-sum"><a
href="http://oj.leetcode.com/problems/path-sum/">112.Path Sum</a></h3>
<p>遍历树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> goal;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode *now, <span class="type">int</span> cursum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left == <span class="literal">NULL</span> &amp;&amp; now-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> cursum + now-&gt;val == goal;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">DFS</span>(now-&gt;left, cursum + now-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">DFS</span>(now-&gt;right, cursum + now-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        goal = sum;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFS</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="minimum-depth-of-binary-tree"><a
href="http://oj.leetcode.com/problems/minimum-depth-of-binary-tree/">111.Minimum
Depth of Binary Tree</a></h3>
<p>还是遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="balanced-binary-tree"><a
href="http://oj.leetcode.com/problems/balanced-binary-tree/">110.Balanced
Binary Tree</a></h3>
<p>遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">maxDepth</span>(now-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">maxDepth</span>(now-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(l - r) &gt; <span class="number">1</span> || l &lt; <span class="number">0</span> || r &lt; <span class="number">0</span> ? <span class="number">-2</span> : <span class="built_in">max</span>(l, r); &#125; <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">maxDepth</span>(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="convert-sorted-list-to-binary-search-tree"><a
href="http://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">109.Convert
Sorted List to Binary Search Tree</a></h3>
<p>每次找中点作为根节点，将两边递归，返回根节点指针作为左右节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedListToBST</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *p, *mid, *pre;</span><br><span class="line">        <span class="keyword">for</span>(p = mid = head, pre = <span class="literal">NULL</span>; p-&gt;next != <span class="literal">NULL</span>; mid = mid-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre = mid;</span><br><span class="line">        &#125;;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span>) pre-&gt;next = <span class="literal">NULL</span>, root-&gt;left = <span class="built_in">sortedListToBST</span>(head);</span><br><span class="line">        <span class="keyword">else</span> root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="built_in">sortedListToBST</span>(mid-&gt;next);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span>) pre-&gt;next = mid;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="convert-sorted-array-to-binary-search-tree"><a
href="http://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">108.Convert
Sorted Array to Binary Search Tree</a></h3>
<p>递归做，比链表的容易些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">convert</span><span class="params">(vector &amp;num, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == left) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> mid = right + left &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">convert</span>(num, left, mid);</span><br><span class="line">        root-&gt;right = <span class="built_in">convert</span>(num, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">convert</span>(num, <span class="number">0</span>, num.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-level-order-traversal-ii"><a
href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/">107.Binary
Tree Level Order Traversal II</a></h3>
<p>宽搜和深搜都可以，找对层数就行了。</p>
<p>本以为这题亮点是如何一遍实现从底向上顺序的vector，AC之后上网一查也全是最后把vector翻转的。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vectorv;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(TreeNode *now, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">size</span>() &lt;= depth) v.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>)); v[depth].<span class="built_in">push_back</span>(now-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>) <span class="built_in">DFS</span>(now-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>) <span class="built_in">DFS</span>(now-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">levelOrderBottom</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="built_in">DFS</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = v.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i ++, j --)</span><br><span class="line">            <span class="built_in">swap</span>(v[i], v[j]);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="construct-binary-tree-from-inorder-and-postorder-traversal"><a
href="http://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106.Construct
Binary Tree from Inorder and Postorder Traversal</a></h3>
<p>数据结构经典题。后序遍历的结尾是根节点
Proot，在中序遍历中找到这个节点 Iroot，则
Iroot两边即为左右子树。根据左右子树节点个数，在后序遍历中找到左右子树分界（左右子树肯定不交叉），则几个关键分界点都找到了，对左右子树递归。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">build</span><span class="params">(vector &amp;inorder, <span class="type">int</span> ileft, <span class="type">int</span> iright, vector &amp;postorder, <span class="type">int</span> pleft, <span class="type">int</span> pright)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(iright == ileft)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> root;</span><br><span class="line">        <span class="keyword">for</span>(root = ileft; inorder[root] != postorder[pright - <span class="number">1</span>]; root ++);</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(inorder[root]);</span><br><span class="line">        node-&gt;left = <span class="built_in">build</span>(inorder, ileft, root, postorder, pleft, pleft + root - ileft);</span><br><span class="line">        node-&gt;right = <span class="built_in">build</span>(inorder, root + <span class="number">1</span>, iright, postorder, pleft + root - ileft, pright - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector &amp;inorder, vector &amp;postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="construct-binary-tree-from-preorder-and-inorder-traversal"><a
href="http://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.Construct
Binary Tree from Preorder and Inorder Traversal</a></h3>
<p>和上一题Construct Binary Tree from Inorder and Postorder
Traversal方法一样，前序和后序的信息作用相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">build</span><span class="params">(vector &amp;inorder, <span class="type">int</span> ileft, <span class="type">int</span> iright, vector &amp;preorder, <span class="type">int</span> pleft, <span class="type">int</span> pright)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(iright == ileft)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> root;</span><br><span class="line">        <span class="keyword">for</span>(root = ileft; inorder[root] != preorder[pleft]; root ++);</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(inorder[root]);</span><br><span class="line">        node-&gt;left = <span class="built_in">build</span>(inorder, ileft, root, preorder, pleft + <span class="number">1</span>, pleft + root - ileft);</span><br><span class="line">        node-&gt;right = <span class="built_in">build</span>(inorder, root + <span class="number">1</span>, iright, preorder, pleft + root - ileft + <span class="number">1</span>, pright);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector &amp;preorder, vector &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximum-depth-of-binary-tree"><a
href="http://oj.leetcode.com/problems/maximum-depth-of-binary-tree/">104.Maximum
Depth of Binary Tree</a></h3>
<p>遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">maxDepth</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">maxDepth</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-zigzag-level-order-traversal"><a
href="http://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">103.Binary
Tree Zigzag Level Order Traversal</a></h3>
<p>BFS，奇偶层轮流走，一层左到右，一层右到左。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        vector&lt;TreeNode*&gt; q1, q2;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q<span class="number">1.</span><span class="built_in">empty</span>() || !q<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = q<span class="number">1.</span><span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[depth].<span class="built_in">push_back</span>(q1[i]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q1[i]-&gt;left != <span class="literal">NULL</span>) q<span class="number">2.</span><span class="built_in">push_back</span>(q1[i]-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(q1[i]-&gt;right != <span class="literal">NULL</span>) q<span class="number">2.</span><span class="built_in">push_back</span>(q1[i]-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth ++;</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span>(q<span class="number">2.</span><span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = q<span class="number">2.</span><span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[depth].<span class="built_in">push_back</span>(q2[i]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q2[i]-&gt;right != <span class="literal">NULL</span>) q<span class="number">1.</span><span class="built_in">push_back</span>(q2[i]-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(q2[i]-&gt;left != <span class="literal">NULL</span>) q<span class="number">1.</span><span class="built_in">push_back</span>(q2[i]-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">clear</span>();</span><br><span class="line">            depth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-level-order-traversal"><a
href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal/">102.Binary
Tree Level Order Traversal</a></h3>
<p>懒省事直接在上一题Binary Tree Zigzag Level Order
Traversal的代码上改了一下。</p>
<p>只用一个队列的话，增加个层数信息存队列里即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">levelOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        vector&lt;TreeNode*&gt; q1, q2;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q<span class="number">1.</span><span class="built_in">empty</span>() || !q<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q<span class="number">1.</span><span class="built_in">size</span>(); i ++) &#123; ans[depth].<span class="built_in">push_back</span>(q1[i]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q1[i]-&gt;left != <span class="literal">NULL</span>) q<span class="number">2.</span><span class="built_in">push_back</span>(q1[i]-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(q1[i]-&gt;right != <span class="literal">NULL</span>) q<span class="number">2.</span><span class="built_in">push_back</span>(q1[i]-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth ++;</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span>(q<span class="number">2.</span><span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q<span class="number">2.</span><span class="built_in">size</span>(); i ++) &#123; ans[depth].<span class="built_in">push_back</span>(q2[i]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q2[i]-&gt;left != <span class="literal">NULL</span>) q<span class="number">1.</span><span class="built_in">push_back</span>(q2[i]-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(q2[i]-&gt;right != <span class="literal">NULL</span>) q<span class="number">1.</span><span class="built_in">push_back</span>(q2[i]-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">clear</span>();</span><br><span class="line">            depth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="symmetric-tree"><a
href="http://oj.leetcode.com/problems/symmetric-tree/">101.Symmetric
Tree</a></h3>
<p>递归：左指针和右指针，对称递归，即(左的左)和(右的右)对应，(左的右)和(右的左)对应。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(TreeNode *l, TreeNode *r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;val != r-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;left != r-&gt;right &amp;&amp; (l-&gt;left == <span class="literal">NULL</span> || r-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        || l-&gt;right != r-&gt;left &amp;&amp; (l-&gt;right == <span class="literal">NULL</span> || r-&gt;left == <span class="literal">NULL</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;left != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">judge</span>(l-&gt;left, r-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;right != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">judge</span>(l-&gt;right, r-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span></span><br><span class="line">            || root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>非递归：左右子树分别做一个队列，同步遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span></span><br><span class="line">            || root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue q1, q2;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!q<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *now1 = q<span class="number">1.f</span>ront(), *now2 = q<span class="number">2.f</span>ront();</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(now1-&gt;val != now2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(now1-&gt;left != <span class="literal">NULL</span> || now2-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now1-&gt;left == <span class="literal">NULL</span> || now2-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q<span class="number">1.</span><span class="built_in">push</span>(now1-&gt;left);</span><br><span class="line">                q<span class="number">2.</span><span class="built_in">push</span>(now2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now1-&gt;right != <span class="literal">NULL</span> || now2-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now1-&gt;right == <span class="literal">NULL</span> || now2-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q<span class="number">1.</span><span class="built_in">push</span>(now1-&gt;right);</span><br><span class="line">                q<span class="number">2.</span><span class="built_in">push</span>(now2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="same-tree"><a
href="http://oj.leetcode.com/problems/same-tree/">100.Same Tree</a></h3>
<p>同步遍历，比较判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p != q &amp;&amp; (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="recover-binary-search-tree"><a
href="http://oj.leetcode.com/problems/recover-binary-search-tree/">99.Recover
Binary Search Tree</a></h3>
<p>中序遍历是二叉查找树的顺序遍历，<em>a,
<em>b表示前驱节点和当前节点，因为只有一对数值翻转了，所以肯定会遇到前驱节点val比当前节点val大的情况一次或两次，遇到一次表示翻转的是相邻的两个节点。</em>ans1和</em>ans2指向两个被翻转的节点，当遇到前驱val比当前val大的情况时候，根据第一次还是第二次给ans1和ans2赋值，最终翻转回来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *a, *b;</span><br><span class="line">    TreeNode *ans1, *ans2;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">DFS</span>(now-&gt;left);</span><br><span class="line">        a = b;</span><br><span class="line">        b = now;</span><br><span class="line">        <span class="keyword">if</span>(a != <span class="literal">NULL</span> &amp;&amp; a-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans1 == <span class="literal">NULL</span>) ans1 = a;</span><br><span class="line">            ans2 = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">DFS</span>(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        a = b = ans1 = ans2 = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(ans1-&gt;val, ans2-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="validate-binary-search-tree"><a
href="http://oj.leetcode.com/problems/validate-binary-search-tree/">98.Validate
Binary Search Tree</a></h3>
<p>中序遍历，更新前驱节点，与当前节点比较。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">isValidBST</span>(root-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">isValidBST</span>(root-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="interleaving-string"><a
href="http://oj.leetcode.com/problems/interleaving-string/">97.Interleaving
String</a></h3>
<p>动态规划。如果结果是true，则任意 <code>i</code>,
<code>j</code>，<code>s1[i]</code> 之前的字符 和
<code>s2[j]</code>之前的字符，都能够交叉为 <code>s3[i + j]</code>
之前的字符。</p>
<p>由此，当<code>dp[i][j]</code>时，如果<code>s1[i]==s3[i+j]</code>，则尝试<code>s1[i]</code>与<code>s3[i+j]</code>对应，如果<code>dp[i-1][j]</code>是<code>true</code>，则<code>dp[i][j]</code>也为<code>true</code>。如果<code>s2[j]==s3[i+j]</code>则同样处理。</p>
<p>直到最后，判断<code>dp[s1.length()-1][s2.length()-1]</code>是否为true。为方便初始化，坐标后移了一位。</p>
<p>题目不厚道的出了<code>s1.length()+s2.length() != s3.length()</code>的数据，特判一下。</p>
<p>看到网上也都是<code>O(n^2)</code>的解法，我也就放心了。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s<span class="number">1.l</span>ength() + s<span class="number">2.l</span>ength() != s<span class="number">3.l</span>ength())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector <span class="title">dp</span><span class="params">(s<span class="number">1.l</span>ength() + <span class="number">1</span>, vector(s<span class="number">2.l</span>ength() + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s<span class="number">1.l</span>ength(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= s<span class="number">2.l</span>ength(); j ++) </span><br><span class="line">            &#123; </span><br><span class="line">               <span class="keyword">if</span>(!i &amp;&amp; !j) dp[i][j] = <span class="literal">true</span>; </span><br><span class="line">               dp[i][j] = dp[i][j] || i &gt; <span class="number">0</span> &amp;&amp; s3[i + j - <span class="number">1</span>] == s1[i - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j];</span><br><span class="line">               dp[i][j] = dp[i][j] || j &gt; <span class="number">0</span> &amp;&amp; s3[i + j - <span class="number">1</span>] == s2[j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s<span class="number">1.l</span>ength()][s<span class="number">2.l</span>ength()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="unique-binary-search-trees-ii"><a
href="http://oj.leetcode.com/problems/unique-binary-search-trees-ii/">96.Unique
Binary Search Trees II</a></h3>
<p>LeetCode目前为止感觉最暴力的。递归遍历所有情况，每次返回子问题（左右子树）的vector的解，两层循环组合这些解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">generate</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vectorres;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *tmp = <span class="literal">NULL</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector l = <span class="built_in">generate</span>(start, i - <span class="number">1</span>), r = <span class="built_in">generate</span>(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; l.<span class="built_in">size</span>(); j ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; r.<span class="built_in">size</span>(); k ++) &#123; TreeNode *tmp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i); tmp-&gt;left = l[j];</span><br><span class="line">                    tmp-&gt;right = r[k];</span><br><span class="line">                    res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generate</span>(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="unique-binary-search-trees"><a
href="http://oj.leetcode.com/problems/unique-binary-search-trees/">95.Unique
Binary Search Trees</a></h3>
<p>经典问题，卡特兰数，可递推，可用公式（公式用组合数，也要写循环）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">COM</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m = n - m &lt; m ? n - m : m;</span><br><span class="line">        <span class="type">int</span> res, i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = n, res = j = <span class="number">1</span>; i &gt; n - m; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= i;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt;= m &amp;&amp; res % j == <span class="number">0</span>; j ++)</span><br><span class="line">                res /= j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">COM</span>(n &lt;&lt; <span class="number">1</span>, n) / (n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-inorder-traversal"><a
href="http://oj.leetcode.com/problems/binary-tree-inorder-traversal/">94.Binary
Tree Inorder Traversal</a></h3>
<p>数据结构基础</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(now-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(now-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="restore-ip-addresses"><a
href="http://oj.leetcode.com/problems/restore-ip-addresses/">93.Restore
IP Addresses</a></h3>
<p>四层递归枚举分割位置，判断数字范围和前导零，处理字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(string s, <span class="type">int</span> last, <span class="type">int</span> cur, string now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(last == s.<span class="built_in">length</span>()) <span class="keyword">return</span>;</span><br><span class="line">            string tmp = s.<span class="built_in">substr</span>(last, s.<span class="built_in">length</span>() - last);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">atoi</span>(tmp.<span class="built_in">c_str</span>()) &lt;= <span class="number">255</span> &amp;&amp; (tmp.<span class="built_in">length</span>() == <span class="number">1</span> || tmp[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">                res.<span class="built_in">push_back</span>(now + tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string lin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = last; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp = s.<span class="built_in">substr</span>(last, i - last + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">atoi</span>(tmp.<span class="built_in">c_str</span>()) &lt;= <span class="number">255</span> &amp;&amp; (tmp.<span class="built_in">length</span>() == <span class="number">1</span> || tmp[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">                <span class="built_in">DFS</span>(s, i + <span class="number">1</span>, cur + <span class="number">1</span>, now + tmp + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-linked-list-ii"><a
href="http://oj.leetcode.com/problems/reverse-linked-list-ii/">92.Reverse
Linked List II</a></h3>
<p>在表头添加一个(哨兵)会好写很多，额外的newhead可以帮助标记翻转之后更换了的头指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        newhead-&gt;next = head;</span><br><span class="line">        ListNode *pre = newhead, *p = head, *start = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; p != <span class="literal">NULL</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(i == m)</span><br><span class="line">                start = pre;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m &amp;&amp; i &lt;= n) p-&gt;next = pre;</span><br><span class="line">            <span class="keyword">if</span>(i == n)</span><br><span class="line">            &#123;</span><br><span class="line">                start-&gt;next-&gt;next = tmp;</span><br><span class="line">                start-&gt;next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = newhead-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(newhead);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="decode-ways"><a
href="http://oj.leetcode.com/problems/decode-ways/">91.Decode
Ways</a></h3>
<p>递推：<code>dp[i]</code>表示前 <code>i</code> 个数字的解码种数。</p>
<p>`dp[i] = if(一)dp[i-1] + if(二)dp[i-2]``</p>
<p>当 <code>i</code> 位置不为<code>0</code>，可加上
<code>i - 1</code>位置的解。当当前位置和前一位置组成的两位数满足解码且高位不为<code>0</code>，可加上
<code>i - 2</code> 位置的解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">dp</span><span class="params">(s.length() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">           dp[i + <span class="number">1</span>] = (s[i] != <span class="string">&#x27;0&#x27;</span> ? dp[i] : <span class="number">0</span>) + </span><br><span class="line">               (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">atoi</span>(s.<span class="built_in">substr</span>(i - <span class="number">1</span>, <span class="number">2</span>).<span class="built_in">c_str</span>()) &lt;= <span class="number">26</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">length</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="subsets-ii"><a
href="http://oj.leetcode.com/problems/subsets-ii/">90.Subsets
II</a></h3>
<p>统计地存map里，map[i]= j 表示 S 中有 j 个
i。map是有序的，用迭代器递归枚举放入集合的个数。</p>
<p>也可以先排序，用set标记每个数时候被放入过，第一次放入之后才可以继续放同一个数。</p>
<p>代码是用map的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    vector now;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == mp.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator tmp = i;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="built_in">DFS</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; tmp-&gt;second; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            now.<span class="built_in">push_back</span>(tmp-&gt;first);</span><br><span class="line">            <span class="built_in">DFS</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; tmp-&gt;second; j ++)</span><br><span class="line">            now.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">subsetsWithDup</span><span class="params">(vector &amp;S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            !mp.<span class="built_in">count</span>(S[i]) ? (mp[S[i]] = <span class="number">1</span>) : mp[S[i]] ++;</span><br><span class="line">        <span class="built_in">DFS</span>(mp.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="gray-code"><a
href="http://oj.leetcode.com/problems/gray-code/">89.Gray Code</a></h3>
<p>格雷码有多种生成方法，可参考<a
href="http://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81">维基百科</a>
。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) res.<span class="built_in">push_back</span>((i &gt;&gt; <span class="number">1</span>) ^ i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="merge-sorted-array"><a
href="http://oj.leetcode.com/problems/merge-sorted-array/">88.Merge
Sorted Array</a></h3>
<p>从后往前，对 A
来说一个萝卜一个坑，肯定不会破坏前面的数据。具体看代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> m, <span class="type">int</span> B[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = m + n - <span class="number">1</span>, i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; B[j]) A[p --] = A[i --];</span><br><span class="line">            <span class="keyword">else</span> A[p --] = B[j --];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) A[p --] = A[i --];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) A[p --] = B[j --];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="scramble-string"><a
href="http://oj.leetcode.com/problems/scramble-string/">87.Scramble
String</a></h3>
<p>直接搜索可以过，记忆化搜索可提高效率。</p>
<p>dp[i][j][k]表示从 s1[i] 和 s2[j] 开始长度为 k 的字符串是否是scrambled
string。</p>
<p>枚举分割位置，scrambled
string要求字符串对应字母的个数是一致的，可以直接排序对比。递归终点是刚好只有一个字母。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string S1, S2;</span><br><span class="line">    vector&lt;vector &gt; dp;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> s1start, <span class="type">int</span> s2start, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> &amp;ans = dp[s1start][s2start][len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> ans = S1[s1start] == S2[s2start];</span><br><span class="line">        <span class="keyword">if</span>(ans != <span class="number">-1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">judge</span>(S<span class="number">1.</span><span class="built_in">substr</span>(s1start, len), S<span class="number">2.</span><span class="built_in">substr</span>(s2start, len)))</span><br><span class="line">            <span class="keyword">return</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans</span><br><span class="line">            || <span class="built_in">DFS</span>(s1start, s2start, i) &amp;&amp; <span class="built_in">DFS</span>(s1start + i, s2start + i, len - i)</span><br><span class="line">            || <span class="built_in">DFS</span>(s1start, s2start + len - i, i) &amp;&amp; <span class="built_in">DFS</span>(s1start + i, s2start, len - i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isScramble</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        S1 = s1, S2 = s2;</span><br><span class="line">        dp = <span class="built_in">vector</span>&lt;vector &gt;</span><br><span class="line">            (s<span class="number">1.l</span>ength(), <span class="built_in">vector</span></span><br><span class="line">                (s<span class="number">1.l</span>ength(), <span class="built_in">vector</span></span><br><span class="line">                    (s<span class="number">1.l</span>ength(), <span class="number">-1</span>)));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, s<span class="number">1.l</span>ength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="partition-list"><a
href="http://oj.leetcode.com/problems/partition-list/">86.Partition
List</a></h3>
<p>分存大小最后合并。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *shead, *bhead, *smaller, *bigger, *p;</span><br><span class="line">        <span class="keyword">for</span>(shead = bhead = smaller = bigger = <span class="literal">NULL</span>, p = head; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val &lt; x) &#123; <span class="keyword">if</span>(shead == <span class="literal">NULL</span>) shead = p; <span class="keyword">if</span>(smaller != <span class="literal">NULL</span>) smaller-&gt;next = p;</span><br><span class="line">                smaller = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(bhead == <span class="literal">NULL</span>)</span><br><span class="line">                    bhead = p;</span><br><span class="line">                <span class="keyword">if</span>(bigger != <span class="literal">NULL</span>)</span><br><span class="line">                    bigger-&gt;next = p;</span><br><span class="line">                bigger = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(smaller != <span class="literal">NULL</span>) smaller-&gt;next = bhead;</span><br><span class="line">        <span class="keyword">if</span>(bigger != <span class="literal">NULL</span>) bigger-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> shead != <span class="literal">NULL</span> ? shead : bhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximal-rectangle"><a
href="http://oj.leetcode.com/problems/maximal-rectangle/">85.Maximal
Rectangle</a></h3>
<p>方法一：<code>linecnt[i][j]</code>统计第 <code>i</code> 行到第
<code>j</code> 位置有多少个连续的
<code>'1'</code>，接下来枚举列，每一列相当于一次直方图最大矩形统计，计算每个位置向前和向后最远的不少于当前位置值的位置，每次更新结果，总复杂度<code>O(n^2)</code>。</p>
<p>找(最远位置)用迭代指针，理论复杂度略高于<code>O(n)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> H = matrix.<span class="built_in">size</span>(), W = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">left</span><span class="params">(H)</span>, <span class="title">right</span><span class="params">(H)</span></span>;</span><br><span class="line">        <span class="function">vector <span class="title">linecnt</span><span class="params">(H, vector(W, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; W; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) last ++;</span><br><span class="line">                <span class="keyword">else</span> last = <span class="number">0</span>;</span><br><span class="line">                linecnt[i][j] = last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; W; k ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i ++) </span><br><span class="line">            &#123; </span><br><span class="line">               <span class="keyword">if</span>(i == <span class="number">0</span>) left[i] = <span class="number">-1</span>; </span><br><span class="line">               <span class="keyword">else</span> </span><br><span class="line">               &#123; </span><br><span class="line">                   left[i] = i - <span class="number">1</span>; </span><br><span class="line">                   <span class="keyword">while</span>(left[i] &gt; <span class="number">-1</span> &amp;&amp; linecnt[left[i]][k] &gt;= linecnt[i][k])</span><br><span class="line">                        left[i] = left[left[i]];</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = H - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == H - <span class="number">1</span>) right[i] = H;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right[i] = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(right[i] &lt; H &amp;&amp; linecnt[right[i]][k] &gt;= linecnt[i][k])</span><br><span class="line">                        right[i] = right[right[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * linecnt[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用单调栈，理论复杂度O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">linecnt</span><span class="params">(matrix.size(), vector(matrix[<span class="number">0</span>].size(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) last ++;</span><br><span class="line">                <span class="keyword">else</span> last = <span class="number">0</span>;</span><br><span class="line">                linecnt[i][j] = last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); k ++)</span><br><span class="line">        &#123;</span><br><span class="line">            stack s, site;</span><br><span class="line">            <span class="built_in">vectorlast</span>(matrix.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++) &#123; <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &gt;= linecnt[i][k])</span><br><span class="line">                    s.<span class="built_in">pop</span>(), site.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) last[i] = site.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> last[i] = <span class="number">0</span>;</span><br><span class="line">                s.<span class="built_in">push</span>(linecnt[i][k]);</span><br><span class="line">                site.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>(), site.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &gt;= linecnt[i][k])</span><br><span class="line">                    s.<span class="built_in">pop</span>(), site.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) ans = <span class="built_in">max</span>(ans, (site.<span class="built_in">top</span>() - last[i]) * linecnt[i][k]);</span><br><span class="line">                <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, (<span class="type">int</span>)(matrix.<span class="built_in">size</span>() - last[i]) * linecnt[i][k]);</span><br><span class="line">                s.<span class="built_in">push</span>(linecnt[i][k]);</span><br><span class="line">                site.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：每个 <code>1</code>
的点当作一个矩形的底部，<code>left[j]、right[j]、height[j]</code>表示当前行第
<code>j</code>个位置这个点向左、右、上伸展的最大矩形的边界，作为滚动数组，下一行的数据可以由上一行结果得到，总复杂度O(n^2)。</p>
<p><code>left[j] = max(这一行最左, left[j]（上一行最左） );</code></p>
<p><code>right[j] = min(这一行最右，right[j]（上一行最右） );</code></p>
<p><code>height[j] = height[j - 1] + 1;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> H = matrix.<span class="built_in">size</span>(), W = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector <span class="title">left</span><span class="params">(W, <span class="number">-1</span>)</span>, <span class="title">right</span><span class="params">(W, W)</span>, <span class="title">height</span><span class="params">(W, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; W; j ++) </span><br><span class="line">            &#123; </span><br><span class="line">               <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">               &#123; </span><br><span class="line">                   <span class="keyword">if</span>(last == <span class="number">-1</span>) last = j; </span><br><span class="line">                   left[j] = <span class="built_in">max</span>(left[j], last); </span><br><span class="line">                   height[j] ++;</span><br><span class="line">               &#125; </span><br><span class="line">               <span class="keyword">else</span> </span><br><span class="line">               &#123; </span><br><span class="line">                   last = <span class="number">-1</span>; left[j] = <span class="number">-1</span>; height[j] = <span class="number">0</span>; </span><br><span class="line">               &#125; </span><br><span class="line">             &#125; last = <span class="number">-1</span>; </span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = W - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(last == <span class="number">-1</span>) last = j;</span><br><span class="line">                    right[j] = <span class="built_in">min</span>(right[j], last);</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, height[j] * (right[j] - left[j] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    last = <span class="number">-1</span>;</span><br><span class="line">                    right[j] = W;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="largest-rectangle-in-histogram"><a
href="http://oj.leetcode.com/problems/largest-rectangle-in-histogram/">84.Largest
Rectangle in Histogram</a></h3>
<p>参考上一题Maximal Rectangle方法一。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">left</span><span class="params">(height.size())</span>, <span class="title">right</span><span class="params">(height.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">           <span class="keyword">if</span>(i == <span class="number">0</span>) left[i] = <span class="number">-1</span>; </span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">           &#123; </span><br><span class="line">               left[i] = i - <span class="number">1</span>; </span><br><span class="line">               <span class="keyword">while</span>(left[i] &gt; <span class="number">-1</span> &amp;&amp; height[i] &lt;= height[left[i]])</span><br><span class="line">                   left[i] = left[left[i]]; </span><br><span class="line">           &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = height.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == height.<span class="built_in">size</span>() - <span class="number">1</span>) right[i] = height.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(right[i] &lt; height.<span class="built_in">size</span>() &amp;&amp; height[i] &lt;= height[right[i]])</span><br><span class="line">                    right[i] = right[right[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-duplicates-from-sorted-list-ii"><a
href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">83.Remove
Duplicates from Sorted List II</a></h3>
<p>加个表头乱搞吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        newhead-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(ListNode *pre = newhead, *now = head, *nex = head-&gt;next; nex != <span class="literal">NULL</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;val == nex-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(nex != <span class="literal">NULL</span> &amp;&amp; now-&gt;val == nex-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">free</span>(now);</span><br><span class="line">                    now = nex;</span><br><span class="line">                    nex = nex-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">free</span>(now);</span><br><span class="line">                pre-&gt;next = nex;</span><br><span class="line">                <span class="keyword">if</span>(nex == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> pre = now;</span><br><span class="line">            now = nex;</span><br><span class="line">            nex = nex-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = newhead-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(newhead);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-duplicates-from-sorted-list"><a
href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">82.Remove
Duplicates from Sorted List</a></h3>
<p>直接操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">for</span>(ListNode *pre = head, *p = head-&gt;next; p != <span class="literal">NULL</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val == p-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = p-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(p);</span><br><span class="line">                p = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-in-rotated-sorted-array-ii"><a
href="http://oj.leetcode.com/problems/search-in-rotated-sorted-array-ii/">81.Search
in Rotated Sorted Array II</a></h3>
<p>以mid为界，左右两边至少有一边是有序的。由于不可避免地会有O(n)的可能性，所以确定的时候二分，不确定的时候单位缩减边界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; A[mid] &amp;&amp; A[left] &lt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; A[right] &amp;&amp; A[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[left] == target || A[right] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(A[left] &lt; target) left ++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; A[right]) right --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[left] == target ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-duplicates-from-sorted-array-ii"><a
href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">80.Remove
Duplicates from Sorted Array II</a></h3>
<p>记下放了几个，多了不放。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j, cnt;</span><br><span class="line">        <span class="keyword">for</span>(i = j = cnt = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; A[j - <span class="number">1</span>] == A[i]) cnt ++;</span><br><span class="line">            <span class="keyword">else</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">2</span>) A[j ++] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-search"><a
href="http://oj.leetcode.com/problems/word-search/">79.Word
Search</a></h3>
<p>基础DFS。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, vector &amp;board, string word, <span class="type">int</span> ith)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] != word[ith]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ith == word.<span class="built_in">length</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) </span><br><span class="line">        &#123; </span><br><span class="line">           <span class="type">int</span> nx = x + dx[i]; <span class="type">int</span> ny = y + dy[i]; </span><br><span class="line">           <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; board.<span class="built_in">size</span>() &amp;&amp; ny &lt; board[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">DFS</span>(nx, ny, board, word, ith + <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    board[x][y] = word[ith];</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = word[ith];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector &amp;board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">DFS</span>(i, j, board, word, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="subsets"><a
href="http://oj.leetcode.com/problems/subsets/">78.Subsets</a></h3>
<p>基础DFS。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector now;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector &amp;S, <span class="type">int</span> ith)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ith == S.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DFS</span>(S, ith + <span class="number">1</span>);</span><br><span class="line">        now.<span class="built_in">push_back</span>(S[ith]);</span><br><span class="line">        <span class="built_in">DFS</span>(S, ith + <span class="number">1</span>);</span><br><span class="line">        now.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">subsets</span><span class="params">(vector &amp;S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(S.<span class="built_in">begin</span>(), S.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">DFS</span>(S, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="combinations"><a
href="http://oj.leetcode.com/problems/combinations/">77.Combinations</a></h3>
<p>基础DFS。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector now;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> ith, <span class="type">int</span> sum, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum + n - ith + <span class="number">1</span> &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(n, ith + <span class="number">1</span>, sum, k);</span><br><span class="line">        &#125;</span><br><span class="line">        now.<span class="built_in">push_back</span>(ith);</span><br><span class="line">        <span class="built_in">DFS</span>(n, ith + <span class="number">1</span>, sum + <span class="number">1</span>, k);</span><br><span class="line">        now.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(n, <span class="number">1</span>, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="minimum-window-substring"><a
href="http://oj.leetcode.com/problems/minimum-window-substring/">76.Minimum
Window Substring</a></h3>
<p>先统计 <code>T</code>
中各字符都有多少个，然后两个下标一前(<code>i</code>)一后(<code>j</code>)在
<code>S</code> 上跑， 当 <code>i</code> 跑到把 <code>T</code>
中字符都包含的位置时候，让 <code>j</code> 追到第一个包含 <code>T</code>
的字符的地方，更新结果，去掉 <code>j</code> 这个位置字符的统计，让
<code>i</code> 继续跑，如此反复。</p>
<p><code>i</code> 和 <code>j</code> 都只遍历一遍 <code>S</code>，复杂度
<code>O(n)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">cnt</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span>, <span class="title">need</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, len = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            need[T[i]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; S.<span class="built_in">length</span>(); j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; S.<span class="built_in">length</span>() &amp;&amp; sum &lt; T.<span class="built_in">length</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[S[i]] &lt; need[S[i]])</span><br><span class="line">                    sum ++;</span><br><span class="line">                cnt[S[i]] ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(sum == T.<span class="built_in">length</span>() &amp;&amp; j &lt; S.<span class="built_in">length</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[S[j]] --;</span><br><span class="line">                <span class="keyword">if</span>(cnt[S[j]] &lt; need[S[j]])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; T.<span class="built_in">length</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i - j &lt; len)</span><br><span class="line">                ans = S.<span class="built_in">substr</span>(j, i - j), len = i - j;</span><br><span class="line">            sum --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sort-colors"><a
href="http://oj.leetcode.com/problems/sort-colors/">75.Sort
Colors</a></h3>
<p>轮流找：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> find = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n; i ++) &#123; <span class="keyword">if</span>(A[i] == find) <span class="keyword">continue</span>; <span class="keyword">while</span>(j &gt; i &amp;&amp; A[j] != find) j --;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; i) <span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">            <span class="keyword">else</span> i --, j = n - <span class="number">1</span>, find ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>找到哪个放哪个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p0, p1, p2;</span><br><span class="line">        <span class="keyword">for</span>(p0 = <span class="number">0</span>, p1 = p2 = n - <span class="number">1</span>; p0 &lt; p1; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[p0] == <span class="number">0</span>) p0 ++;</span><br><span class="line">            <span class="keyword">if</span>(A[p0] == <span class="number">1</span>) <span class="built_in">swap</span>(A[p0], A[p1 --]);</span><br><span class="line">            <span class="keyword">if</span>(A[p0] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[p0], A[p2 --]);</span><br><span class="line">                p1 = p2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-a-2d-matrix"><a
href="http://oj.leetcode.com/problems/search-a-2d-matrix/">74.Search a
2D Matrix</a></h3>
<p>写两个二分查找。或者把整个矩阵看作一维，直接二分，换算坐标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector &amp;matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid;</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = matrix.<span class="built_in">size</span>(); left &lt; right - <span class="number">1</span>; ) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] &gt; target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == matrix.<span class="built_in">size</span>() || right == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vector &amp;a = matrix[left];</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = a.<span class="built_in">size</span>(); left &lt; right - <span class="number">1</span>;) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &gt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == a.<span class="built_in">size</span>() || right == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a[left] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="set-matrix-zeroes"><a
href="http://oj.leetcode.com/problems/set-matrix-zeroes/">73.Set Matrix
Zeroes</a></h3>
<p><code>O(m+n)</code>的方法是容易想到的，而空间复杂度<code>O(1)</code>，只要利用原矩阵的一行和一列来使用<code>O(m+n)</code>的方法就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>, y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = i, y = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        matrix[x][j] = <span class="number">0</span>;</span><br><span class="line">                        matrix[i][y] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">                <span class="keyword">if</span>((matrix[x][j] == <span class="number">0</span> || matrix[i][y] == <span class="number">0</span>) &amp;&amp; (i != x &amp;&amp; j != y))</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++) matrix[i][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) matrix[x][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="edit-distance"><a
href="http://oj.leetcode.com/problems/edit-distance/">72.Edit
Distance</a></h3>
<p>动态规划，先初始化 <code>dp[i][0]</code> 和
<code>dp[0][i]</code>，即每个字符串对应空串的编辑距离为串长度，之后对每个位置取子问题加上当前位置
改、删、增得解的最小值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">dp</span><span class="params">(word<span class="number">1.l</span>ength() + <span class="number">1</span>, vector(word<span class="number">2.l</span>ength() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word<span class="number">1.l</span>ength(); i ++) dp[i + <span class="number">1</span>][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word<span class="number">2.l</span>ength(); i ++) dp[<span class="number">0</span>][i + <span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word<span class="number">1.l</span>ength(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; word<span class="number">2.l</span>ength(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i] != word2[j])</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j] + <span class="number">1</span>, <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>] + <span class="number">1</span>, dp[i + <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j], <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>] + <span class="number">1</span>, dp[i + <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word<span class="number">1.l</span>ength()][word<span class="number">2.l</span>ength()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="simplify-path"><a
href="http://oj.leetcode.com/problems/simplify-path/">71.Simplify
Path</a></h3>
<p>好烦人的题，没什么好说的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        stack s;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str == <span class="string">&quot;..&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line"></span><br><span class="line">                        s.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str != <span class="string">&quot;.&quot;</span> &amp;&amp; str != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                    s.<span class="built_in">push</span>(str);</span><br><span class="line">                str.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str += path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;..&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str != <span class="string">&quot;.&quot;</span> &amp;&amp; str != <span class="string">&quot;&quot;</span>)</span><br><span class="line">            s.<span class="built_in">push</span>(str);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(str.<span class="built_in">clear</span>(); !s.<span class="built_in">empty</span>(); s.<span class="built_in">pop</span>())</span><br><span class="line">            str = <span class="string">&quot;/&quot;</span> + s.<span class="built_in">top</span>() + str;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="climbing-stairs"><a
href="http://oj.leetcode.com/problems/climbing-stairs/">70.Climbing
Stairs</a></h3>
<p>递推，就是斐波那契数列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)</span><br><span class="line">            (<span class="built_in">pow</span>((<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>, n + <span class="number">1</span>) / <span class="built_in">sqrt</span>(<span class="number">5</span>) -</span><br><span class="line">            <span class="built_in">pow</span>((<span class="number">1</span>-<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>, n + <span class="number">1</span>) / <span class="built_in">sqrt</span>(<span class="number">5</span>) + <span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sqrtx"><a
href="http://oj.leetcode.com/problems/sqrtx/">69.Sqrt(x)</a></h3>
<p>牛顿迭代。
设输入为n，<code>f(x)=x^2-n</code>，解就是<code>f(x)=0</code>时的<code>x</code>。
设猜了一数<code>x[0]</code>，那么在<code>f(x)</code>在<code>x[0]</code>处的切线与x轴的交点<code>x[1]</code>更接近目标解（可画图看看）。
那么递推下去，<code>x[i]=(x[i-1]+n/x[i-1])/2</code>，用double，越推越精确，直到自己想要的精度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> now, last;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(now = last = (<span class="type">double</span>)x; ; last = now)</span><br><span class="line">        &#123;</span><br><span class="line">            now = (last + (x / last)) * <span class="number">0.5</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(last - now) &lt; <span class="number">1e-5</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(now + <span class="number">1e-6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="text-justification"><a
href="http://oj.leetcode.com/problems/text-justification/">68.Text
Justification</a></h3>
<p>每行限制长度，空格均匀插入，不能完全平均的情况下优先靠前的单词间隔。</p>
<p>最后一行特别处理，单词间只有一个空格，剩下的放在末尾。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">fullJustify</span><span class="params">(vector &amp;words, <span class="type">int</span> L)</span> </span>&#123;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, i, j, k, l;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; words.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; words.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cnt += words[i].<span class="built_in">length</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == words.<span class="built_in">size</span>() || (L - cnt) / (i - j) &lt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> blank = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; words.<span class="built_in">size</span>())</span><br><span class="line">                    blank = (i - j - <span class="number">1</span>) ? (L - cnt + words[i].<span class="built_in">length</span>()) / (i - j - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">                string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                l = i &lt; words.<span class="built_in">size</span>() ? (L - cnt + words[i].<span class="built_in">length</span>() - blank * (i - j - <span class="number">1</span>)) : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(k = j; k &lt; i; k ++, l --)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp += words[k];</span><br><span class="line">                    <span class="keyword">if</span>(k != i - <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i != words.<span class="built_in">size</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> bl = <span class="number">0</span>; bl &lt; blank; bl ++) tmp += <span class="string">&quot; &quot;</span>; <span class="keyword">if</span>(l &gt; <span class="number">0</span>) tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(tmp.<span class="built_in">length</span>() &lt; L) tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                j = i;</span><br><span class="line">                i --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="plus-one"><a
href="http://oj.leetcode.com/problems/plus-one/">67.Plus One</a></h3>
<p>大整数加法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">plusOne</span><span class="params">(vector &amp;digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur, i;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        <span class="keyword">for</span>(i = digits.<span class="built_in">size</span>() - <span class="number">1</span>, cur = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = digits[i] + cur;</span><br><span class="line">            cur = tmp / <span class="number">10</span>;</span><br><span class="line">            digits[i] = tmp % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur) digits.<span class="built_in">insert</span>(digits.<span class="built_in">begin</span>(), cur);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="valid-number"><a
href="http://oj.leetcode.com/problems/valid-number/">66.Valid
Number</a></h3>
<p>用DFA也不麻烦，题目定义太模糊，为了理解规则错很多次也没办法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f[<span class="number">11</span>][<span class="number">129</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> fail = <span class="number">-1</span>;    <span class="comment">//非法</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> st = <span class="number">0</span>;       <span class="comment">//起始</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> pn = <span class="number">1</span>;       <span class="comment">//正负号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> di = <span class="number">2</span>;       <span class="comment">//整数部分</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> del = <span class="number">3</span>;      <span class="comment">//前面无数字小数点</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ddi = <span class="number">4</span>;      <span class="comment">//小数部分</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ndel = <span class="number">5</span>;     <span class="comment">//前面有数字小数点</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dibl = <span class="number">6</span>;     <span class="comment">//数后空格</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ex = <span class="number">7</span>;       <span class="comment">//进入指数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> epn = <span class="number">8</span>;      <span class="comment">//指数符号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> edi = <span class="number">9</span>;      <span class="comment">//指数数字</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> end = <span class="number">10</span>;     <span class="comment">//正确结束</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildDFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[st][<span class="string">&#x27; &#x27;</span>] = st;</span><br><span class="line">        f[st][<span class="string">&#x27;+&#x27;</span>] = f[st][<span class="string">&#x27;-&#x27;</span>] = pn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="string">&#x27;0&#x27;</span>; i &lt;= <span class="string">&#x27;9&#x27;</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[st][i] = f[pn][i] = f[di][i] = di;</span><br><span class="line">            f[del][i] = f[ndel][i] = f[ddi][i] = ddi;</span><br><span class="line">            f[ex][i] = f[epn][i] = f[edi][i] = edi;</span><br><span class="line">        &#125;</span><br><span class="line">        f[di][<span class="string">&#x27;.&#x27;</span>] = ndel;</span><br><span class="line">        f[st][<span class="string">&#x27;.&#x27;</span>] = f[pn][<span class="string">&#x27;.&#x27;</span>] = del;</span><br><span class="line">        f[di][<span class="string">&#x27; &#x27;</span>] = f[ndel][<span class="string">&#x27; &#x27;</span>] = f[ddi][<span class="string">&#x27; &#x27;</span>] = f[dibl][<span class="string">&#x27; &#x27;</span>] = f[edi][<span class="string">&#x27; &#x27;</span>] = dibl;</span><br><span class="line">        f[di][<span class="number">0</span>] = f[ndel][<span class="number">0</span>] = f[dibl][<span class="number">0</span>] = f[ddi][<span class="number">0</span>] = f[edi][<span class="number">0</span>] = end;</span><br><span class="line">        f[di][<span class="string">&#x27;e&#x27;</span>] = f[ndel][<span class="string">&#x27;e&#x27;</span>] = f[ddi][<span class="string">&#x27;e&#x27;</span>] = ex;</span><br><span class="line">        f[ex][<span class="string">&#x27; &#x27;</span>] = ex;</span><br><span class="line">        f[ex][<span class="string">&#x27;+&#x27;</span>] = f[ex][<span class="string">&#x27;-&#x27;</span>] = epn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFA</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> situ = st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            situ = f[situ][s[i]];</span><br><span class="line">            <span class="keyword">if</span>(situ == end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(situ == fail) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">buildDFA</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFA</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="add-binary"><a
href="http://oj.leetcode.com/problems/add-binary/">65.Add
Binary</a></h3>
<p>翻转，大整数加法，再翻转。无心情优化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        string c;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(a.<span class="built_in">length</span>(), b.<span class="built_in">length</span>()); i ++) &#123; <span class="type">int</span> tmp = a[i] - <span class="string">&#x27;0&#x27;</span> + b[i] - <span class="string">&#x27;0&#x27;</span> + cur; cur = tmp &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            c += (tmp &amp; <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string &amp;t = a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>() ? a : b;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; t.<span class="built_in">length</span>(); i ++) &#123; <span class="type">int</span> tmp = t[i] - <span class="string">&#x27;0&#x27;</span> + cur; cur = tmp &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            c += (tmp &amp; <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur) c += <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="minimum-path-sum"><a
href="http://oj.leetcode.com/problems/minimum-path-sum/">64.Minimum Path
Sum</a></h3>
<p>递推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123; <span class="type">int</span> tmp = <span class="number">0x3f3f3f3f</span>; <span class="keyword">if</span>(i &gt; <span class="number">0</span>) tmp = <span class="built_in">min</span>(tmp, grid[i][j] + grid[i - <span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>) tmp = <span class="built_in">min</span>(tmp, grid[i][j] + grid[i][j - <span class="number">1</span>]);</span><br><span class="line">                grid[i][j] = tmp == <span class="number">0x3f3f3f3f</span> ? grid[i][j] : tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.<span class="built_in">size</span>() - <span class="number">1</span>][grid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="unique-paths-ii"><a
href="http://oj.leetcode.com/problems/unique-paths-ii/">63.Unique Paths
II</a></h3>
<p>递推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector &amp;obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; obstacleGrid.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123; <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>) &#123; obstacleGrid[i][j] = <span class="number">0</span>; <span class="keyword">continue</span>; &#125; <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                    obstacleGrid[i][j] += obstacleGrid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                    obstacleGrid[i][j] += obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[obstacleGrid.<span class="built_in">size</span>() - <span class="number">1</span>][obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="unique-paths"><a
href="http://oj.leetcode.com/problems/unique-paths/">62.Unique
Paths</a></h3>
<p>这是当年学组合数时候的经典题型吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">COM</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b = <span class="built_in">min</span>(b, a - b);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>, i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = a, j = <span class="number">1</span>; i &gt; a - b; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            ret *= i;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt;= b &amp;&amp; ret % j == <span class="number">0</span>; j ++)</span><br><span class="line">                ret /= j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">COM</span>(m + n - <span class="number">2</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-list"><a
href="http://oj.leetcode.com/problems/rotate-list/">61.Rotate
List</a></h3>
<p>因为k可能比长度大，需要求长度然后k对长度取模。那么就不要矫情地追求双指针一遍扫描了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        ListNode *en, *p;</span><br><span class="line">        <span class="keyword">for</span>(cnt = <span class="number">1</span>, en = head; en-&gt;next != <span class="literal">NULL</span>; cnt ++, en = en-&gt;next);</span><br><span class="line">        k %= cnt;</span><br><span class="line">        <span class="keyword">for</span>(p = head, cnt --; cnt != k; cnt --, p = p-&gt;next);</span><br><span class="line">        en-&gt;next = head;</span><br><span class="line">        en = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> en;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="permutation-sequence"><a
href="http://oj.leetcode.com/problems/permutation-sequence/">60.Permutation
Sequence</a></h3>
<p>一位一位算，每一位优先没使用过的较小的数字，而其后剩下的m个位置有 m!
种排列方法，用 k
减去，直到k不大于这个方法数，则这一位就是枚举到的这个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> permu[<span class="number">10</span>];</span><br><span class="line">    <span class="type">bool</span> vis[<span class="number">10</span>];</span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        permu[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++) permu[i] = permu[i - <span class="number">1</span>] * i;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123; <span class="keyword">if</span>(!vis[j]) &#123; <span class="keyword">if</span>(k &gt; permu[n - i])</span><br><span class="line">                        k -= permu[n - i];</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += <span class="string">&#x27;0&#x27;</span> + j;</span><br><span class="line">                        vis[j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="spiral-matrix-ii"><a
href="http://oj.leetcode.com/problems/spiral-matrix-ii/">59.Spiral
Matrix II</a></h3>
<p>直接算每个位置的数是多少有木有很霸气→_→。
先看当前位置之外有几个嵌套的正方形，再看当前位置在当前正方形四条边的第几条，求出坐标(x,y)位置的数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    vector nsq;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calnum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> num, tmp;</span><br><span class="line">        tmp = <span class="built_in">min</span>(<span class="built_in">min</span>(i, j), <span class="built_in">min</span>(n - <span class="number">1</span> - i, n - <span class="number">1</span> - j));</span><br><span class="line">        num = nsq[tmp];</span><br><span class="line">        <span class="keyword">if</span>(i == tmp) <span class="keyword">return</span> num + j - tmp + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n - j - <span class="number">1</span> == tmp) <span class="keyword">return</span> num + n - <span class="number">2</span> * tmp + i - tmp;</span><br><span class="line">        <span class="keyword">if</span>(n - i - <span class="number">1</span> == tmp) <span class="keyword">return</span> num + <span class="number">2</span> * (n - <span class="number">2</span> * tmp) - <span class="number">2</span> + n - j - tmp;</span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">3</span> * (n - <span class="number">2</span> * tmp) - <span class="number">3</span> + n - i - tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">generateMatrix</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        nsq.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>) nsq.<span class="built_in">push_back</span>(<span class="number">4</span> * i - <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nsq.<span class="built_in">size</span>(); i ++) nsq[i] += nsq[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(<span class="built_in">calnum</span>(i, j, n));</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="length-of-last-word"><a
href="http://oj.leetcode.com/problems/length-of-last-word/">58.Length of
Last Word</a></h3>
<p>从后往前找。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="built_in">strlen</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>; i --);</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>; j --);</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">0</span> ? <span class="number">0</span> : i - j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="insert-interval"><a
href="http://oj.leetcode.com/problems/insert-interval/">57.Insert
Interval</a></h3>
<p>end 比 newInterval 的 start 小的 intervals 直接插入，从 end 比
newInterval 的 start 大的 intervals 开始，到 start 比 newInterval 的 end
大的 intervals 结束，对这部分区间合并，再把之后的
intervals直接插入，特判 newInterval 最小和最大两种极端情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function">vector <span class="title">insert</span><span class="params">(vector &amp;intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; newInterval.start &gt; intervals[i].end; i ++)</span><br><span class="line">            res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; intervals.<span class="built_in">size</span>() &amp;&amp; newInterval.end &gt;= intervals[j].start; j ++);</span><br><span class="line">        <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; i != intervals.<span class="built_in">size</span>())</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">Interval</span>(<span class="built_in">min</span>(intervals[i].start, newInterval.start),</span><br><span class="line">                                <span class="built_in">max</span>(intervals[j - <span class="number">1</span>].end, newInterval.end)));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; intervals.<span class="built_in">size</span>(); j ++)</span><br><span class="line">            res.<span class="built_in">push_back</span>(intervals[j]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="merge-intervals"><a
href="http://oj.leetcode.com/problems/merge-intervals/">56.Merge
Intervals</a></h3>
<p>先按start排个序，然后慢慢合并。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cxompp</span><span class="params">(<span class="type">const</span> Interval &amp;a, <span class="type">const</span> Interval &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;</span><br><span class="line">    <span class="function">vector <span class="title">merge</span><span class="params">(vector &amp;intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cxompp);</span><br><span class="line">        Interval last = intervals[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i ++) &#123; <span class="keyword">if</span>(last.end &gt;= intervals[i].start)</span><br><span class="line">                last.end = <span class="built_in">max</span>(last.end, intervals[i].end);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(last), last = intervals[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(last);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="jump-game"><a
href="http://oj.leetcode.com/problems/jump-game/">55.Jump Game</a></h3>
<p>维护最大可跳距离，每个位置都枚举一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i, jumpdis;</span><br><span class="line">        <span class="keyword">for</span>(i = jumpdis = <span class="number">0</span>; i &lt; n &amp;&amp; jumpdis &gt;= <span class="number">0</span>; i ++, jumpdis --)</span><br><span class="line">            jumpdis = <span class="built_in">max</span>(A[i], jumpdis);</span><br><span class="line">        <span class="keyword">return</span> i == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="spiral-matrix"><a
href="http://oj.leetcode.com/problems/spiral-matrix/">54.Spiral
Matrix</a></h3>
<p>模拟转一遍吧。写了俩代码，差不多，处理拐弯的方式略有不同。</p>
<p>代码一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">JudgeValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y,</span></span></span><br><span class="line"><span class="params"><span class="function">        vector &amp;vis, vector &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; </span><br><span class="line">           vis[x][y] == <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">spiralOrder</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dir, x, y, nx, ny;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector <span class="title">vis</span><span class="params">(matrix.size(), vector(matrix[<span class="number">0</span>].size(), <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(dir = x = y = <span class="number">0</span>; <span class="built_in">JudgeValid</span>(x, y, vis, matrix); x = nx, y = ny)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">            nx = x + dx[dir];</span><br><span class="line">            ny = y + dy[dir];</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">JudgeValid</span>(nx, ny, vis, matrix))</span><br><span class="line">            &#123;</span><br><span class="line">                dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                nx = x + dx[dir];</span><br><span class="line">                ny = y + dy[dir];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function">vector <span class="title">spiralOrder</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dir, x, y, nx, ny;</span><br><span class="line">        <span class="type">int</span> l, r, u, d;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        l = u = <span class="number">-1</span>;</span><br><span class="line">        r = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        d = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(dir = x = y = <span class="number">0</span>; res.<span class="built_in">size</span>() &lt; matrix.<span class="built_in">size</span>() * matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            x = nx, y = ny)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            nx = x + dx[dir];</span><br><span class="line">            ny = y + dy[dir];</span><br><span class="line">            <span class="keyword">if</span>(nx == d || nx == u || ny == r || ny == l)</span><br><span class="line">            &#123;</span><br><span class="line">                dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir == <span class="number">0</span>) l ++, r --, d --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dir == <span class="number">3</span>) u ++;</span><br><span class="line">                nx = x + dx[dir];</span><br><span class="line">                ny = y + dy[dir];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximum-subarray"><a
href="http://oj.leetcode.com/problems/maximum-subarray/">53.Maximum
Subarray</a></h3>
<p>最大子串和，子串要求至少包含一个数字。</p>
<p>一个变量 sum 表示当前求得的子串和，当 sum
小于0时，对后面的子串没有贡献，则把 sum
置零，中间处理一下要求至少包含一个数字的要求即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = A[<span class="number">0</span>], sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">                sum = <span class="number">0</span>, ans = <span class="built_in">max</span>(ans, A[i]);</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="n-queens-ii"><a
href="http://oj.leetcode.com/problems/n-queens-ii/">52.N-Queens
II</a></h3>
<p>题目没说 n 的取值范围，就不用 位运算 做标记了。</p>
<p>老老实实开三个 bool
数组，一个标记纵列，另外两个标记两个斜列，一行一行DFS。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector col, lc, rc;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans ++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!col[i] &amp;&amp; !lc[n - cur - <span class="number">1</span> + i] &amp;&amp; !rc[cur + i])</span><br><span class="line">            &#123;</span><br><span class="line">                col[i] = lc[n - cur - <span class="number">1</span> + i] = rc[cur + i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">DFS</span>(cur + <span class="number">1</span>, n);</span><br><span class="line">                col[i] = lc[n - cur - <span class="number">1</span> + i] = rc[cur + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        col.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        lc.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        rc.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="n-queens"><a
href="http://oj.leetcode.com/problems/n-queens/">51.N-Queens</a></h3>
<p>同上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector tmp;</span><br><span class="line">    vector res;</span><br><span class="line">    vector col, lc, rc;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">now</span><span class="params">(n, <span class="string">&#x27;.&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!col[i] &amp;&amp; !lc[n - cur - <span class="number">1</span> + i] &amp;&amp; !rc[cur + i])</span><br><span class="line">            &#123;</span><br><span class="line">                col[i] = lc[n - cur - <span class="number">1</span> + i] = rc[cur + i] = <span class="literal">true</span>;</span><br><span class="line">                now[i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(now);</span><br><span class="line">                <span class="built_in">DFS</span>(cur + <span class="number">1</span>, n);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                now[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                col[i] = lc[n - cur - <span class="number">1</span> + i] = rc[cur + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        col.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        lc.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        rc.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="powx-n"><a
href="http://oj.leetcode.com/problems/powx-n/">50.Pow(x, n)</a></h3>
<p>很多人用特判错过了 <code>n=-2147483648</code> 这么优美的
trick，而不特判的话，似乎只能 long long 了。</p>
<p>经典的快速幂，用二进制理解也好，用折半理解也好，网上很多资料。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> nn = n;</span><br><span class="line">        <span class="keyword">if</span>(nn &lt; <span class="number">0</span>) x = <span class="number">1</span> / x, nn = -nn; <span class="keyword">while</span>(nn) &#123; <span class="keyword">if</span>(nn &amp; <span class="number">1</span>) res *= x; x *= x; nn &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="anagrams"><a
href="http://oj.leetcode.com/problems/anagrams/">49.Anagrams</a></h3>
<p>这概念以前没听过诶。。题也没看到样例，不知道以后会不会更新，网上查了才明白啥意思。</p>
<p>调换单词字母顺序能一致的单词集合全放进答案。比如有tea, eat,
aet，就都要放进答案，有cat,
atc，就都要放进答案，而如果孤零零有个dog，没其他可和他一组的，那么就不放进答案。</p>
<p>手写hash能更快些，但是题目没给数据范围，给hash数组定多大都没合理性，干脆用unordered_map好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function">vector <span class="title">anagrams</span><span class="params">(vector &amp;strs)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp = strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(tmp)) mp[tmp] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[tmp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i ++) &#123; string tmp = strs[i]; <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>()); <span class="keyword">if</span>(mp.<span class="built_in">count</span>(tmp) &amp;&amp; mp[tmp] &gt; <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-image"><a
href="http://oj.leetcode.com/problems/rotate-image/">48.Rotate
Image</a></h3>
<p>四个一组，就地旋转。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> len = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> lenlimi = len + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenlimi; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; (len &amp; <span class="number">1</span> ? lenlimi - <span class="number">1</span> : lenlimi); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[len - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[len - j - <span class="number">1</span>][i] = matrix[len - i - <span class="number">1</span>][len - j - <span class="number">1</span>];</span><br><span class="line">                matrix[len - i - <span class="number">1</span>][len - j - <span class="number">1</span>] = matrix[j][len - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][len - i - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="permutations-ii"><a
href="http://oj.leetcode.com/problems/permutations-ii/">47.Permutations
II</a></h3>
<p>有重复数字，把数字统计起来好了。因为题目没说数字大小，所以统计用了unordered_map。</p>
<p>也可以把数组排序，DFS时跳过重复的数字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    vector tmp;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="type">int</span> numsize;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == numsize)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(it-&gt;first);</span><br><span class="line">                it-&gt;second --;</span><br><span class="line">                <span class="built_in">DFS</span>(cnt + <span class="number">1</span>);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                it-&gt;second ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">permute</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        numsize = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(num[i])) mp[num[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[num[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="permutations"><a
href="http://oj.leetcode.com/problems/permutations/">46.Permutations</a></h3>
<p>虽然题目没说有没有重复数字。。既然 Permutations II
说有了，那就当这个没有吧。</p>
<p>传统DFS。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, vector &amp;num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == num.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(num[cur], num[i]);</span><br><span class="line">            <span class="built_in">DFS</span>(cur + <span class="number">1</span>, num);</span><br><span class="line">            <span class="built_in">swap</span>(num[cur], num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">permute</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="jump-game-ii"><a
href="http://oj.leetcode.com/problems/jump-game-ii/">45.Jump Game
II</a></h3>
<p>维护一步最远到达的位置，到达这个位置之前的位置需要的步数都是一样的，到达这个位置的时候，下一步的最远位置已经更新完毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nex = <span class="number">0</span>, pace = <span class="number">0</span>, far = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nex &amp;&amp; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            far = <span class="built_in">max</span>(far, A[i] + i);</span><br><span class="line">            <span class="keyword">if</span>(i == nex)</span><br><span class="line">            &#123;</span><br><span class="line">                pace ++;</span><br><span class="line">                nex = far;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="wildcard-matching"><a
href="http://oj.leetcode.com/problems/wildcard-matching/">44.Wildcard
Matching</a></h3>
<p>同步扫描两个字符串，每当 p 遇到 <code>*</code>
，记录s和p的当前扫描位置，当 s 与 p 不匹配时，跑扫描指针回到
<code>*</code> 后一个字符， s 扫描指针回到上次遇到 <code>*</code> 之后与
p 开始匹配位置的下一个位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> last_star = <span class="number">-1</span>, last_s = <span class="number">-1</span>, i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">0</span>; s[i]; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) i ++, j ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">&#x27;*&#x27;</span>) last_star = ++ j, last_s = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(last_star != <span class="number">-1</span>) i = ++ last_s, j = last_star;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p[j] == <span class="string">&#x27;*&#x27;</span>) j ++;</span><br><span class="line">        <span class="keyword">return</span> !s[i] &amp;&amp; !p[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="multiply-strings"><a
href="http://oj.leetcode.com/problems/multiply-strings/">43.Multiply
Strings</a></h3>
<p>翻转num1和num2，大整数乘法，把结果再翻转。注意 int 和 char
的转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="function">string <span class="title">ans</span><span class="params">(num<span class="number">1.l</span>ength() + num<span class="number">2.l</span>ength() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">1.</span><span class="built_in">begin</span>(), num<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">2.</span><span class="built_in">begin</span>(), num<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>, i, j, k;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num<span class="number">1.l</span>ength(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; num<span class="number">2.l</span>ength(); j ++) &#123; ans[i + j] += cur + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>); cur = ans[i + j] / <span class="number">10</span>; ans[i + j] %= <span class="number">10</span>; &#125; <span class="keyword">for</span>(k = i + j; cur; k ++) &#123; ans[k] += cur; cur = ans[k] / <span class="number">10</span>; ans[k] %= <span class="number">10</span>; &#125; &#125; <span class="keyword">for</span>(k = ans.<span class="built_in">length</span>() - <span class="number">1</span>; k &gt; <span class="number">0</span> &amp;&amp; ans[k] == <span class="number">0</span>; k --);</span><br><span class="line">        ans.<span class="built_in">resize</span>(k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            ans[i] += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="trapping-rain-water"><a
href="http://oj.leetcode.com/problems/trapping-rain-water/">42.Trapping
Rain Water</a></h3>
<p>对于每个位置，取这个位置<code>左边最高的</code>和<code>右边最高的</code>的较低者，如果<code>较低者</code>比这个位置高，则这个位置存水高度为<code>较低者</code>减该位置高度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector pre;</span><br><span class="line">        <span class="type">int</span> i, maxheight, ans;</span><br><span class="line">        <span class="keyword">for</span>(i = maxheight = <span class="number">0</span>; i &lt; n; i ++) &#123; maxheight = <span class="built_in">max</span>(A[i], maxheight); pre.<span class="built_in">push_back</span>(maxheight); &#125; <span class="keyword">for</span>(maxheight = ans = <span class="number">0</span>, i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            maxheight = <span class="built_in">max</span>(A[i], maxheight);</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(pre[i] - A[i], maxheight - A[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="first-missing-positive"><a
href="http://oj.leetcode.com/problems/first-missing-positive/">41.First
Missing Positive</a></h3>
<p>题目要求时间O(n)，空间O(1)，经分析，不得不破坏原数组 A。</p>
<p>方法一：</p>
<p>剔除非整数，把原数组 A 当作存在标记，存在的数 x 则 A[x-1]取负数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>)</span><br><span class="line">                A[j ++] = A[i];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; j; i ++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(A[i]) &lt;= j)</span><br><span class="line">                A[<span class="built_in">abs</span>(A[i]) - <span class="number">1</span>] = -<span class="built_in">abs</span>(A[<span class="built_in">abs</span>(A[i]) - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; j; i ++) <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：把出现的符合范围的数swap到下标和数对应的位置，再次遍历，数和下标不对应则是第一个没出现的数。注意处理有重复数字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">while</span>(A[i] &lt;= n &amp;&amp; A[i] &gt; <span class="number">0</span> &amp;&amp; A[i] != i + <span class="number">1</span> &amp;&amp; A[A[i] - <span class="number">1</span>] != A[i])</span><br><span class="line">                <span class="built_in">swap</span>(A[i], A[A[i] - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="combination-sum"><a
href="http://oj.leetcode.com/problems/combination-sum/">40.Combination
Sum</a></h3>
<p>基础DFS</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector tmp;</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector &amp;num, <span class="type">int</span> ith, <span class="type">int</span> now, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ith == num.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(num, ith + <span class="number">1</span>, now, target);</span><br><span class="line">            now += num[ith];</span><br><span class="line">            cnt ++;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(num[ith]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cnt --) tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">combinationSum</span><span class="params">(vector &amp;candidates, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">DFS</span>(candidates, <span class="number">0</span>, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="combination-sum-ii"><a
href="http://oj.leetcode.com/problems/combination-sum-ii/">39.Combination
Sum II</a></h3>
<p>如果一个数没有被用，那么后面重复的这个数就别用，避免重复解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector tmp;</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector &amp;num, <span class="type">int</span> ith, <span class="type">int</span> now, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ith == num.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> nex;</span><br><span class="line">        <span class="keyword">for</span>(nex = ith + <span class="number">1</span>; nex &lt; num.<span class="built_in">size</span>() &amp;&amp; num[nex] == num[ith]; nex ++);</span><br><span class="line">        <span class="built_in">DFS</span>(num, nex, now, target);</span><br><span class="line">        <span class="keyword">if</span>(num[ith] + now &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            now += num[ith];</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(num[ith]);</span><br><span class="line">            <span class="built_in">DFS</span>(num, ith + <span class="number">1</span>, now, target);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">combinationSum2</span><span class="params">(vector &amp;num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">DFS</span>(num, <span class="number">0</span>, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="count-and-say"><a
href="http://oj.leetcode.com/problems/count-and-say/">38.Count and
Say</a></h3>
<p>直接模拟，递推。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string f[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i &amp; <span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; f[i &amp; <span class="number">1</span> ^ <span class="number">1</span>].<span class="built_in">length</span>();)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cnt;</span><br><span class="line">                <span class="type">char</span> x = f[i &amp; <span class="number">1</span> ^ <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span>(cnt = <span class="number">0</span>; j &lt; f[i &amp; <span class="number">1</span> ^ <span class="number">1</span>].<span class="built_in">length</span>() &amp;&amp; f[i &amp; <span class="number">1</span> ^ <span class="number">1</span>][j] == x; cnt ++, j ++);</span><br><span class="line">                f[i &amp; <span class="number">1</span>] += <span class="string">&#x27;0&#x27;</span> + cnt;</span><br><span class="line">                f[i &amp; <span class="number">1</span>] += x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n &amp; <span class="number">1</span> ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sudoku-solver"><a
href="http://oj.leetcode.com/problems/sudoku-solver/">37.Sudoku
Solver</a></h3>
<p>这道题考察回溯和数独结果的判断。ACM做过，就直接拿dancing
links代码了，4ms。</p>
<p>关于dancing links，对于面试题来说变态了些，应该不至于考察。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> rw[<span class="number">10</span>], cl[<span class="number">10</span>], in[<span class="number">10</span>], RW[<span class="number">81</span>], CL[<span class="number">81</span>], IN[<span class="number">81</span>], goal;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mark</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rw[RW[i]] ^= <span class="number">1</span> &lt;&lt; num;</span><br><span class="line">        cl[CL[i]] ^= <span class="number">1</span> &lt;&lt; num;</span><br><span class="line">        in[IN[i]] ^= <span class="number">1</span> &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i)</span><br><span class="line">            cl[i] = rw[i] = in[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = goal = <span class="number">0</span>; buf[i]; ++ i)</span><br><span class="line">            goal += buf[i] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">81</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            RW[i] = i / <span class="number">9</span>, CL[i] = i % <span class="number">9</span>, IN[i] = i / <span class="number">3</span> % <span class="number">3</span> + i / <span class="number">27</span> * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(buf[i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="built_in">Mark</span>(i, buf[i] - <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Judge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> ~(rw[RW[i]] | cl[CL[i]] | in[IN[i]]) &amp; (<span class="number">1</span> &lt;&lt; num);&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Oper</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> k, <span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Mark</span>(sx, k), buf[sx] = k + <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(cur + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Mark</span>(sx, k), buf[sx] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">JudgeRWCLIN</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j, k, x, cnt, sx;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++ k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(~rw[i] &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(j = cnt = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = i * <span class="number">9</span> + j;</span><br><span class="line">                        <span class="keyword">if</span>(buf[x] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; <span class="built_in">Judge</span>(x, k)) ++ cnt, sx = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">Oper</span>(sx, k, cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(~cl[i] &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(j = cnt = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = j * <span class="number">9</span> + i;</span><br><span class="line">                        <span class="keyword">if</span>(buf[x] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; <span class="built_in">Judge</span>(x, k)) ++ cnt, sx = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">Oper</span>(sx, k, cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(~in[i] &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(j = cnt = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = i / <span class="number">3</span> * <span class="number">27</span> + j / <span class="number">3</span> * <span class="number">9</span> + i % <span class="number">3</span> * <span class="number">3</span> + j % <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">if</span>(buf[x] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; <span class="built_in">Judge</span>(x, k)) ++ cnt, sx = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">Oper</span>(sx, k, cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j, num, cnt;</span><br><span class="line">        <span class="keyword">if</span>(cur == goal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">81</span>; ++ i)</span><br><span class="line">            <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j = cnt = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">Judge</span>(i, j)) ++ cnt, num = j;</span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">Oper</span>(i, num, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>((num = <span class="built_in">JudgeRWCLIN</span>(cur)) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">81</span>; ++ i)</span><br><span class="line">            <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">Judge</span>(i, j))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">Mark</span>(i, j), buf[i] = j + <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">dfs</span>(cur + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">Mark</span>(i, j), buf[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> site = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++)</span><br><span class="line">                buf[site ++] = board[i][j];</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        site = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++)</span><br><span class="line">                board[i][j] = buf[site ++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="valid-sudoku"><a
href="http://oj.leetcode.com/problems/valid-sudoku/">36.Valid
Sudoku</a></h3>
<p>行列九宫格都判断一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag[<span class="number">3</span>][<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="literal">false</span>, <span class="built_in">sizeof</span>(flag));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> x = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(flag[<span class="number">0</span>][i][x] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    flag[<span class="number">0</span>][i][x] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(flag[<span class="number">1</span>][j][x] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    flag[<span class="number">1</span>][j][x] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(flag[<span class="number">2</span>][i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>][x] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    flag[<span class="number">2</span>][i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-insert-position"><a
href="http://oj.leetcode.com/problems/search-insert-position/">35.Search
Insert Position</a></h3>
<p>二分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid;</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = n; left &lt; right; ) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-for-a-range"><a
href="http://oj.leetcode.com/problems/search-for-a-range/">34.Search for
a Range</a></h3>
<p>二分，容易错。可以用lower_bound和upper_bound。</p>
<p>手工代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">searchRange</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid, l, r;</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = n; left &lt; right; ) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt;= target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l = left;</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = n; left &lt; right; ) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= n || A[l] != target) <span class="keyword">return</span> <span class="built_in">vector</span>(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        vector ans = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>STL：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">searchRange</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">lower_bound</span>(A, A + n, target) - A;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">upper_bound</span>(A, A + n, target) - A;</span><br><span class="line">        <span class="keyword">if</span>(l == n || A[l] != target) <span class="keyword">return</span> <span class="built_in">vector</span>(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        vector ans = &#123;l, r - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-in-rotated-sorted-array"><a
href="http://oj.leetcode.com/problems/search-in-rotated-sorted-array/">33.Search
in Rotated Sorted Array</a></h3>
<p>还是二分，但是要判断一下 mid 在哪部分里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt;= A[left])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; A[mid] &amp;&amp; A[left] &lt;= target) right = mid;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt;= A[right] &amp;&amp; A[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-valid-parentheses"><a
href="http://oj.leetcode.com/problems/longest-valid-parentheses/">32.Longest
Valid Parentheses</a></h3>
<p>这道题时间限制在<code>O(n)</code>，用一个 stack 实现括号配对+统计,
为了方便实现，写成数组的形式。</p>
<p>对不同深度的括号配对统计个数，一层配对成功把该层统计结果加给上一层，这一层清空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">cnt</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i, ans;</span><br><span class="line">        <span class="keyword">for</span>(i = ans = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123; <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) cnt.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="keyword">else</span> &#123; <span class="keyword">if</span>(cnt.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt[cnt.<span class="built_in">size</span>() - <span class="number">2</span>] += *cnt.<span class="built_in">rbegin</span>() + <span class="number">2</span>;</span><br><span class="line">                    cnt.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, *cnt.<span class="built_in">rbegin</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="next-permutation"><a
href="http://oj.leetcode.com/problems/next-permutation/">31.Next
Permutation</a></h3>
<p>从后往前找到第一个非降序的
<code>num[i]</code>，再重新从后往前找到第一个比 <code>num[i]</code>
大的，<code>swap(num[i], num[j])</code>，再把 <code>i</code>
之后的排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = num.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span> &amp;&amp; num[i] &gt;= num[i + <span class="number">1</span>]; i --);</span><br><span class="line">        <span class="keyword">for</span>(j = num.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i &amp;&amp; num[j] &lt;= num[i]; j --);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(num[i], num[j]);</span><br><span class="line">            <span class="built_in">sort</span>(num.<span class="built_in">begin</span>() + i + <span class="number">1</span>, num.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">reverse</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="substring-with-concatenation-of-all-words"><a
href="http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/">30.Substring
with Concatenation of All Words</a></h3>
<p>直观的方法是枚举起点，判断这个起点下的子串是否合法，<code>O(S.length()*L.size())</code>。</p>
<p>其实可以把 S 分成 <code>L[0].length()</code>
个序列，每个序列都是元素间相隔 <code>L[0].length()</code>
的(string开头)，这些序列互不相干。</p>
<p>如下表，假设
<code>L[0].length()=4</code>，第一行数字为分组组号，第二行数字表示 S
的序号。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0)|(1)|(2)|(3)|(0)|(1)|(2)|(3)|(0)|(1)|(2)|(3)|(0)|(1)|(2)|(3)|(0)|(1)|(2)|(3)|(0)|</span><br><span class="line"> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| 14| 15| 16| 17| 18| 19| 20|</span><br></pre></td></tr></table></figure>
对每个序列，用单调队列的思路来处理，一个一个子串入队，当包含了 L 中所有
string 的时候，保存答案。当新元素入队时超出统计允许时————即 L 中有 3 个
"str", 而这时候遇到第 4 个————则开始出队，一直出到队列里不足 3 个
"str"，然后继续。</p>
<p>这样复杂度为<code>O(L[0].length() * S.length() / L[0].length()) = O(S.length())</code>。目前提交结果是180ms。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">findSubstring</span><span class="params">(string S, vector &amp;L)</span> </span>&#123;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="keyword">if</span>(L.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; mp, sum;</span><br><span class="line">        <span class="type">int</span> llen = L[<span class="number">0</span>].<span class="built_in">length</span>(), i, front, rear;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(L[i])) mp[L[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[L[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; llen; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = mp;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(front = rear = i; front + llen &lt;= S.<span class="built_in">length</span>(); front += llen) &#123; </span><br><span class="line">               string tmp = S.<span class="built_in">substr</span>(front, llen); </span><br><span class="line">               <span class="keyword">if</span>(sum.<span class="built_in">count</span>(tmp)) </span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="keyword">if</span>(sum[tmp] &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum[tmp] --;</span><br><span class="line">                        cnt ++;</span><br><span class="line">                        <span class="keyword">if</span>(cnt == L.<span class="built_in">size</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans.<span class="built_in">push_back</span>(rear);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">while</span>(sum[tmp] == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            string ntmp = S.<span class="built_in">substr</span>(rear, llen);</span><br><span class="line">                            sum[ntmp] ++;</span><br><span class="line">                            cnt --;</span><br><span class="line">                            rear += llen;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sum[tmp] --;</span><br><span class="line">                        cnt ++;</span><br><span class="line">                        <span class="keyword">if</span>(cnt == L.<span class="built_in">size</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans.<span class="built_in">push_back</span>(rear);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(rear &lt; front)</span><br><span class="line">                    &#123;</span><br><span class="line">                        string ntmp = S.<span class="built_in">substr</span>(rear, llen);</span><br><span class="line">                        sum[ntmp] ++;</span><br><span class="line">                        cnt --;</span><br><span class="line">                        rear += llen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rear += llen;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="divide-two-integers"><a
href="http://oj.leetcode.com/problems/divide-two-integers/">29.Divide
Two Integers</a></h3>
<p>假设 dividend 与 divisor 正负一致， <code>divisor^(2^n)</code>
为最接近 dividend 的 divisor 的幂，那么令
<code>newdividend = dividend - divisor^(2^n)</code>，<code>ans = ans + 2^n</code>，问题就更新为
newdividend 除以 divisor，如此迭代。用 divisor<sup>(2</sup>n) 是因为
divisor 不停地辗转加自己就可以得到了。</p>
<p>有 <code>-2147483648</code> 这样的极限数据，因为 int 范围是
<code>-2147483648~+2147483647</code>，发现负数比正数范围(多1)，干脆把所有数都转成负数算，这样就避免用
long long 了。最后考察一下flag。</p>
<p>（如果转成正数的话，int 的 -(-2147483648)还是 -2147483648。。）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor &gt; <span class="number">0</span>) divisor = -divisor, flag ^= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dividend &gt; <span class="number">0</span>) dividend = -dividend, flag ^= <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, res = divisor, ex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor &lt; dividend) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">while</span>(res &gt;= dividend - res)</span><br><span class="line">        &#123;</span><br><span class="line">            res += res;</span><br><span class="line">            ex += ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res &lt;= divisor &amp;&amp; dividend) &#123; <span class="keyword">if</span>(res &gt;= dividend)</span><br><span class="line">            &#123;</span><br><span class="line">                dividend -= res;</span><br><span class="line">                ans += ex;</span><br><span class="line">            &#125;</span><br><span class="line">            res &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ex &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="implement-strstr"><a
href="http://oj.leetcode.com/problems/implement-strstr/">28.Implement
strStr()</a></h3>
<p>KMP。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">strStr</span><span class="params">(<span class="type">char</span> *haystack, <span class="type">char</span> *needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hlen = (<span class="type">int</span>)<span class="built_in">strlen</span>(haystack), nlen = (<span class="type">int</span>)<span class="built_in">strlen</span>(needle);</span><br><span class="line">        <span class="keyword">if</span>(nlen == <span class="number">0</span>) <span class="keyword">return</span> haystack;</span><br><span class="line">        <span class="function">vector <span class="title">next</span><span class="params">(nlen + <span class="number">1</span>)</span></span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; nlen;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || needle[i] == needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i ++, j ++;</span><br><span class="line">                <span class="keyword">if</span>(needle[i] != needle[j]) next[i] = j;</span><br><span class="line">                <span class="keyword">else</span> next[i] = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; hlen;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || haystack[i] == needle[j])</span><br><span class="line">                i ++, j ++;</span><br><span class="line">            <span class="keyword">else</span> j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(j == nlen) <span class="keyword">return</span> haystack + i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-element"><a
href="http://oj.leetcode.com/problems/remove-element/">27.Remove
Element</a></h3>
<p>两个游标 i, j 异步挪动，把不等于给定值的数往前挪。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> elem)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] != elem) A[j ++] = A[i];</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-duplicates-from-sorted-array"><a
href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/">26.Remove
Duplicates from Sorted Array</a></h3>
<p>两个游标 i, j 异步挪动，不重复值往前挪。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] != A[i - <span class="number">1</span>]) A[j ++] = A[i];</span><br><span class="line">        <span class="keyword">return</span> n ? j : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-nodes-in-k-group"><a
href="http://oj.leetcode.com/problems/reverse-nodes-in-k-group/">25.Reverse
Nodes in k-Group</a></h3>
<p>用头插法来做的，顺序插入到首节点之后，就反转了。每 k
个节点处理之后，把首节指针点移动到下 k 个的开头。最后面不足 k
个的话，再反转回来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Reverse</span><span class="params">(ListNode *&amp;pre, ListNode *&amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        ListNode *nex, *tmp;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; p != <span class="literal">NULL</span>; i ++, p = tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) nex = p;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="keyword">if</span>(i == k) i = <span class="number">0</span>, pre = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        nex-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *tmphead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *pre = tmphead, *p = head;</span><br><span class="line">        tmphead-&gt;next = head;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Reverse</span>(pre, p, k) != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            <span class="built_in">Reverse</span>(pre, p, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="swap-nodes-in-pairs"><a
href="http://oj.leetcode.com/problems/swap-nodes-in-pairs/">24.Swap
Nodes in Pairs</a></h3>
<p>Reverse Nodes in k-Group的简化版。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">swapPairs</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *tmphead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *pre = tmphead, *p = head, *tmp, *nex;</span><br><span class="line">        tmphead-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; p != <span class="literal">NULL</span>; i ++, p = tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span> ^ <span class="number">1</span>) nex = p;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>) pre = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        nex-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> tmphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="merge-k-sorted-lists"><a
href="http://oj.leetcode.com/problems/merge-k-sorted-lists/">23.Merge k
Sorted Lists</a></h3>
<p>一个堆（这里用了优先级队列），把所有 list
的首元素放堆里，O(logn)取得最小值插入新队列，异步推进。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">comp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(vector &amp;lists)</span> </span>&#123;</span><br><span class="line">        ListNode *tmphead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = tmphead;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, comp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); i ++) <span class="keyword">if</span>(lists[i] != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(lists[i]); <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123; p-&gt;next = q.<span class="built_in">top</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p -&gt;next != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="generate-parentheses"><a
href="http://oj.leetcode.com/problems/generate-parentheses/">22.Generate
Parentheses</a></h3>
<p>DFS，保持当前右括号不多于左括号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string tmp;</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right &amp;&amp; left == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[left + right] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(left + <span class="number">1</span>, right, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[left + right] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(left, right + <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="merge-two-sorted-lists"><a
href="http://oj.leetcode.com/problems/merge-two-sorted-lists/">21.Merge
Two Sorted Lists</a></h3>
<p>归并排序的一次操作，设个哨兵头结点，结束后free。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *thead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = thead;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) p-&gt;next = l1, p = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = l2, p = l2, l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span>) p-&gt;next = l1, p = l1, l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">NULL</span>) p-&gt;next = l2, p = l2, l2 = l2-&gt;next;</span><br><span class="line">        p = thead-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(thead);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="valid-parentheses"><a
href="http://oj.leetcode.com/problems/valid-parentheses/">20.Valid
Parentheses</a></h3>
<p>用栈配对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: st.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: st.<span class="built_in">push</span>(<span class="string">&#x27;[&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: st.<span class="built_in">push</span>(<span class="string">&#x27;&#123;&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    st.<span class="built_in">pop</span>(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    st.<span class="built_in">pop</span>(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    st.<span class="built_in">pop</span>(); <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-nth-node-from-end-of-list"><a
href="http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">19.Remove
Nth Node From End of List</a></h3>
<p>两个指针相隔 n
距离，前面的指针到了末尾，后面的指针就是删除的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *pre, *slow, *quick;</span><br><span class="line">        ListNode *newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        newhead-&gt;next = head;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(pre = slow = quick = newhead; quick != <span class="literal">NULL</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= n) slow = slow-&gt;next;</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = slow-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(slow);</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sum"><a
href="http://oj.leetcode.com/problems/4sum/">18.4Sum</a></h3>
<p>尝试了<code>O(n^2)</code>的，但是应该常数很大吧，超时了。就是哈希存两两的和，然后通过查哈希表找到
两两+两两，要判断数字重复情况。这题数据量挺大的，<code>O(n^3)</code>如果用不太好的方式实现的话也会超。</p>
<p><code>O(n^3)</code>方法：先对num排序，然后从两头枚举两个数，<code>O(n^2)</code>，后两个数在前两个数之间的两端开始，和小了左边的往右，和大了右边的往左调整，<code>O(n)</code>，总共<code>O(n^3)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">fourSum</span><span class="params">(vector &amp;num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>() &lt; <span class="number">4</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left = <span class="number">0</span>; left &lt; num.<span class="built_in">size</span>() - <span class="number">3</span>;) &#123; <span class="keyword">for</span>(<span class="type">int</span> right = num.<span class="built_in">size</span>() - <span class="number">1</span>; right &gt; left + <span class="number">2</span>;) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> ml = left + <span class="number">1</span>, mr = right - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(ml &lt; mr) </span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="type">int</span> tmpsum = num[left] + num[right] + num[ml] + num[mr]; </span><br><span class="line">                    <span class="keyword">if</span>(tmpsum &gt; target) mr --;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &lt; target) ml ++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        vector tmp = &#123;num[left], num[ml], num[mr], num[right]&#125;;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                        ml ++;</span><br><span class="line">                        mr --;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(; ml != left + <span class="number">1</span> &amp;&amp; ml &lt; mr &amp;&amp; num[ml] == num[ml - <span class="number">1</span>]; ml ++);</span><br><span class="line">                    <span class="keyword">for</span>(; mr != right - <span class="number">1</span> &amp;&amp; ml &lt; mr &amp;&amp; num[mr] == num[mr + <span class="number">1</span>]; mr --); </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">for</span>(right --; right &gt; left + <span class="number">2</span> &amp;&amp; num[right] == num[right + <span class="number">1</span>]; right --);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(left ++; left &lt; num.<span class="built_in">size</span>() - <span class="number">3</span> &amp;&amp; num[left] == num[left - <span class="number">1</span>]; left ++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="letter-combinations-of-a-phone-number"><a
href="http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/">17.Letter
Combinations of a Phone Number</a></h3>
<p>基础DFS。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> vector v = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    vector ans;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, string d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == d.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[d[cur] - <span class="string">&#x27;0&#x27;</span>].<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[cur] = v[d[cur] - <span class="string">&#x27;0&#x27;</span>][i];</span><br><span class="line">            <span class="built_in">DFS</span>(cur + <span class="number">1</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">resize</span>(digits.<span class="built_in">length</span>());</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sum-closest"><a
href="http://oj.leetcode.com/problems/3sum-closest/">16.3Sum
Closest</a></h3>
<p><code>O(n^2)</code>，先排序，枚举第一个数，后两个数一个在第一个数后边一个开始，一个从
末尾开始，和4Sum类似调整。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector &amp;num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> findans = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> left = i + <span class="number">1</span>, right = num.<span class="built_in">size</span>() - <span class="number">1</span>; left &lt; right;) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="type">int</span> tmpsum = num[i] + num[left] + num[right]; </span><br><span class="line">                <span class="keyword">if</span>(tmpsum &gt; target) right --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &lt; target) left ++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> tmpsum;</span><br><span class="line">                <span class="keyword">if</span>(!findans || <span class="built_in">abs</span>(tmpsum - target) &lt; <span class="built_in">abs</span>(ans - target))</span><br><span class="line">                    ans = tmpsum, findans = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sum-1"><a
href="http://oj.leetcode.com/problems/3sum/">15.3Sum</a></h3>
<p>同上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">threeSum</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> left = i + <span class="number">1</span>, right = num.<span class="built_in">size</span>() - <span class="number">1</span>; left &lt;right;)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmpsum = num[i] + num[left] + num[right];</span><br><span class="line">                <span class="keyword">if</span>(tmpsum &lt; <span class="number">0</span>) left ++; <span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &gt; <span class="number">0</span>) right --;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vector tmp = &#123;num[i], num[left], num[right]&#125;;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                    left ++;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(; left != i + <span class="number">1</span> &amp;&amp; left &lt; right &amp;&amp; num[left] == num[left - <span class="number">1</span>]; left ++);</span><br><span class="line">                <span class="keyword">for</span>(; right != num.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; left &lt; right &amp;&amp; num[right] == num[right + <span class="number">1</span>]; right --);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i ++; i &lt; num.<span class="built_in">size</span>() &amp;&amp; num[i] == num[i - <span class="number">1</span>]; i ++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-common-prefix"><a
href="http://oj.leetcode.com/problems/longest-common-prefix/">14.Longest
Common Prefix</a></h3>
<p>一个一个扫</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector &amp;strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; ; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i ++)</span><br><span class="line">                <span class="keyword">if</span>(strs[i].<span class="built_in">size</span>() == j || strs[i][j] != strs[i - <span class="number">1</span>][j]) <span class="keyword">return</span> ans;</span><br><span class="line">            ans += strs[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="roman-to-integer"><a
href="http://oj.leetcode.com/problems/roman-to-integer/">13.Roman to
Integer</a></h3>
<p>各有各的方法，重点是记录(上一个)数比(这个)数大或小，来确定谁减谁。基本是右结合的，所以从后往前扫好处理些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> ro[<span class="number">128</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        ro[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        ro[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        ro[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">        ro[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        ro[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>;</span><br><span class="line">        ro[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        ro[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>, last;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">-1</span>) ans = ro[s[i]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(last &gt; ro[s[i]]) ans -= ro[s[i]];</span><br><span class="line">                <span class="keyword">else</span> ans += ro[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            last = ro[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="integer-to-roman"><a
href="http://oj.leetcode.com/problems/integer-to-roman/">12.Integer to
Roman</a></h3>
<p>每个十进制位格式是一样的，只是字母替换一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector table = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">    string ro = <span class="string">&quot;IVXLCDM&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">convert</span><span class="params">(<span class="type">char</span> x, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;I&#x27;</span>) <span class="keyword">return</span> ro[i];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;V&#x27;</span>) <span class="keyword">return</span> ro[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span> ro[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; num; i += <span class="number">2</span>, num /= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = num % <span class="number">10</span>;</span><br><span class="line">            string tmp = table[x];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; tmp.<span class="built_in">size</span>(); j ++)</span><br><span class="line">                tmp[j] = <span class="built_in">convert</span>(tmp[j], i);</span><br><span class="line">            ans = tmp + ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="container-with-most-water"><a
href="http://oj.leetcode.com/problems/container-with-most-water/">11.Container
With Most Water</a></h3>
<p>从两端开始枚举，较高的挡板往中间枚举的话一定无法得到更优解，故反复从较低挡板向中间枚举，O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[left], height[right]) * (right - left));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) left ++;</span><br><span class="line">            <span class="keyword">else</span> right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="regular-expression-matching"><a
href="http://oj.leetcode.com/problems/regular-expression-matching/">10.Regular
Expression Matching</a></h3>
<p>每遇到一个 <code>*</code>
，问题都会出现分枝，需要用到栈或者递归。</p>
<p>没有 <code>*</code> 的情况好处理，遇到 <code>*</code>
的时候，穷举所有匹配长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == <span class="number">0</span>) <span class="keyword">return</span> *s == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(*(p + <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*s &amp;&amp; (*s == *p || *p == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">isMatch</span>(s + <span class="number">1</span>, p + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(; *s &amp;&amp; (*s == *p || *p == <span class="string">&#x27;.&#x27;</span>); s ++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isMatch</span>(s, p + <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isMatch</span>(s, p + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="palindrome-number"><a
href="http://oj.leetcode.com/problems/palindrome-number/">9.Palindrome
Number</a></h3>
<p>首先处理负数的trick。然后主要思路就是通过
<code>while(...) a = a * 10 + x % 10;</code> 来将 x 翻转。</p>
<p>但是注意到 x 很大的时候，翻转的 x 会超出 int
范围，也许会刚好成为另一个和 a
得出的数相等的正数，所以不能完全翻转后判断，而可以在翻转恰好一半的时候判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = x, cnt = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(x /= <span class="number">10</span>) cnt ++; </span><br><span class="line">        <span class="keyword">for</span>(; b &amp;&amp; cnt &gt;= <span class="number">0</span>; b /= <span class="number">10</span>, cnt -= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="keyword">return</span> a == b / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> a == b;</span><br><span class="line">            a = a * <span class="number">10</span> + b % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="string-to-integer-atoi"><a
href="http://oj.leetcode.com/problems/string-to-integer-atoi/">8.String
to Integer (atoi)</a></h3>
<p>任何类似多符号、符号数字间有空格的小问题都直接输出
0，这就好办了。处理越界用 long long。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(; *str == <span class="string">&#x27; &#x27;</span>; str ++);</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;+&#x27;</span>) str ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;-&#x27;</span>) flag = <span class="literal">true</span>, str ++;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(*str); str ++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + *str - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>((flag ? -ans : ans) &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((flag ? -ans : ans) &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(flag ? -ans : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-integer"><a
href="http://oj.leetcode.com/problems/reverse-integer/">7.Reverse
Integer</a></h3>
<p>还是关于越界的讨论，不过这道题本身没有设置处理方式，重点在于面试时的交流。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> b = x &gt;= <span class="number">0</span> ? x : -x; b; b /= <span class="number">10</span>)</span><br><span class="line">            a = a * <span class="number">10</span> + b % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? a : -a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="zigzag-conversion"><a
href="http://oj.leetcode.com/problems/zigzag-conversion/">6.ZigZag
Conversion</a></h3>
<p>题意的 "z"
字形指一列nRows个，然后斜着往右上一格一个回到第一行，然后再一列nRows个。比如nRows=5，如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1          9          17          25</span><br><span class="line">2       8 10       16 18       24 26</span><br><span class="line">3    7    11    15    19    23    27    …</span><br><span class="line">4 6       12 14       20 22       28 30</span><br><span class="line">5         13          21          29</span><br></pre></td></tr></table></figure>
每行字母在原字符串中的间隔是有规律的，虽然两层for循环，但是s中每个字母只访问了一次，O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> nRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="type">int</span> a = (nRows &lt;&lt; <span class="number">1</span>) - <span class="number">2</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nRows; i ++, a -= <span class="number">2</span>, b += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">                    j += flag ? (b ? b : a) : (a ? a : b), flag ^= <span class="number">1</span>)</span><br><span class="line">                ans += s[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-palindromic-substring"><a
href="http://oj.leetcode.com/problems/longest-palindromic-substring/">5.Longest
Palindromic Substring</a></h3>
<p>网上O(n)的方法是厉害啊。。。简单解释如下：</p>
<p>1、预处理字符串，前后加(哨兵)字符比如
<code>!</code>，每个字母旁边加辅助字符比如<code>#</code>，这样例如字符串
<code>s="ababbcbb"</code> 就变成
<code>tmp="!#a#b#a#b#b#c#b#b#!"</code>。这样的好处是不用讨论回文串长度的奇偶。</p>
<p>2、对转化后的串，维护一个 center 和一个 reach，center 是当前已发现的
reach 最远的回文串中心位置，reach
是这个回文串最右端的位置，center和reach可初始化为
1，即第一个<code>#</code>的位置。</p>
<p>3、维护一个数组<code>vector r(tmp.length())</code>，<code>r[i]</code>
表示 i 位置为中心的回文串半径。</p>
<p>4、在考察位置 i 的时候，所有 j &lt; i 的 r[j] 都是已知的子问题。如果
i 在 reach 的左边，则 i 包含在以 center
为中心的回文串中，那么可以想到，如果和 i 关于 center 对称位置的 mirrori
为中心的回文串覆盖范围没有到达 center 为中心的回文串边缘，则 i
为中心的回文串肯定和 mirrori 的一样。而如果 mirrori
的回文串到达了边缘甚至超过，或者 i 本来就在 reach 的右边，那么对 i
为中心的回文串进行一次扩展，则结果
或者刚好不扩展，或者一定更新了reach。无论怎样，这里都得到了
r[i]。知道了所有 r[i]，答案就出来了。</p>
<p>核心问题在于第4步“对 i 为中心的回文串进行扩展”的复杂度。每次发生“对 i
扩展”，必然是对 reach 的扩展(也可能刚好不扩展，这个不影响复杂度），而
reach 的扩展范围是 tmp 的长度大约 2n，所以总复杂度为 O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> center = <span class="number">1</span>, reach = <span class="number">1</span>, ansstart = <span class="number">0</span>, anslength = <span class="number">0</span>;</span><br><span class="line">        string tmp = <span class="string">&quot;!#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            tmp += s[i], tmp += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        tmp + <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">        <span class="function">vector <span class="title">r</span><span class="params">(tmp.length())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; tmp.<span class="built_in">length</span>(); i ++) &#123; <span class="type">int</span> mirrori = center * <span class="number">2</span> - i; r[i] = reach &gt; i ? <span class="built_in">min</span>(r[mirrori], reach - i) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; tmp[i + r[i] + <span class="number">1</span>] == tmp[i - r[i] - <span class="number">1</span>]; r[i] ++);</span><br><span class="line">            <span class="keyword">if</span>(i + r[i] &gt; reach)</span><br><span class="line">                reach = i + r[i], center = i;</span><br><span class="line">            <span class="keyword">if</span>(r[i] &gt; anslength)</span><br><span class="line">            &#123;</span><br><span class="line">                ansstart = i - r[i] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                anslength = r[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(ansstart, anslength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="median-of-two-sorted-arrays"><a
href="http://oj.leetcode.com/problems/median-of-two-sorted-arrays/">4.Median
of Two Sorted Arrays</a></h3>
<p>如果 A[pa] &lt; B[pb]，那么 A[pa] 一定在 A 与 B 合并后的前 pa + pb +
2 个数中。</p>
<p>证明： A 中有 pa + 1 个数 &lt;= A[pa]，B 中有小于 pb + 1 个数 &lt;=
A[pa]，合并后有少于pa + pb + 2 个数 &lt;= A[pa]。</p>
<p>利用这个性质迭代找 A 与 B 合并后的第 k 大数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> m, <span class="type">int</span> B[], <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> pm, pn;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> B[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> A[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(A[k - <span class="number">1</span>], B[k - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(m &lt;= n) pm = <span class="built_in">min</span>(k &gt;&gt; <span class="number">1</span>, m), pn = k - pm;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pn = <span class="built_in">min</span>(k &gt;&gt; <span class="number">1</span>, n), pm = k - pn;</span><br><span class="line">            <span class="keyword">if</span>(A[pm - <span class="number">1</span>] &lt; B[pn - <span class="number">1</span>]) A += pm, m -= pm, k -= pm; <span class="keyword">else</span> <span class="keyword">if</span>(A[pm - <span class="number">1</span>] &gt; B[pn - <span class="number">1</span>]) </span><br><span class="line">                B += pn, n -= pn, k-= pn;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[pm - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> m, <span class="type">int</span> B[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((m + n) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">findKth</span>(A, m, B, n, (m + n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">return</span> (<span class="built_in">findKth</span>(A, m, B, n, m + n &gt;&gt; <span class="number">1</span>) +</span><br><span class="line"></span><br><span class="line">            <span class="built_in">findKth</span>(A, m, B, n, (m + n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-substring-without-repeating-characters"><a
href="http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/">3.Longest
Substring Without Repeating Characters</a></h3>
<p>维护一个不重复字符的区间。</p>
<p>代码一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">isin</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>; front &lt; s.<span class="built_in">length</span>(); front ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isin[s[front]])</span><br><span class="line">                <span class="keyword">for</span>(; rear &lt; front &amp;&amp; isin[s[front]]; isin[s[rear]] = <span class="literal">false</span>, rear ++);</span><br><span class="line">            isin[s[front]] = <span class="literal">true</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, front - rear + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">site</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> nowstart = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123; <span class="keyword">if</span>(site[s[i]] &gt;= nowstart)</span><br><span class="line">                nowstart = site[s[i]] + <span class="number">1</span>;</span><br><span class="line">            site[s[i]] = i;</span><br><span class="line">            ans = <span class="built_in">max</span>(i - nowstart + <span class="number">1</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="add-two-numbers"><a
href="http://oj.leetcode.com/problems/add-two-numbers/">2.Add Two
Numbers</a></h3>
<p>大整数加法的链表版。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = ans;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span> || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;val = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + cur;</span><br><span class="line">            cur = p-&gt;val / <span class="number">10</span>;</span><br><span class="line">            p-&gt;val %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1 || l2 || cur)</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="two-sum"><a
href="http://oj.leetcode.com/problems/two-sum/">1.Two Sum</a></h3>
<p>哈希存位置，O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">twoSum</span><span class="params">(vector &amp;numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(target - numbers[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(mp[target - numbers[i]] + <span class="number">1</span>);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(numbers[i])) mp[numbers[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode题解</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>2015省赛</title>
    <url>/2015-08-29-2015hncpc/</url>
    <content><![CDATA[<p>很忙很累的就不多说了。</p>
<p>比赛顺利开始之后，整个一天就在忙外网rank了。。。</p>
<p>没有独立IP，没有端口映射，数据库同步这个之前配过一次被吓着了好麻烦不打算用。</p>
<p>于是考虑把数据从内网往外推。
总不可能频繁复制数据库，最终决定推rank页的html。</p>
<p>然后问题来了。</p>
<h2 id="section"><span id="more"></span></h2>
<p>1 跨域问题</p>
<p>用jsonp好了。</p>
<p>2 jsonp只能get不能post</p>
<p>这么长的页面代码。。只好用后台来post了</p>
<p>3 最终保存到外网sql的页面代码不完整</p>
<p>怀疑是post功能代码的问题。换了n种，都不行。
php.ini神马的肯定都设置正确了。
难道post也限制长度？这好像不科学。先试试控制长度吧，用rank页后台推来的json。</p>
<p>4 json信息不完整</p>
<p>服务器除了后台json外，已经有了部分信息，所以只用后台json数据的话还原不了rank，还得直接取页面。</p>
<p>中间各种代码bug的也够折腾的。</p>
<p>最最最最最后，比赛都结束一个多小时了……终于，怀疑是服务器数据库存html代码的问题。到底是什么问题呢……暂未搞懂，但是把数据存文件就好了T_T。。。。。。</p>
<p>于是终于外网能看榜了，不过比赛总榜也早发出来了，这功能明年用吧。。。</p>
]]></content>
  </entry>
  <entry>
    <title>Python引入外部文件夹或其他工程的搜索目录设置方法</title>
    <url>/2016-05-11-python-import-outer-folder-project/</url>
    <content><![CDATA[<p>首先耦合性最低的方式是在代码中加入搜索目录，绝对路径相对路径都可以。这种方式在PyCharm中，引入外部路径的那行会有红色波浪线提示语法问题，不过能正常运行。
<span id="more"></span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&#x27;/../../somepath/&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>简单粗暴的方式是添加环境变量PYTHONPATH，把想要的搜索目录加进去，就能直接import了。引入工程外代码的时候比较方便。</p>
<p>工程内加了__init__.py的目录都被理解为包，文件内容空着就可以。</p>
<p>假设如下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base/</span><br><span class="line">--/__init__.py</span><br><span class="line">--/a/</span><br><span class="line">--/--/__init__.py</span><br><span class="line">--/--/test.py</span><br><span class="line">--/b/</span><br><span class="line">--/--/__init__.py</span><br><span class="line">--/--/run.py</span><br></pre></td></tr></table></figure>
<p>我们要在run.py中引入test.py，则在run.py中写 import a.test
就可以了。</p>
]]></content>
  </entry>
  <entry>
    <title>Python使用LibSVM</title>
    <url>/2016-05-13-python-libsvm/</url>
    <content><![CDATA[<p>一开始打算用OpenCV的SVM，不过好像有些bug，训练有问题，保存model之后load()也有问题，于是用LibSVM了。</p>
<p>LibSVM提供了Python的接口，去官网下载他们的包，解压后有Python文件夹，把这个Python文件夹路径加入到环境变量（可能要新建）PYTHONPATH中。
<span id="more"></span> 代码里常用的就下面这几行，简单粗暴哈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> svmutil <span class="keyword">as</span> svm</span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">model = svm.svm_train(trainY, trainX, <span class="string">&#x27;-c 4&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">svm.svm_save_model(<span class="string">&#x27;../filepath/model.dat&#x27;</span>, model)</span><br><span class="line"><span class="comment"># 读取模型</span></span><br><span class="line">model = svm.svm_load_model(<span class="string">&#x27;../filepath/model.dat&#x27;</span>)</span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">p_label, p_acc, p_val = svm.svm_predict(testY, testX, model)</span><br></pre></td></tr></table></figure>
<p>训练数据格式也很直接，trainX是二维数组，trainX[i][j] 表示第 i
组训练数据的第 j 个属性值。</p>
<p>trainY是一维数组，trainY[i]就是第 i 组数据的标签。</p>
<p>test数据同上。testY不影响预测结果，不过如果testY是对应的测试集标签，那么可以得到正确的预测精度值。</p>
]]></content>
  </entry>
  <entry>
    <title>Python多线程（线程池）与多进程（进程池）简单使用</title>
    <url>/2016-05-10-python-threadpool-processpool/</url>
    <content><![CDATA[<p>目前Python<strong>多线程</strong>不能利用CPU多核优势，IO密集型可用<strong>多线程</strong>，CPU密集型适合用<strong>多进程</strong>。</p>
<span id="more"></span>
<p>首先定义一个用来并行跑的函数，加一个随机sleep时间好感受并行的结果，两个参数好理解并行时多参数怎么传递。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Test</span>(<span class="params">a, b</span>):</span><br><span class="line">    time.sleep(random.randint(<span class="number">5</span>, <span class="number">20</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(a) + <span class="string">&#x27;_&#x27;</span> + <span class="built_in">str</span>(b) + <span class="string">&#x27;\t&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="线程池">线程池</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> threadpool</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MultiThreadTest</span>():</span><br><span class="line">    pool = threadpool.ThreadPool(<span class="number">20</span>)</span><br><span class="line">    li = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        li.append((<span class="literal">None</span>, &#123;<span class="string">&#x27;a&#x27;</span>: i, <span class="string">&#x27;b&#x27;</span>: i + <span class="number">10</span>&#125;))</span><br><span class="line">    requests = threadpool.makeRequests(Test, li)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> requests]</span><br><span class="line">    pool.wait()</span><br></pre></td></tr></table></figure>
<p>threadpool需要安装，pip就可以 多参数用 (None,
{....})，当前版本threadpool 1.3.2是这么写的。</p>
<h3 id="进程池">进程池</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MultiProcessTest</span>():</span><br><span class="line">    pool = multiprocessing.Pool(processes = <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        pool.apply_async(Test, (i, i + <span class="number">10</span>, ))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>
<p>先close后join。</p>
<h3 id="共享数据">共享数据</h3>
<p>另外，多线程可以用Python的Queue共享数据，多进程要用multiprocessing.Queue。</p>
<p>这里尝试用multiprocessing的dict保存数据。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Test</span>(<span class="params">a, b, mpDict</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(a) + <span class="string">&quot;test&quot;</span>, b)</span><br><span class="line">    mpDict[<span class="built_in">str</span>(a) + <span class="string">&quot;test&quot;</span>] = b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MultiProcessTest</span>():</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line">    mpDict = multiprocessing.Manager().<span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        pool.apply_async(Test, (i, i + <span class="number">10</span>, mpDict, ))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    traditionDict = <span class="built_in">dict</span>(mpDict)</span><br><span class="line">    <span class="built_in">print</span>(traditionDict)</span><br></pre></td></tr></table></figure></p>
<h1 id="生产者-消费者-模型">生产者-消费者 模型</h1>
<p>Pool 共享 Queue 有个
<strong>坑</strong>，<code>multiprocessing.Queue()</code> 只支持 Process
出来的进程，不支持 Pool 的，在 Pool 中需要使用
<code>multiprocessing.Manager()</code></p>
<p>下面代码为 1 个生产者和 4 个消费者的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生产者</span><br><span class="line">def write(q):</span><br><span class="line">    a = np.random.randint(0, 100, (100, 2, 2))</span><br><span class="line">    for value in range(a.shape[0]):</span><br><span class="line">        print(&#x27;Put %s to queue...\n&#x27; % a[value])</span><br><span class="line">        q.put(a[value])</span><br><span class="line">        print(q.qsize())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 消费者:</span><br><span class="line">def read(q):</span><br><span class="line">    while True:</span><br><span class="line">        # get的参数是 block=True, timeout=None</span><br><span class="line">        # block表示队列空时是阻塞等待还是抛出异常</span><br><span class="line">        # timeout指等待一定时间抛出异常，还是无限等待。</span><br><span class="line">        value = q.get(True)</span><br><span class="line">        print(&#x27;Get %s from queue.\n&#x27; % value)</span><br><span class="line">        print(q.qsize())</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_pool():</span><br><span class="line">    manager = mp.Manager()</span><br><span class="line">    q = manager.Queue(2)</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pw.start()</span><br><span class="line">    worker_num = 4</span><br><span class="line">    pool = mp.Pool(processes=worker_num)</span><br><span class="line">    for i in range(worker_num):</span><br><span class="line">        print(&#x27;start data worker &#x27; + str(i))</span><br><span class="line">        pool.apply_async(read, (q, ))</span><br><span class="line">    pool.close()</span><br><span class="line">    pw.join()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>二刷《社交网络》</title>
    <url>/2016-10-18-again-the-social-network/</url>
    <content><![CDATA[<p>最近喜欢看艾森伯格的电影，于是刷列表之余还是想重温下经典《社交网络》。</p>
<span id="more"></span>
<img src="/2016-10-18-again-the-social-network/post.jpg" class="">
<p>不过不想做影评或者大发感慨，只是仔细看了一下电影开始 10
分钟左右扎克"hack"的方法。电脑还在等待编译“开源大法”，就写篇日志吧。
也许是电影为了让大众容易看懂，也许是因为故事背景在十多年前，互联网今非昔比，所以方法并没有多么极客、高端，也就没什么必要写到技术博客了，放在qq空间里纯当娱乐。</p>
<p><br/></p>
<p>首先有个背景，估计节省了扎克很多麻烦，看起来系统是分楼栋来的，那么男女的分开的，不然的话那年代从照片分男女估计就难倒二年级的小扎克了。</p>
<p><br/></p>
<img src="/2016-10-18-again-the-social-network/1-1.jpg" class="">
<img src="/2016-10-18-again-the-social-network/1-2.jpg" class="">
<blockquote>
<p>First up is <strong>Kirkland</strong>. They keep everything open and
allow indexes in their Apache configuration. So a little Wget magic is
all that's necessary to download the entire Kirkland facebook. Kids'
stuff.</p>
</blockquote>
<p>apache允许目录访问，而且照片连号，也就是说照片可以直接下载。wget很方便的命令行下载，通配符jpg就可以了。</p>
<p><br/></p>
<img src="/2016-10-18-again-the-social-network/2-1.jpg" class="">
<img src="/2016-10-18-again-the-social-network/2-2.jpg" class="">
<blockquote>
<p>Next is Eliot. They're also open, but with no indexes on Apache. I
can run an empty search and it returns all of the images in the database
in a single page. And I can save the page and Mozilla will save all the
images for me. Excellent. Moving right along.</p>
</blockquote>
<p>跑一个空搜索就能搜到所有人了，说明这个楼的系统是模糊匹配的，如果是数据库的话，说不定还可以注入。网页上做空白搜索显示所有照片，浏览器有缓存自然保存了照片，当然批量下载也可以。</p>
<p><br/></p>
<img src="/2016-10-18-again-the-social-network/3-1.jpg" class="">
<img src="/2016-10-18-again-the-social-network/3-2.jpg" class="">
<img src="/2016-10-18-again-the-social-network/3-3.jpg" class="">
<blockquote>
<p><strong>Lowell</strong> has some security. They require a user
name/password combo, and I'm gonna go ahead and say they don't have
access to the main FAS user database, so they have no way of detecting
an intrusion.</p>
</blockquote>
<p>这个楼需要用户名密码。这里光看台词还理解不了，需要结合电影中扎克的博客。博客讲到，分开的系统没有权限连接学校总用户系统，所以这个分系统没法拥有每个学生的密码，即需要给学生分发密码。而统一公布并不靠谱，一一分发相当困难，那就尝试每个人都有的信息，于是扎克尝试了学生名字+学号，首先他试了自己的，不知道是取消了还是没通过，后面又试了一个bolson，至于怎么得到的就没说了，姓名学号这个东西也不难得到。
接着是他博客的内容，图片是分开的网页上的，那就需要脚本上场了，他用的perl（记得上次刷的时候中文字幕是Python，看来字幕组也有有立场的程序猿）。
仅仅是下载有规律地址的图片的话，这类脚本一般比较简单，几行代码的事。
台词提到因为系统没有FAS user
database的权限，所以他们无法察觉到入侵，这个因果关系不是太明了。
也许是扎克解释了下刚刚用自己名字登录了一下的问题吧，比如系统有登录日志，发现非本楼人员之类的。（锁IP地址不是一下就找到你了么。。那年头校园里都是独立IP）</p>
<p><br/></p>
<img src="/2016-10-18-again-the-social-network/4.jpg" class="">
<blockquote>
<p><strong>Adams</strong> has no security but limits the number of
results to 20 a page. All I have to is break up the same script I used
on Lowell and it's set.</p>
</blockquote>
<p>每页20个结果，修改一下Lowell楼用的perl脚本。</p>
<p><br/></p>
<img src="/2016-10-18-again-the-social-network/5.jpg" class="">
<blockquote>
<p><strong>Quincy</strong> has no online Facebook, what a sham. Nothing
I can do about that.</p>
</blockquote>
<p>人家不放照片到网站上，小扎也没办法了。</p>
<p><br/></p>
<img src="/2016-10-18-again-the-social-network/6.jpg" class="">
<blockquote>
<p><strong>Dunster</strong> is intense. Not only is there no public
directory but there's no directory at all. You have to do searches and
every search returns more than 20 matches nothing is returned. Once you
do get results they don't link directly to the images, they link to a
PHP that redirects or something. Weird. This maybe difficult, I'll come
back later.</p>
</blockquote>
<p>没有列出的条目，搜索结果超过20还会隐藏，查到的结果，点过去不是图片也不是直连个人网页，而是一个重定向跳转，跳转目的地还各不相同。
这个编程筛选复杂许多，小扎暂时放弃。估计真要搞的话，当晚他是搞不完了。</p>
<p><br/></p>
<img src="/2016-10-18-again-the-social-network/7.jpg" class="">
<blockquote>
<p><strong>Leverett</strong> is a little better. I'ts still make you
search but you can do an empty search and gets links to pages with every
student's picture. It's slightly obnoxious that they let you view one
picture at a time. And there's no way I'm going to go 500 hundred pages
to download pics one at a time. So its definitely necessary to break out
Emacs and modify that Perl script.</p>
</blockquote>
<p>又是用空搜索，得到链接去个人主页，页面上有照片。看来这些照片的地址是没规律的。这里中文字幕组给“break
out Emacs and modify that Perl
script”翻译成关掉Emacs来修改perl脚本，上次看的时候就楞了一下，不知道是不是反过来翻译成“祭出神器”Emacs来修改perl脚本更合适。。。不过我是不参与Emacs和Vim之战的，我是IDE党。
搜索-&gt;进网页-&gt;获取图片，标准的爬虫脚本了，主要是根据html内容写正则匹配，获取元素，代码量也不会太多。</p>
<p><br/></p>
<p>Done.</p>
<img src="/2016-10-18-again-the-social-network/8.jpg" class="">
<p>电影中小扎这晚的抓图工作就这么多了。</p>
<p>侧面再次显示了美国高中生活的丰富多彩，国内高中能接触编程的也只有OI竞赛的神牛们了，然而能上个满意学校的基本都是金字塔尖的。写个小爬虫脚本多少需要对html、
php、一个脚本语言、apache这些有一定的了解，十多年前的小扎做这些就是玩儿的，十多年后工具发达数倍的时代，我们光靠大一一年玩到这个程度的那真是对编程够钟爱。</p>
]]></content>
  </entry>
  <entry>
    <title>CSU-OJ补完计划（一，10xx）</title>
    <url>/2017-02-09-csu-oj-complete-plan-10xx/</url>
    <content><![CDATA[<blockquote>
<p>20170209</p>
</blockquote>
<p>虽然好几年来一直是CSU-OJ的super
admin，但是退役后就没怎么管OJ了，都是每年的在役队员在加题。不同人对学校OJ的理解不同，有的当对外交流的窗口，有的只是当一个内部的训练工具，导致部分题目残缺、题号不连续等许多问题。多年不做题也怕手生了挺可惜的，打算业余时间偶尔刷几题，把OJ题目重新整理下，调调字体，补补图之类的，顺便做个完整题解。不知道能不能坚持下去，先挖坑吧。</p>
<span id="more"></span>
<blockquote>
<p>20170222</p>
</blockquote>
<p>OJ丑得看不下去了……重做了一个，近期上线吧。</p>
<hr />
<blockquote>
<p>20170307</p>
</blockquote>
<p>OJ、主页、报名系统三个网站合并到一起做了个新网站，已上线。 <a
href="/2017-03-07-csunewoj/">日志留念</a> <a
href="http://acm.csu.edu.cn/">CSU-ACM Home Page</a></p>
<hr />
<h3 id="机器人训练"><a
href="http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1015">1015:
机器人训练</a></h3>
<blockquote>
<p>20170316</p>
</blockquote>
<p>把每两个点之间的移动，都分解成一横一竖两个移动，两个移动相互独立，只需要关心移动前后面对的方向，这样思路会清晰许多。</p>
<p>每一步从一个箭头末端去下一个箭头始端，无非都是走一个“L”，只有一个决策不同，先横着还是先竖着，受前后两个箭头方向的影响会有不同的转弯次数。但是不必分类讨论，都走一走试试就好了，只需要调一下分解后的横竖移动的顺序，纯粹模拟即可，稍注意下点重合的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TURN_NUM[<span class="number">4</span>][<span class="number">4</span>] =</span><br><span class="line">        &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//方向压缩到 0:x正，1:x负，2:y正，3:y负</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Dir</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> is_y)</span></span>&#123;<span class="keyword">return</span> (e &gt; s) + (is_y &lt;&lt; <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ArrowDir</span><span class="params">(<span class="type">int</span> * a)</span></span>&#123;<span class="keyword">return</span> a[<span class="number">0</span>] != a[<span class="number">2</span>] ? <span class="built_in">Dir</span>(a[<span class="number">0</span>], a[<span class="number">2</span>], <span class="number">0</span>) : <span class="built_in">Dir</span>(a[<span class="number">1</span>], a[<span class="number">3</span>], <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OneStep</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> is_y, <span class="type">int</span> &amp;turn, <span class="type">int</span> &amp;dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> nex_dir = <span class="built_in">Dir</span>(s, e, is_y);</span><br><span class="line">    turn += TURN_NUM[dir][nex_dir];</span><br><span class="line">    dir = nex_dir;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TryOneDir</span><span class="params">(<span class="type">int</span> is_y, <span class="type">int</span> dir, <span class="type">int</span> *now, <span class="type">int</span> *nex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">OneStep</span>(now[is_y + <span class="number">2</span> ], nex[is_y], is_y, turn, dir);</span><br><span class="line">    <span class="built_in">OneStep</span>(now[!is_y + <span class="number">2</span> ], nex[!is_y], !is_y, turn, dir);</span><br><span class="line">    <span class="built_in">OneStep</span>(nex[<span class="number">0</span>], nex[<span class="number">2</span>], <span class="number">0</span>, turn, dir);</span><br><span class="line">    <span class="built_in">OneStep</span>(nex[<span class="number">1</span>], nex[<span class="number">3</span>], <span class="number">1</span>, turn, dir);</span><br><span class="line">    <span class="keyword">return</span> turn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n, aw[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;aw[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="type">int</span> now_dir = <span class="built_in">ArrowDir</span>(aw[<span class="number">0</span>]), totalTurn = <span class="number">0</span>, totalDis = <span class="built_in">abs</span>(aw[<span class="number">0</span>][<span class="number">0</span>] - aw[<span class="number">0</span>][<span class="number">2</span>]) + <span class="built_in">abs</span>(aw[<span class="number">0</span>][<span class="number">1</span>] - aw[<span class="number">0</span>][<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; -- n; i ^= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;aw[!i][j]);</span><br><span class="line">            totalTurn += std::<span class="built_in">min</span>(<span class="built_in">TryOneDir</span>(<span class="number">0</span>, now_dir, aw[i], aw[!i]),</span><br><span class="line">                                  <span class="built_in">TryOneDir</span>(<span class="number">1</span>, now_dir, aw[i], aw[!i]));</span><br><span class="line">            now_dir = <span class="built_in">ArrowDir</span>(aw[!i]);</span><br><span class="line">            totalDis += <span class="built_in">abs</span>(aw[i][<span class="number">2</span>] - aw[!i][<span class="number">0</span>]) + <span class="built_in">abs</span>(aw[i][<span class="number">3</span>] - aw[!i][<span class="number">1</span>]) +</span><br><span class="line">                    <span class="built_in">abs</span>(aw[!i][<span class="number">0</span>] - aw[!i][<span class="number">2</span>]) + <span class="built_in">abs</span>(aw[!i][<span class="number">1</span>] - aw[!i][<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, totalDis, totalTurn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="西湖三人行"><a
href="http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1014">1014:
西湖三人行</a></h3>
<blockquote>
<p>20170316</p>
</blockquote>
<p>先想到的思路是直接DP，<code>dp[cost][status][site]</code>，当前花费、状态（行走、在哪个公交上、在出租上且走了几公里，超过3公里按3公里算）、当前站点，优化的是走的时间。
这个思路的问题是，虽然dp的状态空间是
<code>101*204*100</code>，但是每次更新状态还有<code>100</code>数量级的边遍历，这样就行不通了。然而这个方法却水过去了。</p>
<p>更好的方法状态空间是<code>dp[cost][site]</code>，省去<code>status</code>这一维，需要预处理建图。根据三种交通方式，统一地建成一个点到点的距离+花费的无差别图。</p>
<p>首先是bus，因为公交不会抄近道，如果路线是3-&gt;4-&gt;5，它不会因为3-&gt;6-&gt;5更近就绕道，对bus线路上所有能一次性到达的两点都建一条边。</p>
<p>bus之后，就可以Floyd了，因为走路和出租车都是选最短路走的。Floyd之后对任意两点按直达建边。</p>
<p>这样建图在DP时候不需要考虑“当前状态”，比如出租车，都
<strong>只考虑起点发车</strong> ，如果不是起点发车，
<strong>自然有其他的点建了直达边</strong> 。</p>
<p>如此得到了一个有重边的，每条边有距离、花费两个边权的链式图。接下来就可以DP了。最短路做DP也可以，不过多此一举，干净的DP就好。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">30011</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXNUM = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> L, N, M, S, T, B;</span><br><span class="line"><span class="type">int</span> hz[maxn][maxn];</span><br><span class="line"><span class="type">int</span> bus[maxn];</span><br><span class="line"><span class="type">int</span> fst[maxn], nex[maxm], v[maxm], w[maxm], cost[maxm];</span><br><span class="line"><span class="type">int</span> ntp;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">105</span>][maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> len, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nex[ntp] = fst[s];</span><br><span class="line">    v[ntp] = t;</span><br><span class="line">    w[ntp] = len;</span><br><span class="line">    cost[ntp] = c;</span><br><span class="line">    fst[s] = ntp ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= N; k ++)</span><br><span class="line">                hz[i][j] = std::<span class="built_in">min</span>(hz[i][k] + hz[k][j], hz[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DPS</span><span class="params">(<span class="type">int</span> costNow, <span class="type">int</span> siteNow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(costNow &gt; L) <span class="keyword">return</span> MAXNUM;</span><br><span class="line">    <span class="type">int</span> &amp;ans = dp[costNow][siteNow];</span><br><span class="line">    <span class="keyword">if</span>(ans != <span class="number">-1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(siteNow == T) <span class="keyword">return</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans = MAXNUM;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = fst[siteNow]; i != <span class="number">-1</span>; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, <span class="built_in">DPS</span>(costNow + cost[i], v[i]) + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, s, e, len, ans;</span><br><span class="line">    <span class="type">int</span> K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(fst, <span class="number">-1</span>, <span class="built_in">sizeof</span>(fst));</span><br><span class="line">        <span class="built_in">memset</span>(hz, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(hz));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        ntp = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>, &amp;L, &amp;N, &amp;M, &amp;S, &amp;T, &amp;B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;e, &amp;len);</span><br><span class="line">            hz[s][e] = hz[e][s] = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= B; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;K);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;bus[j]);</span><br><span class="line">                <span class="type">int</span> last = j, tmpLen = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">0</span>; last = k --)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmpLen += hz[bus[last]][bus[k]];</span><br><span class="line">                    <span class="built_in">AddEdge</span>(bus[k], bus[j], tmpLen * <span class="number">250</span>, <span class="number">6</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Floyd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hz[i][j] != MAXNUM)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">AddEdge</span>(i, j, hz[i][j] * <span class="number">1000</span>, hz[i][j] * <span class="number">3</span>);</span><br><span class="line">                    <span class="built_in">AddEdge</span>(i, j, hz[i][j] * <span class="number">125</span>, <span class="number">10</span> + (hz[i][j] &gt; <span class="number">3</span> ? (hz[i][j] - <span class="number">3</span>) * <span class="number">2</span> : <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ans = <span class="built_in">DPS</span>(<span class="number">0</span>, S);</span><br><span class="line">        <span class="keyword">if</span>(ans == MAXNUM)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="狐狸与小狗"><a
href="http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1013">1013:
狐狸与小狗</a></h3>
<blockquote>
<p>20170314</p>
</blockquote>
<p>一共32个位置，至多<code>C(32, 5) * 5 * 2 = 2013760</code>种状态，基本思路是状态DP，不难想，却难A。当年出题人或许是为了卡map，设置了1秒，我也不乱改时限了，不过还是用<code>unordered_map</code>先水过了一下。
要做到正常时限还是要自己写Hash，Hash写对了，状态随便压缩一下做记忆化搜索基本就能过了。不过还可以有一些“看起来”挺酷的“优化”。</p>
<p>把所有能放的格子编号，就是<code>0~31</code>，表达棋子位置就有三种模式：坐标<code>(x, y)</code>，编号<code>(0~31)</code>，位标记<code>(0, 2, 4, 8 ... 2147483648)</code>，32个位置用位标记需要<code>unsigned int</code>。
棋子走动，其实就是按位左移或右移<code>3~5</code>个位，棋子能不能落下，就是单个棋子的新位置与所有棋子的旧位置按位与一下来判断。一些细节的分类讨论也可以用位运算减少代码量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> LEFT_1357  = <span class="number">0x01010101</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> RIGHT_2468 = <span class="number">0x80808080</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> LINE_1357  = <span class="number">0x0F0F0F0F</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> LINE_2468  = <span class="number">0xF0F0F0F0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> TOP_LINE   = <span class="number">0x0000000F</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2013761</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> hashSize = <span class="number">1000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> pace[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> dogs, fox;</span><br><span class="line">    <span class="type">int</span> status, m, next;</span><br><span class="line">    <span class="built_in">HashNode</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">HashNode</span>(<span class="type">unsigned</span> d, <span class="type">unsigned</span> f, <span class="type">int</span> m_, <span class="type">int</span> s, <span class="type">int</span> n)</span><br><span class="line">    :<span class="built_in">dogs</span>(d), <span class="built_in">fox</span>(f), <span class="built_in">m</span>(m_), <span class="built_in">status</span>(s), <span class="built_in">next</span>(n)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Vis</span><span class="params">(<span class="type">unsigned</span> dogs_, <span class="type">unsigned</span> fox_, <span class="type">int</span> m_)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dogs == dogs_ &amp;&amp; fox == fox_ &amp;&amp; m == m_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">HashNode hashBuf[maxn];</span><br><span class="line"><span class="type">int</span> hashPointer[hashSize];</span><br><span class="line"><span class="type">int</span> htp = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetHash</span><span class="params">(<span class="type">unsigned</span> dogs, <span class="type">unsigned</span> fox, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hashNum = ((dogs | fox) % hashSize &lt;&lt; <span class="number">1</span> | m) % hashSize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = hashPointer[hashNum]; i != <span class="number">-1</span>; i = hashBuf[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashBuf[i].<span class="built_in">Vis</span>(dogs, fox, m))</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    hashBuf[htp] = <span class="built_in">HashNode</span>(dogs, fox, m, <span class="number">-1</span>, hashPointer[hashNum]);</span><br><span class="line">    <span class="keyword">return</span> hashPointer[hashNum] = htp ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DPS</span><span class="params">(<span class="type">unsigned</span> dogs, <span class="type">unsigned</span> fox, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//status == 1表示Dog win， 0表示Fox win，2表示已入栈</span></span><br><span class="line">    <span class="type">int</span> &amp;status = hashBuf[<span class="built_in">GetHash</span>(dogs, fox, m)].status;</span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    status = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> moveFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">unsigned</span> tmpdogs = dogs;</span><br><span class="line">        <span class="keyword">while</span>(tmpdogs &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">unsigned</span> dog = tmpdogs &amp; -tmpdogs;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> mov = <span class="number">0</span>; mov &lt; <span class="number">2</span>; mov ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dog &amp; RIGHT_2468 &amp;&amp; mov == <span class="number">1</span> || dog &amp; LEFT_1357 &amp;&amp; mov == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">unsigned</span> nex = dog &lt;&lt; pace[mov] + !(dog &amp; LINE_1357);</span><br><span class="line">                <span class="keyword">if</span> (nex == <span class="number">0</span> || dogs &amp; nex || fox &amp; nex)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                moveFlag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">DPS</span>(dogs ^ dog ^ nex, fox, !m) == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> status = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpdogs &amp;= (tmpdogs - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!moveFlag)</span><br><span class="line">            <span class="keyword">return</span> status = <span class="built_in">DPS</span>(dogs, fox, !m);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> status = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fox &amp; TOP_LINE)</span><br><span class="line">            <span class="keyword">return</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mov = <span class="number">3</span>; mov &gt;= <span class="number">0</span>; mov --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fox &amp; RIGHT_2468 &amp;&amp; mov &amp; <span class="number">1</span> || fox &amp; LEFT_1357 &amp;&amp; ~mov &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">unsigned</span> nex;</span><br><span class="line">            <span class="keyword">if</span>(mov &lt; <span class="number">2</span>) nex = fox &lt;&lt; pace[mov] + !(fox &amp; LINE_1357);</span><br><span class="line">            <span class="keyword">else</span> nex = fox &gt;&gt; pace[mov] + !(fox &amp; LINE_2468);</span><br><span class="line">            <span class="keyword">if</span> (nex == <span class="number">0</span> || dogs &amp; nex)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">DPS</span>(dogs, nex, !m) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> status = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, m, x, y;</span><br><span class="line">    <span class="type">unsigned</span> dogs, fox;</span><br><span class="line">    <span class="built_in">memset</span>(hashPointer, <span class="number">-1</span>, <span class="built_in">sizeof</span>(hashPointer));</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        fox = <span class="number">1u</span> &lt;&lt; ((x - <span class="number">1</span>) &lt;&lt; <span class="number">2</span> | (y - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        dogs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            dogs |= <span class="number">1u</span> &lt;&lt; ((x - <span class="number">1</span>) &lt;&lt; <span class="number">2</span> | (y - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">DPS</span>(dogs, fox, m) ? <span class="string">&quot;Dog win&quot;</span> : <span class="string">&quot;Fox win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="prestige"><a
href="http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1012">1012:
Prestige</a></h3>
<blockquote>
<p>20170313</p>
</blockquote>
<p>首先理解题意是两个人都要争取自己拿到的多，在这个前提下让对方也拿到的多。优先拿对自己价值高的，等价情况下优先拿走对对方价值低的（把等价情况下对对方价值高的留给对方），这个思路是对的，也即Han也会用这个思路拿，但需要一个全局策略，即求一个全局的尽可能按上面思路拿的策略。</p>
<p>题目数据规模不允许进行全局状态的DP（比如位运算什么的），那么只能用一个调整的策略。</p>
<p>Li的策略比较直白，所以先按Li取的优先级排序，然后游戏开始。</p>
<p>考虑第<code>i</code>个物品，轮到Han，则假设直接取，但做记录，轮到Li，则看物品<code>i</code>对于已假设Han取了的物品集合而言，是否比这个集合中对Han价值最差的（对Han价值尽可能低，对Li价值尽可能高）物品<code>x</code>，要价值更好，如果更好，那么“时光倒流”，当Han面对物品<code>x</code>的时候，取<code>i</code>，因为已经排序，所以“当时”如果取了<code>i</code>，Li肯定会取<code>x</code>。</p>
<p>不断这样进行下去，这个假设的集合最终就是Han的策略会取的物品集合。</p>
<p>需要Log(n)来找到这个<code>x</code>，用一个优先级队列。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123; ;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pii &amp;a, <span class="type">const</span> pii &amp;b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first != b.first ? a.first &gt; b.first : a.second &lt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n, l, h;</span><br><span class="line">    <span class="type">char</span> start[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; )</span><br><span class="line">    &#123;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, cmp&gt; H;</span><br><span class="line">        <span class="type">int</span> ansl = <span class="number">0</span>, ansh = <span class="number">0</span>;</span><br><span class="line">        vector&lt;pii&gt; L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, start);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;h);</span><br><span class="line">            L.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(l, h));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>(), <span class="built_in">cmp</span>());</span><br><span class="line">        <span class="keyword">if</span>(start[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            ansl += L[<span class="number">0</span>].first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> isH = <span class="number">1</span>, i = start[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span>; i &lt; L.<span class="built_in">size</span>(); isH ^= <span class="number">1</span>, i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            pii &amp;now = L[i];</span><br><span class="line">            <span class="keyword">if</span>(isH)</span><br><span class="line">            &#123;</span><br><span class="line">                ansh += now.second;</span><br><span class="line">                H.<span class="built_in">push</span>(<span class="built_in">pii</span>(now.second, now.first));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">cmp</span>()(<span class="built_in">pii</span>(now.second, now.first), H.<span class="built_in">top</span>()))</span><br><span class="line">                    ansl += now.first;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ansl += H.<span class="built_in">top</span>().second;</span><br><span class="line">                    ansh -= H.<span class="built_in">top</span>().first;</span><br><span class="line">                    ansh += now.second;</span><br><span class="line">                    H.<span class="built_in">pop</span>();</span><br><span class="line">                    H.<span class="built_in">push</span>(<span class="built_in">pii</span>(now.second, now.first));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ansl, ansh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="counting-pixels"><a
href="http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1011">1011:
Counting Pixels</a></h3>
<blockquote>
<p>20170313</p>
</blockquote>
<p>只与半径有关，考虑右上的四分之一圆最后乘 4
即可。半径是整数，把这四分之一圆圈住的像素看作一列一列，圆与每列左边界的交点向上取整就是这一列的像素数，加起来。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x, y, r;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;r) &amp;&amp; (x || y || r))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; r; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += (<span class="type">long</span> <span class="type">long</span>)(<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(r * r - i * i)) + <span class="number">1e-8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans * <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="water-drinking"><a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1010">1010: Water
Drinking</a></h3>
<blockquote>
<p>20170222</p>
</blockquote>
<p>很稀疏的图，记录父子节点关系最后枚举迭代一下就好。不过其实是个食物链并查集模型，比基本并查集多维护一个与父节点的距离。
已经忘了食物链怎么写了，于是复习一下。。。其实还是瞎写的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> p[<span class="number">100011</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">100011</span>];</span><br><span class="line"><span class="type">bool</span> s[<span class="number">100011</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fa</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == p[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="built_in">fa</span>(p[x]);</span><br><span class="line">    dis[x] += dis[p[x]];</span><br><span class="line">    p[x] = <span class="built_in">fa</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">            p[i] = i, dis[i] = <span class="number">0</span>, s[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            s[a] = <span class="literal">true</span>;</span><br><span class="line">            p[b] = a;</span><br><span class="line">            dis[b] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">fa</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fa</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (!s[i] &amp;&amp; (ans == <span class="number">-1</span> || dis[i] &lt; dis[ans]))</span><br><span class="line">                ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抛硬币"><a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1009">1009:
抛硬币</a></h3>
<blockquote>
<p>20170222</p>
</blockquote>
<p>对每列排序，大的跟大的乘，小的很小的乘，最后加起来总期望最高。 证明：
设<code>a&gt;c, b&gt;d</code>,
<code>(ab+cd) - (ad + bc) = (a - c)*(b - d) &gt; 0</code>，即假设已排好序，这时调换任意两个数的位置，得到的结果会小于先前。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">double</span> p[<span class="number">11</span>][<span class="number">111</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[j][i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">            std::<span class="built_in">sort</span>(p[j], p[j] + n);</span><br><span class="line">        <span class="type">double</span> ret = <span class="number">0</span>, tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">                tmp *= p[j][i];</span><br><span class="line">            ret += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="horcrux"><a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1008">1008:
Horcrux</a></h3>
<blockquote>
<p>20170222</p>
</blockquote>
<p>用栈的结构，每段连续相同颜色的第一个的位置为栈元素，每次变色，相当于最后一段连续颜色的起点变成了当前起点的上一个，也即出栈操作。过程中控制好颜色标记。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, horcrux, nowcolor;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        nowcolor = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;horcrux);</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>() || horcrux != nowcolor &amp;&amp; (i &amp; <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(i);</span><br><span class="line">                nowcolor = horcrux;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(horcrux != nowcolor)</span><br><span class="line">            &#123;</span><br><span class="line">                nowcolor = horcrux;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">size</span>() &gt; <span class="number">1</span>) s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, right = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans += (!nowcolor) * (right - s.<span class="built_in">top</span>());</span><br><span class="line">            nowcolor = !nowcolor;</span><br><span class="line">            right = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="矩形着色"><a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1007">1007:
矩形着色</a></h3>
<blockquote>
<p>20170222</p>
</blockquote>
<p>把情况想清楚就好。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> px, py, ax, ay, bx, by;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>, &amp;px, &amp;py, &amp;ax, &amp;ay, &amp;bx, &amp;by);</span><br><span class="line">        <span class="keyword">if</span>(px &lt; ax || px &gt; bx || py &lt; ay || py &gt; by)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Outside\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(px == ax || px == bx || py == ay || py == by)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;On\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Inside\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="saw"><a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1006">1006:
SAW</a></h3>
<blockquote>
<p>20170222</p>
</blockquote>
<p>当年校队的大大们给新人开的一个小玩笑。当时还没看过《电锯惊魂》，都没理解标题的SAW是什么意思。
题目就是随机一个大写的26个英文字母之一，随机也好固定一个字母押宝也好，过的概率是一样的。</p>
<p>但是前些天看到有个代码100%
AC，还以为spj坏了，看了一下spj的代码，原来是当年随机字母就用的srand(time(0))做种子，提交的代码也这样，而提交代码与spj代码运行时间很近，两个种子就一样了。</p>
<p>于是我邪恶地把spj的随机过程搞得更乱了 😂。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="binary-search-tree-analog"><a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1005">1005:
Binary Search Tree analog</a></h3>
<blockquote>
<p>20170222</p>
</blockquote>
<p>二叉搜索树基础 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;left = right = num = <span class="number">-1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node nd[<span class="number">1111</span>];</span><br><span class="line"><span class="type">int</span> ltp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nd[now].num == <span class="number">-1</span>)</span><br><span class="line">        nd[now].num = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nd[now].num &gt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nd[now].left == <span class="number">-1</span>)</span><br><span class="line">            nd[ltp] = <span class="built_in">Node</span>(), nd[now].left = ltp ++;</span><br><span class="line">        <span class="built_in">Insert</span>(x, nd[now].left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nd[now].right == <span class="number">-1</span>)</span><br><span class="line">            nd[ltp] = <span class="built_in">Node</span>(), nd[now].right = ltp ++;</span><br><span class="line">        <span class="built_in">Insert</span>(x, nd[now].right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> printed;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintTree</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(order == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(printed ? <span class="string">&quot; %d&quot;</span> : <span class="string">&quot;%d&quot;</span>, nd[now].num), printed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(nd[now].left != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">PrintTree</span>(nd[now].left, order);</span><br><span class="line">    <span class="keyword">if</span>(order == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(printed ? <span class="string">&quot; %d&quot;</span> : <span class="string">&quot;%d&quot;</span>, nd[now].num), printed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(nd[now].right != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">PrintTree</span>(nd[now].right, order);</span><br><span class="line">    <span class="keyword">if</span>(order == <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(printed ? <span class="string">&quot; %d&quot;</span> : <span class="string">&quot;%d&quot;</span>, nd[now].num), printed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        ltp = <span class="number">0</span>;</span><br><span class="line">        nd[ltp ++] = <span class="built_in">Node</span>();</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span>(n --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="built_in">Insert</span>(x, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printed = <span class="literal">false</span>; <span class="built_in">PrintTree</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        printed = <span class="literal">false</span>; <span class="built_in">PrintTree</span>(<span class="number">0</span>, <span class="number">2</span>); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        printed = <span class="literal">false</span>; <span class="built_in">PrintTree</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="xi-and-bo"><a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1004">1004: Xi
and Bo</a></h3>
<blockquote>
<p>20170222</p>
</blockquote>
<p>用并查集合并相连的站点。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> p[<span class="number">111</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fa</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == p[x] ? x : (p[x] = <span class="built_in">fa</span>(p[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n, m, start, end;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;start, &amp;end);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i ++)</span><br><span class="line">            p[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">            <span class="type">int</span> first = <span class="number">-1</span>, connected;</span><br><span class="line">            <span class="keyword">while</span>(m --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;connected);</span><br><span class="line">                <span class="keyword">if</span>(first == <span class="number">-1</span>)</span><br><span class="line">                    first = connected;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p[<span class="built_in">fa</span>(connected)] = <span class="built_in">fa</span>(first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">fa</span>(start) == <span class="built_in">fa</span>(end) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### <a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1003">1003: UC
Browser</a> &gt; 20170222</p>
<p>按题意做。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">111</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> score = <span class="number">0</span>, tmpscore = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, buf);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] == <span class="string">&#x27;1&#x27;</span> ? tmpscore ++ : (tmpscore = <span class="number">0</span>);</span><br><span class="line">            score += <span class="number">10</span> * ((tmpscore - <span class="number">1</span>) % <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> level = (score + <span class="number">50</span>) / <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, level &gt; <span class="number">8</span> ? <span class="number">8</span> : level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ab-iii"><a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1002">1002: A+B
(III)</a></h3>
<blockquote>
<p>20170209</p>
</blockquote>
<p>int64基础知识。CSU-OJ是Linux编译器，用long long <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b) &amp;&amp; a &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### <a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1001">1001: A+B
(II)</a> &gt; 20170209</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;a, &amp;b) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ab-i"><a
href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1000">1000: A+B
(I)</a></h3>
<blockquote>
<p>20170209</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CSU-OJ</tag>
        <tag>CSUOJ-Complete-plan</tag>
      </tags>
  </entry>
  <entry>
    <title>关于机器学习中的范数的杂记</title>
    <url>/2017-03-29-about-norm/</url>
    <content><![CDATA[<p>一般来说，监督学习可以看作最小化一个目标函数，即Loss
Function加一个约束项： <span class="math display">\[
w^{*} = \mathop{\arg\min}_{w}\sum_{i}L(y_{i}, f(x_{i}; w)) +
\lambda\Omega(w)
\]</span></p>
<p>约束项 <span class="math inline">\(\Omega(w)\)</span>
通常是模型参数向量的范数的规则化项，比如稀疏表示基础知识中的零范数，用来约束字典权值的稀疏性。</p>
<h3 id="l0范数">L0范数</h3>
<p>L0范数指向量中非0的元素个数，
知乎上一个解释很有让人增加对0范数的感性认知的效果<br />
&gt;几何意义不考虑，单从分析角度。总而言之都是P范数，零范数即是当<code>p</code>趋于零，可以证明这时候的极限
<span
class="math inline">\((x_{1}^{p}+x_{2}^{p}+...+x_{n}^{p})^{\frac{1}{p}}\)</span>
恰好是向量 <span
class="math inline">\(x=(x_{1},x_{2},...,x_{n})^{T}\)</span>
非零元素的个数。而无穷范数则是当<code>p</code>趋于无穷的时候的范数。关于这些极限的证明，数学分析的开篇就介绍了，我想这也是为什么当初学习数学分析的时候为什么老是有各种奇形怪状的极限要证明存在性的原因之一。但严格来说，<strong>零范数并不满足数乘率</strong>(
<span class="math inline">\(|\alpha x|\neq |\alpha||x|\)</span>
)。之所以最近被多次提到，也是因为压缩感知的火热。<br />
<a
href="https://www.zhihu.com/question/20473040/answer/121760029">https://www.zhihu.com/question/20473040/answer/121760029</a></p>
<span id="more"></span>
<h3 id="l1范数">L1范数</h3>
<p>L1范数就是向量中各个元素绝对值之和。学术界普遍用L1代替L0做稀疏约束，主要因为在一定条件下L1与L0求解目标等价，但L1是L0的最优凸近似，易于优化求解。</p>
<blockquote>
<p>L1是假设参数服从双指数分布，利于保证权值向量的稀疏性</p>
</blockquote>
<h3 id="l2范数">L2范数</h3>
<blockquote>
<p>L2是假设参数服从高斯分布，利于防止过拟合。</p>
</blockquote>
<p>有前面“<code>P</code>范数”的解释，L2范数就很容易知道是向量各元素平方和的平方根。<br />
L2范数常用来抑制过拟合。机器学习的目标是增大各分量权重<code>w</code>的差异，但产生过拟合时，往往是权重的差异过大，过度拟合了有限的训练数据，而缺乏泛化能力。平方和的平方根求最小值，自然会使所有的数都尽可能小，对训练的过程起到一个反作用。作为一个约束项，也称为惩罚项，即把权重的差异限制到一个范围，类比0范数的作用是让权重的非零项尽可能少，它们都起到<strong>约束</strong>的作用。</p>
<h3 id="核范数nuclear-norm">核范数(Nuclear Norm)</h3>
<p>核范数是矩阵奇异值的和，用来约束矩阵的低秩。对于有稀疏性质的数据（如自然图像），这样的矩阵是低秩的，会包含大量冗余信息，可以利用冗余信息恢复数据（如去噪），可以提取特征（如分类）。</p>
<p>秩（rank）是矩阵非0奇异值的个数，核范数是奇异值的和，把定义放在一起，有种很眼熟的感觉——这就很像用L1范数实现L0范数约束啊。数学角度说，rank是非凸的，或者说又是个NP问题，核范数则是凸的，核范数是rank的凸近似，用核范数最小化来近似实现低秩约束，原因还是好算。</p>
<h3 id="弗罗贝尼乌斯范数">弗罗贝尼乌斯范数</h3>
<p>在矩阵中，对于<code>p=2</code>，称为Frobenius Norm(F-Norm)。 <span
class="math display">\[
\|A\|_{F}=\sqrt{\sum_{i=1}^{m}\sum_{j=1}^{n}|a_{ij}|^{2}}=\sqrt{trace{A^{*}A}}=\sqrt{\sum_{i=1}^{\min(m,n)}\sigma_{i}^{2}}
\]</span> <span class="math inline">\(A^{*}\)</span> 表示 <span
class="math inline">\(A\)</span> 的共轭转置， <span
class="math inline">\(\sigma_{i}\)</span> 是 <span
class="math inline">\(A\)</span> 的奇异值。</p>
<p>参考：</p>
<ol type="1">
<li><a
href="http://blog.csdn.net/zouxy09/article/details/24971995/">机器学习中的范数规则化之（一）L0、L1与L2范数</a><br />
</li>
<li><a
href="http://blog.csdn.net/zouxy09/article/details/24972869">机器学习中的范数规则化之（二）核范数与规则项参数选择</a></li>
<li><a href="https://www.zhihu.com/question/20473040">0 范数、1 范数、2
范数有什么区别？</a></li>
<li><a
href="https://www.zhihu.com/question/26471536/answer/85915842">为什么核范数能凸近似矩阵的秩？为什么核范数是凸的？</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>CSU-ACM新官网上线</title>
    <url>/2017-03-07-csunewoj/</url>
    <content><![CDATA[<p>花了一个多星期给CSUACM做了个新网站。</p>
<p><a href="http://acm.csu.edu.cn">acm.csu.edu.cn</a></p>
<p>本来只是想在学校OJ刷刷题，然而觉得各种丑，之前也一直因为代码不是自己的，想调整内容、增减功能总是不那么得心应手，这次也算心血来潮做个新的UI，做着做着就干脆把官网和报名网站也整合了。</p>
<p>这几天太累了也不想打太多字了，做篇日志留念。也许什么时候有空了再写个新的Judge端吧。</p>
<p>多年过去了，发现自己对中南ACM队伍还是深爱着。。。</p>
<span id="more"></span>
<h4 id="home-page">Home Page</h4>
<img src="/2017-03-07-csunewoj/home.png" class="" title="home">
<h4 id="problemset">Problemset</h4>
<img src="/2017-03-07-csunewoj/problem.png" class="" title="problem">
<h4 id="status">Status</h4>
<img src="/2017-03-07-csunewoj/status.png" class="" title="status">
<h4 id="contest">Contest</h4>
<img src="/2017-03-07-csunewoj/contest.png" class="" title="contest">
<h4 id="contest-registration">Contest Registration</h4>
<img src="/2017-03-07-csunewoj/registration.png" class="" title="registration">
<h4 id="admin-panel">Admin Panel</h4>
<img src="/2017-03-07-csunewoj/admin.png" class="" title="admin">
]]></content>
  </entry>
  <entry>
    <title>从稀疏表示到K-SVD，再到图像去噪</title>
    <url>/2017-03-23-ksvd-and-denoising/</url>
    <content><![CDATA[<p>初学入门，将来有了更深的理解回来纠正错误。</p>
<p>MathJax需要加载，公式如未显示请稍候。</p>
<h3 id="稀疏表示">稀疏表示</h3>
<h4 id="稀疏性的理解">稀疏性的理解</h4>
<p>最初稀疏性产生于信号处理领域，自然界信号低频居多，高频主要是噪声，图像处理中的频率域滤波是个典型例子。</p>
<p>假设有一个干净没有噪声的图像，经过传输，收到的是一个受到干扰有了噪声的图像，而噪声主要是高频分量，对图片做二维傅里叶变换，对低频的波形保持，高频的一刀切，还原回来的图像就平滑了许多，大部分高频噪声就去除了。这个假设的场景就是个“信号恢复”的过程。如果把所有的频率的波都看作一个个相互正交的向量，恢复数据就是给这些向量找到一组系数，它们一乘、一合并，得到原始信号，频率从大到小是有无穷多个的，而由于自然界信号的“稀疏性”，对于图像而言，就是指有用的频率主要是低频，那么对应高频的系数基本都是<code>0</code>了，低频部分也不见得全是非<code>0</code>，这一系列系数<code>0</code>很多，非<code>0</code>很少，就很“稀疏”。</p>
<span id="more"></span>
<h4 id="稀疏表示的概念">稀疏表示的概念</h4>
<p>稀疏表示的目的就是在给定的超完备字典中用尽可能少的原子来表示信号。</p>
<p>意义在于降维，可以是压缩，可以用于机器学习特征提取，还有很多我也不知道的事情。。。</p>
<p>原子：信号的基本构成成分，比如一个长为N的列向量。</p>
<p>字典：许多原子的排序集合，一个<code>N*T</code>的矩阵，如果<code>T&gt;N</code>，则为过完备或冗余字典。</p>
<blockquote>
<p>咦，线性代数又出现了，假设列向量两两线性无关，<code>N*N</code>的矩阵的秩就是N了，再增加向量也不会增加额外的信息。</p>
</blockquote>
<h4 id="稀疏表示的一个场景">稀疏表示的一个场景</h4>
<p>假设现在有了一个<code>N*T</code>的过完备字典
<code>D</code>（比如前面所述图像傅里叶变换的所有频率的波），一个要表示的对象<code>y</code>（要还原的图像），求一套系数<code>x</code>，使得<code>y=Dx</code>，这里<code>y</code>是一个已知的长为<code>N</code>的列向量，<code>x</code>是一个未知的长为<code>T</code>的列向量，解方程。</p>
<p>这是一个<code>T</code>个未知数，<code>N</code>个方程的方程组，<code>T&gt;N</code>，所以是有无穷多解的，线性代数中这样的方程很熟悉了。
<span class="math display">\[
\begin{bmatrix}
1\\
2\\
3\\
4\\
5
\end{bmatrix} = \begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8\\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0
\end{bmatrix}\times
\begin{bmatrix}
x1\\
x2\\
x3\\
x4\\
x5\\
x6\\
x7\\
x8
\end{bmatrix}
\]</span> 上面我就随便举了个<code>N=5</code>,
<code>T=8</code>的例子，用来随便感受下。</p>
<p>这里可以引出一个名词，ill-posed
problem（不适定问题），即有多个满足条件的解，无法判断哪个解更加合适，这是更“落地”的应用场景，inverse
problem（逆问题），比如图像去噪，从噪声图中提取干净图。于是需要做一个约束。</p>
<p>增加限制条件，要求<code>x</code>尽可能稀疏，怎么“稀疏”呢？就是<code>x</code>的<code>0</code>尽可能多，即<code>norm(x, 0)</code>（零范数：非0元素个数）尽可能小。这样就有唯一解了吗？也还不是，如何能“约束”出各位合适的解，如何解，正是稀疏表示所研究的重点问题。比如后来有证明<code>D</code>满足一定条件情况下<code>x</code>满足<code>norm(x,1)</code>即可还原原始数据等，这有不少大神开启这个领域的故事这里就不讲了。</p>
<p>奥卡姆剃刀原理的思想：如果两个模型的解释力相同，选择较简洁的那个。稀疏表达就符合这一点。</p>
<blockquote>
<p>针对这个例子我有个疑问，<code>x</code>都比<code>y</code>还大了，这哪里压缩了。这个问题应该容易解答，例子里<code>x</code>是比<code>y</code>大，但是如果每个<code>原子</code>不是长度为<code>N</code>的列向量，而是个矩阵，或者更复杂的东西呢，<code>x</code>却依然只是一列系数。</p>
</blockquote>
<h4 id="求解">求解</h4>
<p>字典<code>D</code>已知，求<code>y</code>在过完备字典<code>D</code>上的稀疏表示<code>x</code>，被称作稀疏编码，模型是：
<span class="math display">\[
x = \mathop{\arg\min}_{x} norm(y - Dx, 2)^{2}, s.t. norm(x, 1) \le
\varepsilon
\]</span>
如何求解<code>x</code>？<code>D</code>又是怎么来的？先说<code>D</code>，<code>D</code>可以是前面说的傅里叶变换的一系列波啊，也可以是<code>DCT</code>的，也可以是小波的。但是科学家为了特定问题能有更具适应性的字典，让<code>D</code>也变成一个设计出来的量了，手工设计是不行，那么<code>D</code>也成了一个需要求的未知量。</p>
<p>已知<code>D</code>求<code>x</code>有OMP算法，大意是先找到<code>D</code>和<code>y</code>最接近的一个原子<code>D(m)</code>，求出合适的系数<code>x(m)</code>，新的<code>y'=D(m) * x(m)</code>，再找下一个最接近的原子，直到找完合适的<code>x</code>，如何确定最接近，如何计算<code>x(m)</code>，这里不再细说。</p>
<p>当任务是同时求出一个好的字典<code>D</code>，并得到一个满足稀疏约束的<code>x</code>，<strong>两步求解算法</strong>：先固定<code>D</code>，求个<code>x</code>出来，再固定<code>x</code>更新<code>D</code>，交替进行。</p>
<blockquote>
<p>两步求解好熟悉的老套路。也许可以这么理解，求<code>x</code>不再是个稀罕问题，而训练一个好的字典渐渐成为解决应用问题的关键，也是研究重点。</p>
</blockquote>
<p>做这个求解的方法就有MOD、K-SVD等等一系列了。MOD分为两个步骤：Sparse
Coding和Dictionary Update。</p>
<p><strong>Sparse Coding:</strong> <span class="math display">\[
x = \mathop{\arg\min}_{x} norm(y - Ax, 2)^{2}, s.t. norm(x, 1) \le k
\]</span></p>
<p><strong>Dictinary Update:</strong> <span class="math display">\[
D = \mathop{\arg\min}_{x} norm(y - Ax, 2)^{2}
\]</span></p>
<p><code>x</code>的更新类似OMP，字典<code>D</code>的更新使用最小二乘法。</p>
<h3 id="k-svd">K-SVD</h3>
<p>迭代K次，每次计算一下SVD分解的算法。SVD即奇异值，在了解SVD之前先复习一下矩阵的特征值。</p>
<h4 id="特征值分解">特征值分解</h4>
<p>特征值分解和奇异值分解是机器学习领域常见的方法。线性代数中我们熟悉的特征值
<span class="math inline">\(\lambda\)</span> ，设
<code>v</code>是矩阵<code>A</code>的特征向量，则 <span
class="math display">\[
Av = \lambda v
\]</span> <code>v</code>是 <span class="math inline">\(\lambda\)</span>
对应的特征值。
矩阵的一组特征向量是相互正交的，<strong>特征值分解</strong>
将矩阵分解成如下形式： <span class="math display">\[
A = Q\Sigma Q^{-1}
\]</span></p>
<p>其中<code>Q</code>是矩阵<code>A</code>的特征向量组成的矩阵， <span
class="math inline">\(\Sigma\)</span>
是一个对角阵，对角线上每个元素就是一个特征值，由大到小排列。</p>
<blockquote>
<p>这像什么？<span class="math inline">\(\Sigma\)</span> 里的一串 <span
class="math inline">\(\lambda\)</span>
就像前面<code>y=Dx</code>里的<code>x</code>，而特征值矩阵<code>Q</code>就像字典<code>D</code>啊。特征向量的大小描述了每个特征值的权重，它们一起组合成了矩阵<code>A</code>，也就是那个<code>y</code>。</p>
</blockquote>
<p>然而，特征值分解有个严重的局限——<code>A</code>必须是个方阵。</p>
<h4 id="svd奇异值分解">SVD（奇异值）分解</h4>
<p>类比特征值分解，奇异值分解定义成这样： <span class="math display">\[
A = U\Sigma V&#39;
\]</span>
假设<code>A</code>是一个<code>N*M</code>的矩阵，则<code>U</code>是<code>N*N</code>的方阵，<span
class="math inline">\(\Sigma\)</span>
是<code>N*M</code>的矩阵，<code>V</code>是<code>M*M</code>的方阵，于是奇异值分解就是求
<span
class="math inline">\(\Sigma\)</span>、<code>U</code>、<code>V</code>，<code>V'</code>是<code>V</code>的转置。于是套公式就可以求出奇异值、U、V，公式就不堆这里了。</p>
<blockquote>
<p>说来也巧，我之前在一个量子计算的书里看过SVD分解，当时还做了一下习题手算了半天SVD，这部分理解起来舒服多了</p>
</blockquote>
<p>SVD怎么和稀疏性搭边呢？因为奇异值矩阵 <span
class="math inline">\(\Sigma\)</span>
（虽然不是方阵，但也是按45°角放着一串奇异值的类似对角阵的东西）的“对角线”上大部分数值是<code>0</code>或接近<code>0</code>的，类比特征值分解，这些奇异值就是“权重”嘛，如果把接近<code>0</code>的这些丢掉，是不是清（稀）爽（疏）很多？部分奇异值分解，<code>A</code>还是<code>N*M</code>，但假设取比较大的<code>r</code>个奇异值，
<span class="math inline">\(\Sigma\)</span>
变成<code>r*r</code>，部分SVD分解即：</p>
<p><span class="math display">\[
A_{N\times M} \approx U_{N\times r} \Sigma_{r\times r} V^{-1}_{r\times
M}
\]</span></p>
<p>如果<code>r</code>很小，而等式左右又能很接近，那数据就被压缩的相当不错，保存<code>U</code>、<span
class="math inline">\(\Sigma\)</span> 、<code>V</code>
要比保存<code>A</code>本身节省空间多了。</p>
<h4 id="k-svd字典学习">K-SVD字典学习</h4>
<p>K-SVD和MOD最大的不同在于，每次只更新字典的一个原子（即<code>D</code>的一列），而不是每次用一个<code>x</code>更新整个<code>D</code>。</p>
<p>回忆下前面的<code>y=Dx</code>，但是学一个字典，当然不能只用一个数据，现在来升级版：
<span class="math display">\[
Y=DX
\]</span>
哈？小写变大写？意思是一组<code>y</code>和其对应的一组<code>x</code>，那么<code>Y</code>和<code>X</code>指的矩阵。</p>
<p><span class="math display">\[
\begin{bmatrix}
y_{11} &amp; y_{21} &amp; y_{31} &amp; y_{41} \\
y_{12} &amp; y_{22} &amp; y_{32} &amp; y_{42} \\
y_{13} &amp; y_{23} &amp; y_{33} &amp; y_{43} \\
y_{14} &amp; y_{24} &amp; y_{34} &amp; y_{44} \\
y_{15} &amp; y_{25} &amp; y_{35} &amp; y_{45}
\end{bmatrix} = \begin{bmatrix}
d_{11} &amp; d_{21} &amp; d_{31} &amp; d_{41} &amp; d_{51} &amp; d_{61}
&amp; d_{71} &amp; d_{81}\\
d_{12} &amp; d_{22} &amp; d_{32} &amp; d_{42} &amp; d_{52} &amp; d_{62}
&amp; d_{72} &amp; d_{82}\\
d_{13} &amp; d_{23} &amp; d_{33} &amp; d_{43} &amp; d_{53} &amp; d_{63}
&amp; d_{73} &amp; d_{83}\\
d_{14} &amp; d_{24} &amp; d_{34} &amp; d_{44} &amp; d_{54} &amp; d_{64}
&amp; d_{74} &amp; d_{84}\\
d_{15} &amp; d_{25} &amp; d_{35} &amp; d_{45} &amp; d_{55} &amp; d_{65}
&amp; d_{75} &amp; d_{85}
\end{bmatrix}\times
\begin{bmatrix}
x_{11} &amp; x_{21} &amp; x_{31} &amp; x_{41}\\
x_{12} &amp; x_{22} &amp; x_{32} &amp; x_{42}\\
x_{13} &amp; x_{23} &amp; x_{33} &amp; x_{43}\\
x_{14} &amp; x_{24} &amp; x_{34} &amp; x_{44}\\
x_{15} &amp; x_{25} &amp; x_{35} &amp; x_{45}\\
x_{16} &amp; x_{26} &amp; x_{36} &amp; x_{46}\\
x_{17} &amp; x_{27} &amp; x_{37} &amp; x_{47}\\
x_{18} &amp; x_{28} &amp; x_{38} &amp; x_{48}
\end{bmatrix}
\]</span></p>
<p>现在要更新字典<code>D</code>的第<code>k</code>个原子，也就是第<code>k</code>列，它能影响到的是<code>Y</code>的第<code>k</code>行，同样对应<code>D</code>的第<code>k</code>列的系数，也是<code>X</code>的第<code>k</code>行。</p>
<p>目标函数的转化：</p>
<p><span class="math display">\[
\begin{align*}
&amp;  \quad\ \left \|Y - DX\right \|^{2}_{F} \\
&amp; =\left \|Y-\Sigma_{j=1}^{K}d_{j}x^{T}_{j}\right \|^{2}_{F} \\
&amp; =\left \|(Y-\Sigma_{j\neq k}d_{j}x^{T}_{j})-d_{k}x^{T}_{k}\right
\|^{2}_{F} \\
&amp; =\left \|E_{k}-d_{k}x^{T}_{k}\right \|^{2}_{F}
\end{align*}
\]</span> <span class="math inline">\(E_{k}\)</span> 是去掉原子 <span
class="math inline">\(d_{k}\)</span> 的 <span
class="math inline">\(D\)</span> 中的误差，于是目标函数转化为 <span
class="math inline">\(D\)</span> 的其他列固定，要更新的 <span
class="math inline">\(d_{k}\)</span> 使全局误差（ <span
class="math inline">\(\left \|Y-DX\right \|\)</span> ）最小化。
即可得到字典的第<code>k</code>个原子。求解这里的 <span
class="math inline">\(D_{k}, x^{T}_{k}\)</span> ，就用到对 <span
class="math inline">\(E\)</span> 的SVD分解了。</p>
<p>但是直接分解 <span class="math inline">\(E\)</span> 得到的 <span
class="math inline">\(x^{T}_{k}\)</span> 并不稀疏。</p>
<p>更新字典和稀疏系数是迭代进行的，在“本次”迭代中，找到“上次”迭代中哪些<code>Y</code>用到了字典<code>D</code>的原子<code>k</code>，也就是<code>X</code>的第<code>k</code>行哪些元素不为<code>0</code>，<span
class="math inline">\(x_{1k},x_{2k},x_{3k},x_{4k}\)</span>
里，<strong>假设</strong> <span
class="math inline">\(x_{1k},x_{3k}\)</span>
不为<code>0</code>，那么对应的<code>Y</code>的<code>1,3</code>列就是用到了<code>D</code>的原子<code>k</code>的信号（<code>Y</code>的每列是一个信号）。现在把它们拆出来：
<span class="math display">\[
\begin{align*}
  &amp; Y^{temp}_{k} = \begin{bmatrix}
  y_{11} &amp; y_{31} \\
  y_{12} &amp; y_{32} \\
  y_{13} &amp; y_{33} \\
  y_{14} &amp; y_{34} \\
  y_{15} &amp; y_{35}
  \end{bmatrix} \\
  &amp; X^{temp}_{k} = \begin{bmatrix}
  x_{1k} &amp; x_{3k}
  \end{bmatrix} \\
  &amp; D^{temp}_{k} = \begin{bmatrix}
  d_{k1}\\
  d_{k2}\\
  d_{k3}\\
  d_{k4}\\
  d_{k5}
  \end{bmatrix} \\
\end{align*}
\]</span></p>
<p>这样得到只保留非零位置的<code>X</code>、<code>D</code>计算目标函数后得到的只保留对应位置的
<span class="math inline">\(E^{temp}_{k}\)</span> ，对这个 <span
class="math inline">\(E^{temp}_{k}\)</span> 再做SVD分解，<span
class="math inline">\(E^{temp}_{k} = U \Sigma V^{T}\)</span>， <span
class="math inline">\(U\)</span> 的第一列即为新的 <span
class="math inline">\(\widetilde{d}_{k}\)</span>， <span
class="math inline">\(V\)</span> 的第一列与 <span
class="math inline">\(\Sigma(1, 1)\)</span> 的乘积为新的 <span
class="math inline">\(\widetilde{x}^{T}_{k}\)</span> 。</p>
<p>逐列更新得到新字典 <span class="math inline">\(\widetilde{D}\)</span>
。</p>
<h3 id="k-svd图像去噪">K-SVD图像去噪</h3>
<p>上面提到过稀疏表示基本的目标函数是： <span class="math display">\[
x = \mathop{\arg\min}_{x} \left \|y - Dx\right \|^{2}_{2}, s.t. \left
\|x \right \|_{0} \le \varepsilon
\]</span></p>
<blockquote>
<p>这里暂时用0范数来说明。</p>
</blockquote>
<p>假设现在有一个零均值高斯白噪声，即 <span class="math inline">\(n\sim
N(0,\sigma)\)</span> ， <span class="math inline">\(\sigma\)</span>
是噪声的标准差，有噪声的图像为 <span
class="math inline">\(z=y+n\)</span> ，目的是从信号 <code>z</code>
中恢复出原始无噪信号
<code>y</code>，通过最大后验概率，求得目标函数的解，即可恢复出<code>y</code>：</p>
<p><span class="math display">\[
x = \mathop{\arg\min}_{x} \left \|z - Dx\right \|^{2}_{2}, s.t. \left
\|x \right \|_{0} \le T
\]</span> &gt;
这里最大后验概率能恢复<code>y</code>是为什么暂时没管，肯定有证明了。。</p>
<p>其中<code>T</code>依赖于 <span
class="math inline">\(\varepsilon\)</span> 和 <span
class="math inline">\(\sigma\)</span>
。为方便优化计算，实际操作中往往转化成： <span class="math display">\[
x = \mathop{\arg\min}_{x} \left \|z - Dx\right \|^{2}_{2}+\mu \left \|x
\right \|_{0}
\]</span> 选取恰当的<span
class="math inline">\(\mu\)</span>可以让上面两式等价。</p>
<p>优化属于NP难问题，有一系列研究，可通过OMP、BP、FOCUSS等算法来获得近似解。如果
<code>x</code> 足够稀疏，近似解就足够接近精确解。</p>
]]></content>
      <tags>
        <tag>稀疏表示</tag>
        <tag>K-SVD</tag>
        <tag>Denoising</tag>
      </tags>
  </entry>
  <entry>
    <title>生成模型与判别模型</title>
    <url>/2017-04-09-generating-model-and-discriminant-model/</url>
    <content><![CDATA[<p><strong>有监督学习</strong>方法可以分为<strong>生成方法</strong>和<strong>判别方法</strong>，学习得到的模型对应称为生成模型与判别模型。</p>
<p>事物的状态是有概率的，设输入集合是 <code>X</code> , 可以输出的集合是
<code>Y</code>，那么
<code>P(Y|X)</code>表示已知<code>X</code>情况下标签是<code>Y</code>的概率模型，即给出任意<code>xi</code>,
<code>yj</code>，都可求出<code>p(yj|xi)</code>；<code>P(Y,X)</code>表示<code>Y</code>和<code>X</code>一起发生的概率模型，同理就是求出所有的<code>p(yj, xi)</code>。</p>
<p>对于分类问题，就是输入<code>X</code>，输出标签<code>Y</code>，从概率角度说，就是已知<code>X</code>，找概率最大的<code>Y</code>，即条件概率分布<code>P(Y|X)</code>。</p>
<ul>
<li>生成模型：生成数据的分布，也就是求联合分布
<code>P(Y, X)</code>，再通过贝叶斯理论计算 <code>P(Y|X)</code>。</li>
<li>判别模型：判别输出结果的模型，直接训练条件分布<code>P(Y|X)</code>。</li>
</ul>
<p>生成模型的<code>P(Y,X)</code>可以计算出<code>P(Y|X)</code>，反之则不行。联合分布具有更多的信息，所以会有更广的普适性。可以处理存在隐变量的情况，也是这篇博客接下来要讲的。</p>
<p>判别模型由于直接学习条件分布<code>P(Y|X)</code>，所以允许对输入进行抽象，比如降维，从而简化学习问题，</p>
<p>于是就比较容易理解常见的判别方法有SVM、逻辑回归等；
常见的生成方法有朴素贝叶斯法、隐马尔可夫模型等。</p>
<h3 id="参考">参考</h3>
<ol type="1">
<li><a
href="https://www.zhihu.com/question/20446337">机器学习“判定模型”和“生成模型”有什么区别？</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>马尔可夫模型到条件随机场，再结合深度学习</title>
    <url>/2017-04-06-mm-crf-imageprocessing/</url>
    <content><![CDATA[<p>先了解了一下<a
href="/2017-04-09-generating-model-and-discriminant-model/">生成模型与判别模型</a></p>
<h3 id="隐马尔可夫模型">隐马尔可夫模型</h3>
<p>隐马尔可夫模型（HMM）属于生成模型。</p>
<p>组成：两个集合，两个序列，两个矩阵。</p>
<p>这些内容构成了隐马尔可夫模型的整体概念，具体问题中，有的是已知的，有的是未知的，这个模型就是通过已知量建模，进而推算未知量。</p>
<span id="more"></span>
<h4 id="两个集合">两个集合</h4>
<p>状态集合：比如有<code>N</code>个装着黑白两色小球的盒子，当前在第<code>i</code>个盒子就称为状态<code>qi</code>，状态集合<code>Q=&#123;q1, q2,...,qN&#125;</code>。</p>
<p>观测集合：对一个状态，可以有多种观测结果，从一个盒子里拿出一个球，这个球的颜色是观测值，就可能是黑色或白色，观测集合<code>V=&#123;v1, v2, ..., vM&#125;</code>，对于黑白小球这个例子，<code>M=2</code>。</p>
<h4 id="两个序列">两个序列</h4>
<p>状态序列：这个序列可以看作一个时间序列，比如每分钟选一个盒子，当然可以不是时间序列，只是举例子方便些。那一小时就会有一个长度为60的序列，每个元素即对应那一分钟选的盒子编号。状态序列<code>I=(i1, i2, ..., iT)</code>，这里一小时的例子中<code>T=60</code>。</p>
<p>观测序列：对应状态序列的观测值，假设实实在在地做了一次实验，选了60次盒子，拿了60次小球，记录了这60次小球的颜色，观测序列<code>O=(o1, o2, ..., oT)</code>。</p>
<h4 id="两个矩阵">两个矩阵</h4>
<p>状态转移矩阵： <span class="math inline">\(A=[a_{ij}]_{N\times
N}\)</span>
即假设“当前状态”是<code>qi</code>（盒子<code>qi</code>），下一分钟转移到状态<code>qj</code>（选盒子<code>qj</code>）的概率是<code>aij</code>。这里当然和模型名字中的“马尔可夫”挂钩了，马尔可夫过程就是<strong>未来的状态只依赖现在的条件，不依赖于过去</strong>，于是由状态转移矩阵和当前状态即可以知道下一个状态的概率，不需要管上一个状态了。</p>
<p>观测概率矩阵： <span class="math inline">\(B=[b_{j}(k)]_{N\times
M}\)</span>
状态<code>qj</code>条件下得到观测<code>vk</code>的概率，比如盒子<code>qj</code>有<code>4</code>个黑球，<code>6</code>个白球，<span
class="math inline">\(b_{j}(白)\)</span>
就是拿出一个球是白球的概率呗（0.6）。</p>
<blockquote>
<p>盒子与黑白球的例子不算太完美，让人不太习惯的就是怎么选下一个盒子还带“转移概率”的。强行这么理解吧，感觉天气的栗子举起来更难下口。</p>
</blockquote>
<h4 id="模型表示">模型表示</h4>
<p>最开始还没选盒子的时候，总需要有个起始变量。初始状态概率向量 <span
class="math inline">\(\pi=(\pi_{i})\)</span>
即最开始的时候，进入状态<code>qi</code>的概率。有初始状态向量 <span
class="math inline">\(\pi\)</span> ，状态转移矩阵 <span
class="math inline">\(A\)</span> ，观测概率矩阵 <span
class="math inline">\(B\)</span>
，这个模型就可以像一个“自动机”一样跑起来了，可以不断按模型产生状态和观测值。所以隐马尔可夫模型
<span class="math inline">\(\lambda\)</span> 可以用三元符号表示： <span
class="math display">\[
\lambda = (A, B, \pi)
\]</span></p>
<p><span class="math inline">\(A, B, \pi\)</span>
称为马尔可夫模型三要素。</p>
<h4 id="三个基本问题">三个基本问题</h4>
<ol type="1">
<li>概率计算，给定 <span class="math inline">\(\lambda=(A, B,
\pi)\)</span> 和观测序列 <code>O</code>，计算概率 <span
class="math inline">\(P(O|\lambda)\)</span>
，就是已知模型，求能得到特定个观测序列的概率。对这个问题，直接计算的话要枚举所有状态，是指数级的，不可行。而前向法和后向法一个是正推一个是倒推，步步为营递推即可得到结果。</li>
<li>学习问题，给定<code>O</code>，估计模型 <span
class="math inline">\(\lambda=(A, B, \pi)\)</span> ，即估算 <span
class="math inline">\(A, B, \pi\)</span>
。监督学习方法需要训练数据，人工标注代价很高，有时会利用非监督学习方法——Baum-welch算法（也就是EM算法）。</li>
<li>预测问题，也称为解码问题，已知模型 <span
class="math inline">\(\lambda=(A, B, \pi)\)</span> 给定观测序列
<code>O</code>，求最可能的状态序列
<code>I</code>。近似算法计算简单，有一定的适用范围，不过有可能有实际不发生的部分，即存在转移概率为0的状态。维比特算法用动态规划求概率最大路径，一条路径对应一个状态序列。</li>
</ol>
<p>具体算法这里不细说，可参考《统计学习方法》。</p>
<h3 id="马尔可夫随机场">马尔可夫随机场</h3>
<h4 id="三个马尔可夫性">三个马尔可夫性</h4>
<p>Markov random field (MRF) 也就是概率无向图模型（probabilistic
undirected graphical model）。</p>
<p>一个无向图记作<code>G=(V,E)</code>，顶点<code>V</code>表示随机变量<code>Y</code>，边<code>E</code>表示随机变量间的概率依赖关系，则图<code>G</code>表示概率分布<code>P(Y)</code>。</p>
<ul>
<li>成对马尔可夫性：</li>
</ul>
<p>设<code>u</code>和<code>v</code>是无向图<code>G</code>中任意两个<strong>没有边连接</strong>的结点，对应随机变量
<span class="math inline">\(Y_{u}\)</span> 和 <span
class="math inline">\(Y_{v}\)</span>
，其他所有节点为<code>O</code>，对应随机变量<strong>组</strong> <span
class="math inline">\(Y_{O}\)</span>，给定 <span
class="math inline">\(Y_{O}\)</span> 条件下随机变量 <span
class="math inline">\(Y_{u}\)</span> 和 <span
class="math inline">\(Y_{v}\)</span> 条件独立，即： <span
class="math display">\[
P(Y_{u}, Y_{v}|Y_{O})=P(Y_{u}|Y_{O})P(Y_{v}|Y_{O})
\]</span></p>
<blockquote>
<p><code>u</code>、<code>v</code>不相连，其他变量又已知了，则<code>u</code>、<code>v</code>之间概率自然互不影响</p>
</blockquote>
<ul>
<li>局部马尔可夫性：</li>
</ul>
<p>设集合<code>W</code>是与结点<code>v</code>有边连接的所有结点，<code>O</code>是除<code>v</code>、<code>W</code>以外的其他节点，给定
<span class="math inline">\(Y_{W}\)</span> 情况下 <span
class="math inline">\(Y_{v}\)</span> 与 <span
class="math inline">\(Y_{O}\)</span> 独立。
&gt;同理，只是把上面的<code>u</code>变成集合<code>O</code>了</p>
<ul>
<li>全局马尔可夫性：</li>
</ul>
<p>结点集合<code>A</code>，<code>B</code>是无向图<code>G</code>中被结点集合<code>C</code>分开的任意结点集合，给定
<span class="math inline">\(Y_{C}\)</span> 条件下 <span
class="math inline">\(Y_{A}\)</span> 和 <span
class="math inline">\(Y_{B}\)</span> 条件独立。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O---A---C---B</span><br><span class="line">    | \ |   | \</span><br><span class="line">    A---C---B---O</span><br></pre></td></tr></table></figure>
<p>如果联合概率分布<code>P(Y)</code>满足成对、局部或全局马尔可夫性，就称此联合概率分布为马尔可夫随机场（MRF）或概率无向图模型。</p>
<h4 id="求概率分布">求概率分布</h4>
<p><strong>团与最大团</strong>：无向图<code>G</code>中一个结点子集<code>C</code>，若<code>C</code>中任意两个结点都有边连接，则<code>C</code>是一个团。如果无法在<code>C</code>中增加<code>G</code>中的结点并保持团的性质，则<code>C</code>是最大团（maximal
clique）。</p>
<p><strong>马尔可夫随机场因子分解</strong>：将图模型的联合概率分布表示为最大团上的随机变量函数乘积形式，称为因子分解。
<span class="math display">\[
P(Y)=\frac{1}{Z}\prod\limits_{C} \Psi_{C}(Y_{C})
\]</span> <code>Z</code>是归一化因子： <span class="math display">\[
Z=\sum_{Y}\prod\limits_{C} \Psi_{C}(Y_{C})
\]</span>
要保证<code>P(Y)</code>构成一个概率分布，即所有情况的概率的和（积分）得是1，所以要有这个归一化因子。函数
<span class="math inline">\(\prod\limits_{C}\)</span>
称为<strong>势函数</strong>（potential
function），这里要求势函数是严格正的，通常定义为指数函数： <span
class="math display">\[
\Psi_{C}(Y_{C})=e^{-E(Y_{C})}
\]</span> <code>C</code>是无向图的最大团， <span
class="math inline">\(Y_{C}\)</span>
是<code>C</code>的结点对应的随机变量， <span
class="math inline">\(\Psi_{C}(Y_{C})\)</span>
是<code>C</code>上定义的严格正函数，乘积是在无向图所有最大团上进行的。</p>
<h4 id="吉布斯分布">吉布斯分布</h4>
<p>吉布斯分布(Gibbs)在随机场的知识中总是伴随马尔可夫随机场出现，搞得人一头雾水。今天来把它掰扯清楚。</p>
<p>在统计力学与数学中，玻尔兹曼分布（或称吉布斯分布）是系统中的粒子在各种可能微观量子态的概率分布、概率测度或频度分布。在数学上，玻尔兹曼函数更广义的形式为吉布斯测度。在统计学与机器学习中又被称为对数-线性模型。——维基百科</p>
<p>玻尔兹曼分布是状态能量与系统温度的函数，给出了粒子处于特定状态下的概率。其具有以下形式：
<span class="math display">\[
p_{i} =
\frac{e^{-\varepsilon_{i}/kT}}{\sum_{j=1}^{M}e^{-\varepsilon_{j}/kT}}
\]</span> 其中 <span class="math inline">\(p_{i}\)</span> 是量子态
<code>i</code> 的概率， <span class="math inline">\(\varepsilon\)</span>
为量子态 <code>i</code> 的能量， <code>k</code> 为玻尔兹曼常量，
<code>T</code> 为系统温度， <code>M</code>
为系统可具有的量子态数目。</p>
<p>扯得好像有点远，但是注意观察对比前面的<strong>马尔可夫随机场因子分解</strong>，就是那个最大团随机变量函数乘积，势函数、归一化因子<code>Z</code>，和这里的分子分母形式很像。</p>
<p>看到这里，我觉得不指望对这个分布有什么感性认识了，只能强行这么看（理性认识...）：符合这个公式（描述了一个概率分布）的分布，就叫做吉布斯分布，而马尔可夫随机场的概率分布可以描述为最大团随机变量函数乘积形式，这个形式与吉布斯分布不谋而合，<a
href="https://en.wikipedia.org/wiki/Hammersley%E2%80%93Clifford_theorem">Hammersley
Clifford Theorem</a>
提到马尔可夫随机场和吉布斯分布是一致的（原文说的是“吉布斯随机场满足每一个马尔可夫性质”）。</p>
<p>这就是吉布斯分布，好像并没有掰扯很清楚，不过上这么多年学过来，不少东西都是强行认识的，比如小时候第一次认识惯性定律的时候那感觉。。。</p>
<h4 id="势函数">势函数</h4>
<p>说起来这个势函数也是强行定义的么，追求感性认识的我找了一圈也没见有人解释一下这个东西为啥叫势函数。</p>
<p>暂时这么理解吧：最大团两两连接，即团内结点两两之间都能<strong>直接</strong>影响到对方，那么这个团得到某种观察状态就是结点们<strong>直接</strong>“达成共识”的结果，这个结果的可能性是可以直接计算的。而<strong>全局</strong>得到一个什么结果，就需要一些“中间人”去协商，因为团内不是所有结点都能直接和别的团的结点“讨论”，<strong>全局</strong>结果是一个“协商”的结果，互相之间有直接关系的小团体（最大团）对最终结果有一个<strong>趋势</strong>，这个就是<strong>势函数</strong>，而全局的结果是各个小团体的趋势互相妥协的结果。</p>
<h3 id="条件随机场">条件随机场</h3>
<p>条件随机场（conditional random field,
CRF）是给定随机变量<code>X</code>条件下，另一组随机变量<code>Y</code>的马尔可夫随机场。</p>
<p>定义中并没有要求<code>X</code>和<code>Y</code>具有相同的结构，现实中一般假设<code>X</code>和<code>Y</code>有相同的图结构。</p>
<h4 id="线性链条件随机场">线性链条件随机场</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y1---Y2---...---Yi--...---Yn</span><br><span class="line">↑    ↑          ↑         ↑</span><br><span class="line">X1   X2         Xi        Xn</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
P(Y_{i}|X,
Y_{1},...,Y_{i-1},Y_{i+1},...,Y_{n})=P(Y_{i}|X,Y_{i-1},Y_{i+1})
\]</span>
上式满足马尔可夫性，<code>X</code>表示输入观测序列，<code>Y</code>表示对应的输出标记序列或状态序列。
<span class="math inline">\(Y_{i}\)</span> 只与相连的 <span
class="math inline">\(Y_{i-1}\)</span> 、 <span
class="math inline">\(Y_{i+1}\)</span> 相关，但是多了个 <span
class="math inline">\(X\)</span>
的条件，且可以看到与隐马尔可夫模型的不同，隐马尔可夫链是顺序的链，每个状态只与“上一个”状态相关，而线性链条件随机场是<strong>无向图</strong>，每个状态与直接相连的状态相关（上一个和下一个），且有一个额外的条件<code>X</code>。</p>
<h4 id="线性链条件随机场基本问题">线性链条件随机场基本问题</h4>
<ol type="1">
<li>概率计算问题：给定条件随机场<code>P(Y|X)</code>，输入序列<code>x</code>，输出序列<code>y</code>，计算条件概率
<span class="math inline">\(P(Y_{i}=y_{i}|x)\)</span> ， <span
class="math inline">\(P(Y_{i-1}=y_{i-1},Y_{i}=y_{i}|x)\)</span>
以及相应的数学期望。</li>
<li>学习算法。</li>
</ol>
<blockquote>
<p>此部分非本篇博文重点，不再详述，《统计学习方法》也讲的很清晰。</p>
</blockquote>
<h3 id="crf图像分割">CRF图像分割</h3>
<p>把图像每个像素当作条件随机场的一个结点，相邻像素连边，结点集合为<code>Y</code>，在这个基础上，加一个和每个像素一一对应的条件<code>X</code>，条件<code>X</code>就是实际看到的图像，要求的<code>Y</code>是分割结果标签，参考前面的线性链条件随机场，就是把一维的链变成二维的图像，<code>Y</code>的每个像素与相邻像素相连，<code>X</code>的每个像素一一对应与<code>Y</code>连一条边，如图：</p>
<img src="/2017-04-06-mm-crf-imageprocessing/crf_example.png" class="" title="CRF Example">
<p>于是就是各个资料都说的两个式子了：
按前面说的吉布斯分布，差不多就是每四个像素一个最大团 <span
class="math display">\[
P(Y=y|X)=\frac{1}{Z(X)}e^{-E(y|X)}
\]</span> 标签能量表示为 <span class="math display">\[
E(y) = \sum_{i}\Psi_{u}(y_{i}) + \sum_{i&lt;j}\Psi_{p}(y_{i}, y_{j})
\]</span> <span class="math inline">\(\Psi_{u}\)</span>
是一元能量项，表示像素<code>i</code>分类为标签<code>yi</code>的能量，
<span class="math inline">\(\Psi_{p}\)</span> 是二元能量向，表示像素
<code>i</code>、<code>j</code>同时分类为
<code>yi</code>、<code>yj</code>的能量，最小化能量总和就是最可能的分割结果。</p>
<p>能量项可以有不同的定义方式，在求解过程、计算结果等方面都会有不同的影响。</p>
<h3 id="crf与深度学习">CRF与深度学习</h3>
<p>按原始定义来说，一般是先用神经网络输出之后，再用CRF进一步处理，两部分是分开的。而我们都更偏爱端到端直接训练的方法，精确度也会有所提高。CRF可以被表示成RNN的结构，和其他的神经网络结合在一起，实现端到端的同时训练。</p>
<p>这里可以有感性认识，就不放公式了，我自己也没搞太懂。</p>
<p>前面的标签能量<code>E</code>表示为一元能量项加二元能量项，二元能量项定义为若干个高斯函数的和，高斯函数又由若干表达式组成，概率函数<code>P</code>不方便直接计算，又对式子做了些许改变，可以多次迭代来近似。对分解后的公式分成若干步骤，每次迭代就是若干步的连接，而分解出来的每一步可以由卷积来计算，归一化的步骤可以由Softmax来计算，这样就通过一个RNN网络来迭代逼近<code>P</code>了，相关证明保证迭代的快速收敛。</p>
<h3 id="参考">参考</h3>
<ol type="1">
<li><a
href="http://baike.baidu.com/item/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95"><code>李航. 统计学习方法[J]. 清华大学出版社, 北京, 2012.</code></a></li>
<li><a
href="https://zh.wikipedia.org/wiki/%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E5%88%86%E5%B8%83">维基百科-玻尔兹曼分布</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/22308032">图像语义分割之FCN和CRF</a></li>
<li><a href="http://blog.csdn.net/taigw/article/details/51794283">CRF as
RNN的原理及Caffe实现</a></li>
</ol>
]]></content>
      <tags>
        <tag>隐马尔可夫</tag>
        <tag>条件随机场</tag>
        <tag>CRF</tag>
      </tags>
  </entry>
  <entry>
    <title>HNCPC历年Rank</title>
    <url>/2020-11-27-hncpc-every-year/</url>
    <content><![CDATA[<p>湖南省大学生程序设计竞赛历年 Rank</p>
<span id="more"></span>
<iframe id="rank_frame" src="/static_files/HNCPC_Rank/HNCPC_Rank.htm" frameborder="0" scrolling="auto" width="100%" height="100%">
</iframe>
<script> 
function changeFrameHeight(){ 
    var ifm = document.getElementById("rank_frame"); 
    ifm.height=document.documentElement.clientHeight - 400; 
} 

window.onload = function(){ 
    changeFrameHeight(); 
} 

window.onresize=function(){ 
    changeFrameHeight(); 
} 
</script>
]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>HNCPC</tag>
      </tags>
  </entry>
  <entry>
    <title>图的前向星表示（带注释）</title>
    <url>/2021-03-31-chain-graph-template/</url>
    <content><![CDATA[<p>该内容在紫书中有详述</p>
<p>这里贴一份模板方便讲解使用</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 链式前向星建图</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxN = <span class="number">1100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxM = <span class="number">110000</span>;</span><br><span class="line"><span class="type">int</span> first[maxN];    <span class="comment">// 每个顶点发出的边的边链表头结点，该数组可初始化为 -1 表示每个顶点都还没有边</span></span><br><span class="line"><span class="type">int</span> nex[maxM];      <span class="comment">// 同个顶点发出的边的边结点 next 域</span></span><br><span class="line"><span class="type">int</span> u[maxM];        <span class="comment">// 边的发出顶点</span></span><br><span class="line"><span class="type">int</span> v[maxM];        <span class="comment">// 边的收入顶点</span></span><br><span class="line"><span class="type">int</span> w[maxM];        <span class="comment">// 边的权值</span></span><br><span class="line"><span class="type">int</span> tp;             <span class="comment">// 全局“内存分配”“指针”，就是模拟分配内存时，tp从0开始逐个增加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如 first[1]，表示顶点 V1 发出的第一条边的“指针”，这里就是数组编号</span></span><br><span class="line"><span class="comment">// nex[first[1]] 表示顶点 V1 发出的边的链表的第二个结点编号</span></span><br><span class="line"><span class="comment">// nex[nex[first[1]]] 表示顶点 V1 发出的边的链表的第三个结点编号 ...</span></span><br><span class="line"><span class="comment">// u[first[1]] 顶点 V1</span></span><br><span class="line"><span class="comment">// v[first[1]] 顶点 V1 发出的第一条边的另一端的顶点编号，比如 v[first[1]] == 3 就表示 V1 连着 V3</span></span><br><span class="line"><span class="comment">// w[first[1]] 顶点 V1 发出的第一条边的权值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 建图：表示顶点 s 向顶点 e 发出了一条权重为 weight 的有向边</span></span><br><span class="line">    <span class="comment">// 程序开始时 tp 初始为 0</span></span><br><span class="line">    nex[tp] = first[s]; <span class="comment">// 类似链表头插法</span></span><br><span class="line">    first[s] = tp;</span><br><span class="line">    u[tp] = s;</span><br><span class="line">    v[tp] = e;</span><br><span class="line">    w[tp] = weight;</span><br><span class="line">    tp ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DbEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果表示无向图，那简单，两个方向都建一条有向边就好</span></span><br><span class="line">    <span class="built_in">AddEdge</span>(s, e, weight);</span><br><span class="line">    <span class="built_in">AddEdge</span>(e, s, weight);</span><br><span class="line">    <span class="comment">// 结合 tp 的属性，你会发现，可以很容易找到两个顶点之间成对的双向边</span></span><br><span class="line">    <span class="comment">// 比如 i 是 s 发向 e 的边的编号，那么 i^1 （异或操作） 就是 e 发向 s 的边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 以深度优先搜索为例遍历全图，感受前向星的使用</span></span><br><span class="line"><span class="type">bool</span> vis[maxN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = first[now]; i != <span class="number">-1</span>; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 类似链表访问过程，i = first[now] 从头结点获得第一条边的指针</span></span><br><span class="line">        <span class="comment">// i = nex[i] 即链表指针域往后遍历</span></span><br><span class="line">        <span class="comment">// i != -1 即判断是否到链表末尾</span></span><br><span class="line">        <span class="comment">// u[i]、v[i]、w[i] 都是链表结点的数据域，当然你可以把 nex、u、v、w 封装在 struct 里</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[v[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[v[i]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 以迪杰斯特拉最短路算法体验前向星的使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> vNum;</span><br><span class="line">    <span class="type">int</span> pathLen;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> v_, <span class="type">int</span> p_)&#123;vNum = v_, pathLen = p_;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node &amp;b)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pathLen &gt; b.pathLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> key[maxN];  <span class="comment">// 动态更新每个结点与起点的距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(key, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(key));</span><br><span class="line">    key[s] = <span class="number">0</span>;</span><br><span class="line">    std::priority_queue&lt;Node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node now = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(now.pathLen != key[now.vNum])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(now.vNum == e)</span><br><span class="line">            <span class="keyword">return</span> now.pathLen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = first[now.vNum]; i != <span class="number">-1</span>; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now.pathLen + w[i] &lt; key[v[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                key[v[i]] = now.pathLen + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(v[i], key[v[i]]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>用git管理自己的代码与文档</title>
    <url>/2021-03-31-git-newbie/</url>
    <content><![CDATA[<p>用 git 多年，网上 git 使用的博客也层出不穷，然而让学生使用 git
的时候，却困难重重。</p>
<p>找资料不如写资料，写篇小白入门，希望能有些效果。</p>
<span id="more"></span>
<hr />
<h2 id="什么是git">什么是git</h2>
<p>git（分布式版本控制系统）并不等同于github。</p>
<p>git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。</p>
<p>github提供git服务，其他网站当然也可以，自己也可以搭建git服务器。</p>
<p>今天改了代码，明天又改了，后天甲方爸爸说还是喜欢第一个版本……</p>
<p>用git可以方便的查看/回滚任意commit过的版本，并查看文本类文件的差异。</p>
<p>当然也可以当个文档云服务，方便地在不同地点同步自己的代码与文档。严格的版本控制能够保证文件不出差错。</p>
<p><strong>这里推荐大家使用git管理自己的ACM代码、解题报告、模板、技术日志等</strong>。</p>
<h2 id="git起步">git起步</h2>
<h3 id="下载安装git客户端">下载安装git客户端</h3>
<p>当然要有支持软件才可以：https://git-scm.com/</p>
<p>安装的时候有个细节要注意选择——</p>
<p>“Checkout as-is, commit Unix-style line endings”</p>
<img src="/2021-03-31-git-newbie/line_ending_style.png" class="" title="a">
<p>写代码的你们应该已经了解这个事情：Windows、OSX、Linux/Unix
的换行格式不一样（<code>\n</code>、<code>\r\n</code>...）</p>
<p>建议推送到git仓库的代码都是 Unix 格式的换行。</p>
<p>而Windows只要使用高级点的文本编辑器，换行显示都不是问题。</p>
<h3 id="配置个人信息及公钥">配置个人信息及公钥</h3>
<p>安装git软件之后就有git控制台了，任意位置右键打开它。</p>
<img src="/2021-03-31-git-newbie/git_bash_here.png" class="" title="b">
<p>执行以下三行，替换引号里的内容为自己的。遇到提示都默认回车。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&lt;你的用户名&gt;&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&lt;你的邮箱&gt;&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;&lt;你的邮箱&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于新手小白，不用太关心这些是什么。特别是第三行以及下面的内容，如果想搞清楚，可以去了解一下<a
href="https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA加密算法</a>，简单来说是让你本地生成一个钥匙和一个锁，等下要把锁传给服务器用来锁你的代码。而钥匙只有你的本地有，能理解个大概吧。</p>
<p>github的网速慢，可能还需要梯子。对于新手的你，就用开源中国的git服务吧，很快也很好用：</p>
<p>https://gitee.com/</p>
<p>注册账号一通操作（认真对待账号邮箱与手机号。总忘密码不是快乐的事情）</p>
<p>进入账号设置，找到ssh公钥设置进行填写。</p>
<img src="/2021-03-31-git-newbie/gitee_setting.png" class="" title="c">
<img src="/2021-03-31-git-newbie/gitee_ssh.png" class="" title="d">
<p>公钥字符串就是你的锁，它就是刚刚<code>ssh-keygen -t rsa -C "&lt;你的邮箱&gt;"</code>这行代码在你的系统里生成的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\&lt;你的windows用户名&gt;\.ssh\id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>注意：这个目录有 <code>id_rsa</code> 和
<code>id_rsa.pub</code>，“pub”一看就能分辨这个才是“公”钥咯。</p>
<p>用vscode或者什么文本编辑器打开这个文件，复制全部内容，贴在gitee的那个地方，点确定，gitee就有你的锁（公钥）来保护你的代码了。</p>
<p>私钥不需要另外的配置，git软件会自动到这个路径找你的私钥去开锁帮你读写服务器上的代码。</p>
<h3 id="已经可以开始使用了">已经可以开始使用了</h3>
<p>在gitee里建一个自己的仓库</p>
<img src="/2021-03-31-git-newbie/gitee_repo.png" class="" title="e">
<p>进入仓库，复制仓库的管理链接，我们配置的是ssh方式的（ssh一般基于RSA加密，就是上面的钥匙和锁的事情）</p>
<img src="/2021-03-31-git-newbie/gitee_sshurl.png" class="" title="f">
<p>到自己本地的工作目录（就是自己想要存放、管理代码或文档的目录）</p>
<p>打开前面配置git的那个控制台（右键-&gt;git bash
here），用git指令把代码克隆下来（当然新仓库啥都没有）</p>
<img src="/2021-03-31-git-newbie/git_clone.png" class="" title="g">
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;刚刚复制的ssh地址&gt;</span><br></pre></td></tr></table></figure>
<p>正常情况仓库就到了本地了，会有一个你仓库名字的文件夹，比如<code>my-acm-code</code>。文件夹里有一个隐藏文件夹“<code>.git</code>”，这就是你本地的仓库。</p>
<p>这里举个例子，仓库放在了这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\workspace\my-acm-code</span><br></pre></td></tr></table></figure>
<p>你的仓库就是隐藏文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\workspace\my-acm-code\.git</span><br></pre></td></tr></table></figure>
<p>在仓库文件夹里（<code>E:\workspace\my-acm-code</code>）随便存放和编辑代码或文档吧。</p>
<p>当想要保存版本的时候，在你的仓库文件夹里（<code>E:\workspace\my-acm-code</code>）打开控制台。当然在控制台里切换到这个路径也可以。这可能需要一些基础的命令行知识，比如小学时候学的dos指令（windows下）或者了解过linux的shell指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>可能什么都不发生，也可能有一些提示，这是把“还没加入版本控制的文件”加入到版本控制里。</p>
<p>然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -am <span class="string">&quot;&lt;你的备注&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p>git要求你对每次commit的版本做个注释，这样方便你回忆这次commit了个什么。当然你可以胡乱填写。</p>
<p>如果不写这个引号的部分，那么git会为你进入一个vim编辑界面。有个梗是“如何得到一串随机字符串？——给一个小白进入vim，让他想办法退出”，那会更难受些，vim怎么用这里就不讲了，在自己了解vim编辑之前，乖乖把备注写在同一行里吧。</p>
<p>这行执行之后，你的代码版本就被保存在了本地仓库里了（就是隐藏的<code>.git</code>里）。</p>
<p>但是gitee的服务器并不知道，想享受git云服务，那还得把你本地的仓库推到服务器上去，就是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>好了，一次完整的版本管理操作完成了。看看gitee网站上仓库的内容，已经和自己本地一致了。</p>
<p>小小总结一下：</p>
<ol type="1">
<li>下载安装git软件</li>
<li>git config 配置个人信息</li>
<li>ssh-keygen 生成私钥公钥（钥匙和锁）</li>
<li>注册gitee账号，配置gitee公钥</li>
<li>在gitee网页上建立自己的仓库</li>
<li>在仓库里复制ssh地址</li>
<li>本地git clone这个仓库</li>
<li>编辑自己的代码/文档</li>
<li><code>git add .</code></li>
<li><code>git commit -am "&lt;你的备注&gt;"</code></li>
<li><code>git push</code></li>
</ol>
<h3 id="同步自己的仓库">同步自己的仓库</h3>
<p>换一台新电脑，当然还得 <code>git clone</code> ，这不用说了。</p>
<p>而在家里和宿舍两台电脑都有了仓库，得保持一致吧。</p>
<p>宿舍里 <code>git push</code> 了，回到家，仓库还是旧版本。</p>
<p>这时候用 <code>git pull</code>，把最新的仓库从 gitee 上拉下来。</p>
<p>然后就可以正常的继续自己的工作了。</p>
<h3 id="gitignore">gitignore</h3>
<p>仓库的目录下可以建一个<code>.gitignore</code>文件，里面描述不想加入版本控制的文件。</p>
<p>比如一个写代码的仓库，你经常会编译出 <code>main.exe</code>
文件，它不需要“云同步”，不需要版本控制，而且把它推到仓库里的话，还挺占空间。</p>
<p>我们在<code>.gitignore</code>里加上<code>*.exe</code>，这样无论怎样
add commit
push，仓库里的<code>.exe</code>文件都会雷打不动地留在本地了。</p>
<p>想要有更丰富的<code>gitignore</code>方式，可以去了解一下<a
href="https://zh.wikipedia.org/wiki/%E9%80%9A%E9%85%8D%E7%AC%A6">通配符</a>以及<code>.gitignore</code>的写法。</p>
<h2 id="tortoisegit">TortoiseGit</h2>
<p>TortoiseGit是个帮助我们使用git的软件。</p>
<p>命令行恐惧症？可以额外装一个
TortoiseGit：https://tortoisegit.org/download/</p>
<p>它可以帮你用鼠标代替上面那些命令行操作，自己摸索吧。</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode使用latex</title>
    <url>/2021-03-31-vscode-latex/</url>
    <content><![CDATA[<p>进入vscode时代，sublime atom 那一套事情都打算切过来了。</p>
<span id="more"></span>
<h2 id="安装texlive">1. 安装<a
href="http://tug.org/texlive/">texlive</a></h2>
<p>官网的用户体验很不好，找iso有点迷</p>
<p>这里有提供下载镜像的汇总：<a
href="https://ctan.org/mirrors">https://ctan.org/mirrors</a></p>
<p>这个阿里云的镜像一时半会儿应该不会失效吧：<a
href="https://mirrors.aliyun.com/CTAN/systems/texlive/Images/">https://mirrors.aliyun.com/CTAN/systems/texlive/Images/</a></p>
<p>下载 <code>texlive.iso</code></p>
<p>打开iso文件，运行
<code>install-tl-windows.bat</code>，界面都看得懂，装就是了。</p>
<h2 id="vscode-安装-latex-workshop-扩展">2. vscode 安装 latex workshop
扩展</h2>
<p>vscode怎么装扩展不用赘述了</p>
<h2 id="设置里找latex栏目下的-latextools编辑settings.json">3.
设置里，找latex栏目下的
<code>Latex:Tools</code>，编辑<code>settings.json</code></h2>
<p>添加：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<h2 id="latexrecipes编辑settings.json">4.
<code>Latex:Recipes</code>，编辑<code>settings.json</code></h2>
<p>添加：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex ➞ bibtex ➞ xelatex × 2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>可以把latexmk的三条注释掉</p>
<p>要想使用bibtex参考文献，需要“四次编译”，可以设为默认，把<code>"xelatex ➞ bibtex ➞ xelatex × 2"</code>挪到前面。</p>
<h2 id="一些快捷键">一些快捷键</h2>
<ul>
<li>ctrl+alt+b：编译</li>
<li>ctrl+鼠标点击pdf：可跳至源码位置</li>
<li>在源码位置ctrl+alt+j可跳至pdf位置</li>
<li>ctrl+k ctrl+a： 切换活动栏可见性(左侧图标开关)</li>
<li>ctrl+alt+x：显示LaTeX面板(左侧编译命令面板和文档大纲)。</li>
<li>ctrl+alt+c：清除辅助文件</li>
<li>ctrl+alt+v：查看编译的pdf文件(预览)</li>
<li>ctrl+alt+j：正向搜索。当设置<code>"latex-workshop.view.pdf.viewer": "tab";</code>时，在LaTeX源文件中按下快捷键，定位到PDF文档相应位置。</li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>基于vscode与mingw配置c++环境（ACM向）</title>
    <url>/2021-03-31-vscode-mingw-acm/</url>
    <content><![CDATA[<p>本篇博客与<a
href="/2021-03-31-vscode-wsl-acm/">基于vscode与wsl配置c++环境（ACM向）</a>
联动。</p>
<p>MinGW 相对 wsl 而言，小白使用更方便。</p>
<span id="more"></span>
<p>注：在windows环境使用powershell，所以一些地方与基于 wsl
的配置语法不一样。</p>
<h3 id="mingw">MinGW</h3>
<p>安装mingw应该不难。小白可以简单粗暴地下载 <a
href="https://www.codeblocks.org/downloads/binaries/">codeblocks</a>-MinGW-nosetup
版本，解压后就有个 MinGW 目录</p>
<p>这里给个当前版本的SourceForge<a
href="https://sourceforge.net/projects/codeblocks/files/Binaries/20.03/Windows/codeblocks-20.03mingw-nosetup.zip/download">下载链接</a></p>
<blockquote>
<p>都下载codeblocks了还用vscode干嘛？<br />
之前我也这么想的，直到发现确实有人更想要vscode的界面与字体与配色，codeblocks配置半天还是没vscode养眼。</p>
</blockquote>
<p>配置系统环境变量 path，添加 <code>xxx/xxx/MinGW/bin</code></p>
<p>检查是否配置好，新打开powershell或cmd，<code>gcc -v</code>
有版本信息就是配好了。</p>
<h3 id="目录设定">目录设定</h3>
<p>vscode 打开工作目录，比如
<code>E:\cpp\localcpp</code>，在此目录下新建一个<code>workspace</code></p>
<p>最后的目录结构会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| .vscode           // vscode的配置文件，下文的tasks.json、launch.json都在这里</span><br><span class="line">| workspace         // 自己的工作目录</span><br><span class="line">| --| build         // 编译的结果会在这个目录</span><br><span class="line">| --| main.cpp      // 主文件</span><br><span class="line">| otherfolder       // 如果做成git仓库，可以这里归档自己的代码</span><br><span class="line">| .gitignore        // git仓库忽略的文件，可以忽略 .vscode 和 workspace 这两个目录</span><br></pre></td></tr></table></figure>
<h3 id="tasks.json"><code>tasks.json</code></h3>
<p>打开一个cpp文件，菜单的 Terminal（F1）打开
<code>Configure Default Build Task...</code>，选择g++ build active
file</p>
<p>自动生成tasks.json，修改如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: g++.exe gen&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;New-Item -ItemType Directory -Force -Path $&#123;workspaceFolder&#125;/workspace/build | Out-Null; g++ $&#123;file&#125; -g -o $&#123;workspaceFolder&#125;/workspace/build/$&#123;fileBasenameNoExtension&#125;.exe; cd $&#123;workspaceFolder&#125;/workspace/build/; .\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$gcc&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++ debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;New-Item -ItemType Directory -Force -Path $&#123;workspaceFolder&#125;/workspace/build | Out-Null; g++ $&#123;file&#125; -g -o $&#123;workspaceFolder&#125;/workspace/build/$&#123;fileBasenameNoExtension&#125;.exe;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$gcc&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="launch.json"><code>launch.json</code></h3>
<p>菜单的 Run 打开 <code>Add Configuration...</code> 选择
<code>C++ (GDB/LLDB)</code></p>
<p>自动生成<code>launch.json</code>，修改如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb start&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/workspace/build/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++ debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用">使用</h3>
<p><code>ctrl+shift+b</code>
编译+运行，在vscode下方的terminal里进行数据交互</p>
<p><code>f5</code>
debug，也在terminal里。其它debug快捷键点菜单的Run查看。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>基于vscode与wsl配置c++环境（ACM向）</title>
    <url>/2021-03-31-vscode-wsl-acm/</url>
    <content><![CDATA[<p>本文基于 wsl1 配置，wsl2 暂未试过。</p>
<p>参考vscode官方基于wsl cpp环境配置： <a
href="https://code.visualstudio.com/docs/cpp/config-wsl">https://code.visualstudio.com/docs/cpp/config-wsl</a></p>
<span id="more"></span>
<p>首先设定一下自己的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| .vscode           // vscode的配置文件，下文的tasks.json、launch.json都在这里</span><br><span class="line">| workspace         // 自己的工作目录</span><br><span class="line">| --| build         // 编译的结果会在这个目录</span><br><span class="line">| --| main.cpp      // 主文件</span><br><span class="line">| otherfolder       // 如果做成git仓库，可以这里归档自己的代码</span><br><span class="line">| .gitignore        // git仓库忽略的文件，可以忽略 .vscode 和 workspace 这两个目录</span><br></pre></td></tr></table></figure>
<p>安装vscode、wsl，vscode的file菜单勾上 <code>Auto Save</code></p>
<p>vscode 安装 WSL扩展、C/C++扩展（in wsl）</p>
<p>让vscode进入wsl状态（左下角点击后选择），建立一个工作目录并让vscode打开该工作目录。</p>
<h3 id="build-配置">build 配置</h3>
<p>打开一个cpp文件，菜单的 Terminal 打开
<code>Configure Default Build Task...</code>，选择<code>g++ build active file</code></p>
<p>自动生成<code>tasks.json</code>，修改如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;start g++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mkdir -p $&#123;workspaceFolder&#125;/workspace/build &amp;&amp; g++ $&#123;file&#125; -g -o $&#123;workspaceFolder&#125;/workspace/build/$&#123;fileBasenameNoExtension&#125; &amp;&amp; $&#123;workspaceFolder&#125;/workspace/build/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$gcc&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++ debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mkdir -p $&#123;workspaceFolder&#125;/workspace/build &amp;&amp; g++ $&#123;file&#125; -g -o $&#123;workspaceFolder&#125;/workspace/build/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$gcc&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里把指令直接写在一行里了。</p>
<p>把相似的内容写了两遍，主要是第二个task用于debug的<code>launch.json</code>去调用。被调用的task省去了直接运行这一步，这样才能正常进入debug</p>
<p>设置了<code>isDefault</code>，则<code>Ctrl+Shift+B</code>就直接执行这个配置的build了。</p>
<p>这里指令全塞进配置里太长，也可以写成 “build and run”
脚本，在<code>workspace</code>下建立<code>build_script.sh</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$1</span>/build &amp;&amp; \</span><br><span class="line">g++ <span class="variable">$2</span> -g -o <span class="variable">$1</span>/build/<span class="variable">$3</span> &amp;&amp; \</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$1</span>/build/ &amp;&amp; \</span><br><span class="line">./<span class="variable">$3</span></span><br></pre></td></tr></table></figure>
<p>这里用“cd”
是保证工作目录在build里，方便读写<code>test.in</code>、<code>test.out</code>等文件。</p>
<p>然后用<code>task.json</code>的 command + args
调用（替换第一个task的两个地方）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/workspace/build_script.sh&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$&#123;workspaceFolder&#125;/workspace&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>此时就可以<code>Ctrl+Shift+B</code>执行cpp了</p>
<p>（其实Run菜单里会发现 ctrl+f5 可以 Run Without
Debugging，或许不配这一坨也行？）</p>
<h3 id="debug-配置">debug 配置</h3>
<p>wsl中安装gdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gdb</span><br></pre></td></tr></table></figure>
<p>菜单的 Run 打开 <code>Add Configuration...</code> 选择
<code>C++ (GDB/LLDB)</code></p>
<p>自动生成<code>launch.json</code>，修改如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;run g++ debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/workspace/build/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++ debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里<code>preLaunchTask</code>要与 <code>tasks.json</code>的
<code>label</code> 对应，也就是对应了不带运行指令的task。</p>
<h3 id="使用新的-c-特性">使用新的 C++ 特性</h3>
<p>F1 菜单搜索选择
<code>C/C++: Edit Configurations (UI)</code>，会生成一个<code>c_cpp_properties.json</code>文件，可以把</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++14&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="debug的glibc问题">debug的glibc问题</h3>
<h4 id="安装-glibc">1. 安装 glibc</h4>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">sudo apt install glibc-source</span><br><span class="line">cd /usr/src/glibc/</span><br><span class="line">sudo tar -xvf glibc-*.tar.xz</span><br></pre></td></tr></table></figure>
<h4 id="在-vscode-文件夹下的launch.json中添加以下内容">2. 在 VSCode
文件夹下的<code>launch.json</code>中添加以下内容：</h4>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;sourceFileMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;/build/glibc-xxxxx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/src/glibc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>修改 xxxxx 为报错提示中出现的glibc文件名:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;sourceFileMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;/build/glibc-ZN95T4&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/src/glibc&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用">使用</h3>
<p><code>ctrl+shift+b</code>
编译+运行，在vscode下方的terminal里进行数据交互</p>
<p><code>f5</code>
debug，也在terminal里。其它debug快捷键点菜单的Run查看。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>联邦学习初理解</title>
    <url>/2021-04-05-federated-learning-start/</url>
    <content><![CDATA[<blockquote>
<p>开头一段是故事，可跳过看正文</p>
</blockquote>
<p>几年前师兄让我研究一下为深度学习训练提供云服务时，如何解决用户的数据隐私顾虑，精度允许有损耗。</p>
<p>当时一腔热血展开调研，对着CNN结构苦思冥想，不给数据怎么训练？给了数据怎么隐私？</p>
<p>然后顺理成章的钻进了数据加密的死胡同。原想着“加密-&gt;训练-&gt;解密”做成端到端或许行得通，跑了一波实验只能得到雪花点。发现一个无比牛叉的发明——同态加密，啃了好几天终于略有些理解，却是框架难实现、模型难收敛、图像难处理。</p>
<p>在同态加密的死胡同里挣扎了一番，还是数学能力不足放弃了，感觉是个无解的问题。</p>
<p>今年突然发现了“联邦学习”这个名词，科研界与工业界早已炒得火热，第一反应就是“啊？这样训练也能用？也能刷论文？也能做产品？”</p>
<p>好吧感觉这么多年还是不够懂科研。想起那个水笔的故事——墨水只能灌那么高，再高会漏墨，怎么办呢，把笔芯就生产成那么高墨水的就好了，完全能用啊。</p>
<p>如今坑都填差不多了，剩下的要么是人不想做的，要么是无比难搞的。</p>
<p>这世上精明人那么多，哪有那么多舒服的方向给你。而且也给过你机会了。</p>
<p>静下心来不要挑三拣四，总能做出点东西。</p>
<span id="more"></span>
<h2 id="联邦学习是什么">联邦学习是什么</h2>
<p>大数据时代，数据为王，机器学习模型或好或坏，丢几十T数据进去，都能给你练出个NB模型，预测用户习惯，精准推送文章、商品、广告，换来的都是流量，都是真金白银。</p>
<p>可用户不开心啊，我的聊天记录，我的朋友圈，我的联系人列表，都是我的隐私，你凭什么拿去机器学习。感到被监控，感到可怕...</p>
<p>好的，法律来了，国内外都有，保护用户隐私。</p>
<p>互联网公司郁闷了，这可咋整。</p>
<p>好好好，不拿你数据了，借你手机cpu用你自己的数据跑几个特征值给我，我看不到你的隐私，还依然给你提供智能的自动化服务，双赢，如何。</p>
<p>联邦学习的雏形就这么来了，比较典型的开始是谷歌2016年预测Android设备文本输入的模型训练中，保持数据在设备本地，服务器只收集设备按机器学习算法求出的局部梯度，通过服务器合并，在数学上逼近全局训练效果的计算方案。</p>
<p>再往后，更丰富的需求和方案也来了：</p>
<ul>
<li>不同的企业都有数据，合在一起训练的模型不是更好。但是数据都是钱啊，凭什么给。互换数据？问问我的用户答应不答应。</li>
<li>不同的部门有同一批用户的不同方面的数据，银行有存款信息，医院有病例信息，结合起来可以有更完整的用户模型，但是...</li>
</ul>
<p>要么是部门财产，要么是用户隐私，反正数据都拿出来一起跑个好模型的乌托邦是不存在的。</p>
<p>机器学习一般把数据看作一个一个的包含多个特征值的数据，一个放一行的话，可以放进一个Excel表格里，一行是一个数据，每列是数据的一个特征值。</p>
<p>那么</p>
<ul>
<li>横向联邦学习：不同企业的数据是不同的行，他们可能包含了不同的类别，把这些数据以联邦学习的方式训练联合模型，会支持更丰富的类别或更好的分类泛化性能。</li>
<li>纵向联邦学习：不同部门的数据是不同的列，即每个数据都包含了用户重叠或不重叠的若干特征，以联邦学习的方式训练联合模型，会基于更多的特征给出更精准的结果。</li>
</ul>
<h2 id="联邦学习研究些什么">联邦学习研究些什么</h2>
<h3 id="通讯成本高">通讯成本高</h3>
<p>不是本地一个GPU从硬盘里拿了就训练，而是要各个终端频繁地发送梯度信息，下载模型更新信息。</p>
<p>在保证相同模型精度前提下，考虑减少通讯次数、模型更新时间等</p>
<h3 id="统计学异质性statistical-heterogeneity">统计学异质性（Statistical
Heterogeneity）</h3>
<p>这词也没找到官方翻译，说“异构性”感觉格局小了。。其实单词直译看起来还不错。</p>
<p>这个问题在普通机器学习中就有，比如训练mnist
<code>0</code>到<code>9</code>的手写数字识别，如果加入训练的数据是一堆<code>0</code>，然后一堆<code>1</code>，然后...，在训练完一堆<code>9</code>之后，你会发现模型可能预测啥都是<code>9</code>。每堆数据的分布是不一样的。</p>
<p>那怎么办？传统机器学习把数据<strong>随机打乱</strong>一下就好了。这样你随便拿起“一堆”数据，他们就会有个统计学分布（比如画个柱状图统计不同数字个数）。不同“堆”得到的分布都很接近。</p>
<p>按概率论说，每次随便拿起一个数字是几的概率是相互独立的，即先拿起一个数是<code>0</code>，不会影响再拿起一个数是几的概率。</p>
<p>又分布接近，又相互独立，嗯，独立同分布（Independent and Identically
Distributed，IID），这样的数据，才能在机器学习的熔炉里均衡地炼出较靠谱的解。</p>
<p>那前面扎堆的<code>0</code>、扎堆的<code>1</code>...扎堆的<code>9</code>就是非独立同分布了（Non-IID）。</p>
<p>传统机器学习可以随机打乱，但联邦学习我们没法把数据集合在一起处理，你的手机里全是<code>0</code>，我的手机里全是<code>1</code>，麻烦就大了。</p>
<p>再者，手机运算速度、网络环境、网络波动，都给不同方向传给服务器的数据带来各种不确定性，归根到底都影响了数据的分布。</p>
<p>所以联邦学习最大的困难就是悬丝诊脉，哦不，是碰不到数据还要依赖数据的分布。</p>
<h3 id="数据安全">数据安全</h3>
<p>既然要数据隐私，那这要考虑的就太多了，数据怎么不泄露？即使不发数据，发的信息会不会足够猜到数据本身是什么？</p>
<p>如果要依赖“大”数据，往服务器发信息的终端一定都是“善良”的吗？</p>
<p>任何事情牵扯到互联网，环节就会非常多，数据发送、接收、模型聚合、下发，都要顾虑一个安全问题，隐私安全，模型安全，数据安全...</p>
<h3 id="应用落地">应用落地</h3>
<p>有理论不一定能用，把理论用起来产生经济价值也有一系列要解决的问题。</p>
<h3 id="需求与优化">需求与优化</h3>
<p>异步训练？模型验证？无监督？区块链？...</p>
<h2 id="我想做点什么">我想做点什么</h2>
<p>统计学异质性是个老话题，哪怕是在联邦学习中。如前文所说，好填的坑都被人填完了，难啃的骨头啃一啃吧，总有些能改进的地方，对应用落地还是有些帮助。</p>
<hr />
<h2 id="参考">参考</h2>
<ul>
<li>[1] YANG Q, LIU Y, CHEN T, et al. Federated machine learning:
Concept and applications[J]. ACM Trans. Intell. Syst. Technol., 2019,
10(2): 12:1­12:19.</li>
<li>[2] LI T, SAHU A K, TALWALKAR A, et al. Federated learning:
Challenges, methods, and future directions[J]. IEEE Signal Processing
Magazine, 2020, 37: 50­60.</li>
<li>[3] LI L, FAN Y, TSE M, et al. A review of applications in federated
learning[J]. Computers &amp; Industrial Engineering, 2020, 149:
106854.</li>
<li>[4] LI T, SAHU A K, ZAHEER M, et al. Federated optimization in
heterogeneous networks [C]//DHILLON I S, PAPAILIOPOULOS D S, SZE V.
Proceedings of Machine Learning and Systems 2020, MLSys 2020, Austin,
TX, USA, March 2­4, 2020. mlsys.org, 2020.</li>
</ul>
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Federated Learning</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>试证KMP计算循环节方法</title>
    <url>/2021-04-27-try-to-prove-loop-by-kmp/</url>
    <content><![CDATA[<ol type="1">
<li>给一个字符串，求最短循环节，如<code>abcabcabcabc</code>循环节为<code>abc</code></li>
<li>给一个字符串，求在末尾最少补多少字母后成为一个有循环节的字符串，如<code>abcabca</code>需要补充<code>bc</code></li>
</ol>
<span id="more"></span>
<p>数据结构课程在string章节的实验课，多半会有循环节这道题，或许蒙的猜的或许课堂讲的，大多人会发现
<code>strLen - next[strLen]</code>
就是最短循环节的长度，无论是上述问题<code>1</code>还是问题<code>2</code>，都能求出循环节长度为<code>3</code>，即<code>abc</code></p>
<p>但总觉得哪里怪怪的，大家都默认这样正确，在网上却不太容易找到一个严谨的证明。这篇博客试着证明一下，当然依然是非数学的，期望更容易读懂。</p>
<p>我们知道KMP算法的next数组是由“最长相等前后缀”推得的，<code>strLen - next[strLen]</code>
其实就是“字符串长度”减去“整串最长相等前后缀长度”后的长度，循环节即这个长度的前缀，这里我们就是要证明：</p>
<p><strong><code>strLen - next[strLen]</code>
是字符串最短循环节的长度</strong></p>
<p>一个字符串的最长相等前后缀，有两种情况：</p>
<p>情况<code>1</code>：最长相等前后缀重叠</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mmmmmmmmmmmmmm---</span><br><span class="line">---mmmmmmmmmmmmmm</span><br><span class="line">0  j         k  l</span><br></pre></td></tr></table></figure>
<p>这里 m 表示相匹配的串</p>
<p>情况<code>2</code>：不重叠</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mmmmm------------</span><br><span class="line">------------mmmmm</span><br><span class="line">0   k       j   l</span><br></pre></td></tr></table></figure>
<p>对于情况<code>1</code>和情况<code>2</code>，又分别有
<strong>循环刚好填满</strong> ，和 <strong>循环未填满需要补充</strong>
的情况。</p>
<h2
id="情况1最长相等前后缀重叠-且-循环节填满">情况<code>1</code>最长相等前后缀重叠
<strong>且</strong> 循环节填满</h2>
<p>这里用 <code>[0,k] == [j,l]</code> 表示 <code>0~k</code> 的字符与
<code>j~l</code> 的字符顺序一一匹配，<code>[]</code>表示闭区间。</p>
<p>显然<code>[0,j) == [j,j+j)</code>，即最长相等前后缀之间，“前缀的前缀”肯定与“后缀的前缀”相匹配。这里<code>)</code>表示右侧开区间，用<code>M</code>来表示这个情况。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MMMmmmmmmmmmmmm---</span><br><span class="line">---MMMmmmmmmmmmmmm</span><br><span class="line">0  j          k  l</span><br></pre></td></tr></table></figure>
<p>而<code>[j,j+j) == [j+j,j+j+j)</code>
也是成立的，最长相等前后缀之间，前缀的任意一段，等于后缀对应位移的那段，这里用<code>P</code>来表示</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MMMPPPmmmmmmmmm---</span><br><span class="line">---MMMPPPmmmmmmmmm</span><br><span class="line">0  j          k  l</span><br></pre></td></tr></table></figure>
<p>而显然，后缀的<code>MMM</code>和前缀的<code>PPP</code>是同一个区间，都是<code>[j,j+j)</code>，后缀的<code>PPP</code>又和前缀的<code>PPP</code>之后的长度为<code>j</code>的区间是同一个区间，可以连锁反应下去，直到字符串最后</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MMMPPPOOOmmmmmm---</span><br><span class="line">---MMMPPPOOOmmmmmm</span><br><span class="line">0  j          k  l</span><br></pre></td></tr></table></figure>
<h2
id="情况1最长相等前后缀重叠-但-循环节-未-填满">情况<code>1</code>最长相等前后缀重叠
<strong>但</strong> 循环节 <strong>未</strong> 填满</h2>
<p>可能会是这个样子</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mmmmmmmmmmmmm---</span><br><span class="line">---mmmmmmmmmmmmm</span><br><span class="line">0  j        k  l</span><br></pre></td></tr></table></figure>
<p>看起来没什么区别？其实就是长度不能整除这个假定的循环节了。</p>
<p>连锁反应还和刚才一样，最后能得到：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MMMPPPOOOAAAm---</span><br><span class="line">---MMMPPPOOOAAAm</span><br><span class="line">0  j        k  l</span><br></pre></td></tr></table></figure>
<p>到这里，连锁还可以继续，后缀的<code>AAA</code>对应前缀的那段依然是循环，用<code>BBB</code>表示</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MMMPPPOOOAAABBB-</span><br><span class="line">---MMMPPPOOOAAAm</span><br><span class="line">0  j        k  l</span><br></pre></td></tr></table></figure>
<p>最后剩下的这个字符（或若干字符）</p>
<ul>
<li>是后缀的末尾，那必然也与前缀的末尾匹配 ==&gt;</li>
<li>现在前缀已经被循环串填满了，所以前缀的末尾必然是循环串的一个开头
==&gt;</li>
<li>则后缀的末尾（也是字符串的末尾）也是循环串的一个开头</li>
</ul>
<h2
id="情况2最长相等前后缀-不-重叠-且-循环节填满">情况<code>2</code>最长相等前后缀
<strong>不</strong> 重叠 <strong>且</strong> 循环节填满</h2>
<p>循环节填满字符串的话，是不可能出现情况<code>2</code>的</p>
<p>循环两次时：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">AAAA----</span><br><span class="line">----BBBB</span><br></pre></td></tr></table></figure>
<p>最长相等前后缀是挨着的，用情况<code>1</code>的连锁反应即可</p>
<p>循环大于两次时：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">AAAACCCC----</span><br><span class="line">----BBBBCCCC</span><br></pre></td></tr></table></figure>
<p>必然重叠</p>
<h2
id="情况2最长相等前后缀-不-重叠-但-循环节-未-填满">情况<code>2</code>最长相等前后缀
<strong>不</strong> 重叠 <strong>但</strong> 循环节 <strong>未</strong>
填满</h2>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">mmmmm------------</span><br><span class="line">------------mmmmm</span><br><span class="line">0   k       j   l</span><br></pre></td></tr></table></figure>
<p>按照公式，即总长度减去最长相等前后缀长度，循环节应该是<code>[0,j)</code>，用<code>M</code>表示为</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MMMMMMMMMMMM-----</span><br><span class="line">------------mmmmm</span><br><span class="line">0   k       j   l</span><br></pre></td></tr></table></figure>
<p>它当作需要补齐的循环节，是符合要求的。但是否是“最小循环节”呢？</p>
<p><strong>反证</strong> 一下，假设有更短循环节<code>P</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">PPPmm------------</span><br><span class="line">------------mmmmm</span><br><span class="line">0   k       j   l</span><br></pre></td></tr></table></figure>
<p>那么，我们得到的KMP匹配结果，将会是</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">PPPAAABBBCCCDD---</span><br><span class="line">---PPPAAABBBCCCDD</span><br><span class="line">0   k       j   l</span><br></pre></td></tr></table></figure>
<p>这是情况<code>1</code>而不是情况<code>2</code>了，产生矛盾，故不存在更小的循环节<code>P</code>。</p>
<h2 id="小结">小结</h2>
<p>几种情况都已处理完，这样可以更感性地认知<code>strLen - next[strLen]</code>为循环节长度的意义了。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>凸优化初步了解</title>
    <url>/2021-04-24-understanding-of-convex-optimization/</url>
    <content><![CDATA[<p>凸优化是个大话题，常见却又从未系统去理解，这里做一些初步了解。</p>
<span id="more"></span>
<h2 id="优化optimization">优化（optimization）</h2>
<p>机器学习的大部分事情，就是把任务建模成一个优化问题：</p>
<p><span class="math display">\[
\min_{x\in D} f(x)
\]</span></p>
<p>用高中数学的用词来讲，就是让 <span class="math inline">\(x\)</span>
在定义域 <span class="math inline">\(D\)</span> 上找到特定位置，使 <span
class="math inline">\(f(x)\)</span> 达到最小值。</p>
<p>机器学习中，我们通常用梯度下降、牛顿迭代等方法来找最优解，也就是利用函数的导数，或数据的梯度，来迭代地找到达到最优解的优化变量的位置。</p>
<p>我们曾经学函数的时候直到，可以利用“导数=0”来求最大或最小值，也知道对于一些函数，这个方法是不适用的，比如三次函数，拐点梯度为0但并不是最大或最小值。显然，二次函数的形状是“凸的”，三次函数则不是。</p>
<p>如果机器学习中的问题能够适用“梯度为0则为最优解”，或问题可以转换成适用的问题，那么优化问题就会变简单。那么我们可以对问题做限定：</p>
<ol type="1">
<li>函数是凸函数</li>
<li>优化变量的可行域是凸集</li>
</ol>
<h2 id="凸集">凸集</h2>
<p>通过二次函数与三次函数，凸函数还算容易理解。那么凸集是什么呢？</p>
<p>对于<code>n</code>维空间集合<code>D</code>中任意两点 <span
class="math inline">\(p_{1}\)</span> 与 <span
class="math inline">\(p_{2}\)</span> ， 对 <span
class="math inline">\(\theta \in [0, 1]\)</span> 都有</p>
<p><span class="math display">\[
\theta p_{1} + (1-\theta)p_{2} \in D
\]</span></p>
<p>则该集合<code>D</code>是凸集。</p>
<p>也比较显而易见，用二维空间理解的话，就是没有洞也没有凹槽。</p>
<p>显然在不加约束的情况下，任意维度空间都满足上面公式，即都是凸集。</p>
<p>那么如果作为一个课程，就可以出不少有意思的考试题了：给不同类型的约束，证明约束下的可行域是否是凸集。</p>
<p>比如线性规划：如果每条直线都取一侧作为可行域，一系列直线的交集肯定是个凸集。</p>
<ul>
<li>多个凸集的交集也是凸集</li>
<li>线性等式约束可行域是凸集</li>
</ul>
<h2 id="凸函数">凸函数</h2>
<p>在定义域内，任意两点 <span class="math inline">\(p_{1}\)</span> 与
<span class="math inline">\(p_{2}\)</span> ，都满足</p>
<p><span class="math display">\[
f(\theta p_{1} + (1 - \theta)p_{2}) \leq \theta f(p_{1}) + (1 -
\theta)f(p_{2})
\]</span></p>
<p>则 <code>f</code> 是凸函数。</p>
<p>当然，实际问题中往往不那么直观，就会有更多数学工具与方法来证明函数凸性，比如海瑟矩阵是否正定等等，读研时候学过，早忘一干二净了。。。</p>
<h2 id="凸优化">凸优化</h2>
<p>如果一个最优化问题的可行域是凸集，并且目标函数是凸函数，则该问题为凸优化问题。</p>
<p>证明一个优化问题是凸优化，就从以上内容着手，证明凸函数一般就证明海瑟矩阵半正定，证明可行域是凸集就可以利用许多已有的结论。凸优化的通用写法是</p>
<p><span class="math display">\[
\min f(x) \\
g_{i} (x) \leq 0, i = 1, ..., m \\
h_{i} (x) = 0, i = 1, ..., p
\]</span></p>
<p>很多地方见到这么写，就是不解释 g、h
是什么，急死个人，对小白很不友好。</p>
<p>这里 <span class="math inline">\(g_{i}(x)\)</span>
是不等式约束函数，为凸函数。</p>
<p><span class="math inline">\(h_{i} (x)\)</span>
是等式约束函数，为仿射函数，仿射函数即相对于线性函数而言，
<code>Ax+b</code>
是线性函数，<code>Ax</code>即仿射函数，可以理解为“穿过原点”。</p>
<p>这是用了前面说的凸集中被证明的结论：凸集的交集是凸集，线性等式约束的可行域是凸集，那么就可以用这两点来描述一个更具体的凸优化，分别对应
<span class="math inline">\(g\)</span> 函数集合与 <span
class="math inline">\(h\)</span> 函数集合。</p>
<h2 id="局部最优与全局最优">局部最优与全局最优</h2>
<p>目标函数是凸函数、优化变量的可行域是凸集，这两个条件缺其中任何一个都不能保证局部最优解是全局最优解。</p>
<p>也即两者都满足才是凸优化问题，而凸优化问题可以放心地找局部最优，同时也就找到了全局最优。</p>
<p>证明过程也不十分复杂，这里就不照搬资料了。</p>
<h2 id="求解">求解</h2>
<p>梯度下降、牛顿法、拟牛顿法这些研究生课也学过，现在竟不记得那门课叫什么名字，只记得是数学院的老师讲的，十分受用。</p>
<p>难者不会，会者不难。非本篇文章重点，这里掠过。</p>
<p>各种各样的机器学习方法，大都也是在梯度下降的思想上设计的。支持向量机、逻辑回归等等等等。就想起当时老师说：</p>
<blockquote>
<p>模拟退火、遗传算法这些随机算法都发不了什么好期刊了，因为它们不“数学”，收敛靠概率，不能数学地证明收敛时间。而梯度下降、拟牛顿法等等是基于数据梯度方向的，可以严谨地证明收敛性和收敛时间。</p>
</blockquote>
<h2 id="小结">小结</h2>
<p>不求甚解地了解了一下凸优化，背后的数学优美而复杂，而浅尝辄止地理解一下概念未尝不可。</p>
]]></content>
  </entry>
  <entry>
    <title>基尔霍夫矩阵-矩阵树定理</title>
    <url>/2021-06-18-Kirchhoff/</url>
    <content><![CDATA[<p>求一个图的生成树个数</p>
<span id="more"></span>
<p>一个图的生成树个数是其基尔霍夫矩阵任意主余子式的值。</p>
<p>基尔霍夫矩阵： - <span class="math inline">\(D_{ii}\)</span>:
Degree(i) - <span class="math inline">\(D_{ij}\)</span>: i 到 j
的边数取负数</p>
<p>对于 n 阶矩阵，去掉任意的第 R 行 R 列，求剩下的 n-1
阶行列式的绝对值即最小生成树个数。</p>
<p>根据题目特点，可利用特殊数据推出行列式结果，数据范围允许时可按照行列式性质计算行列式。</p>
<p>例如一个图：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1---2</span><br><span class="line">|  /|</span><br><span class="line">| / |</span><br><span class="line">|/  |</span><br><span class="line">3---4</span><br></pre></td></tr></table></figure>
<p>其基尔霍夫矩阵为：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">    (1) (2) (3) (4)</span><br><span class="line">(1)  2  -1  -1   0 </span><br><span class="line">(2) -1   3  -1  -1</span><br><span class="line">(3) -1  -1   3  -1</span><br><span class="line">(4)  0  -1  -1   2</span><br></pre></td></tr></table></figure>
<p>去掉第 4 行第 4 列为：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">    (1) (2) (3)</span><br><span class="line">(1)  2  -1  -1 </span><br><span class="line">(2) -1   3  -1 </span><br><span class="line">(3) -1  -1   3 </span><br></pre></td></tr></table></figure>
<p>计算行列式得 8，所以这个图有 8 种生成树。</p>
<p>对有向图，还可以计算内向树与外向树，内向树指树上的边由子结点指向父节点，让
<span class="math inline">\(D_{ii}\)</span>
表示入度即可。外向树反之。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
        <tag>GraphTheory</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元</title>
    <url>/2021-06-07-MultiplicativeInverse/</url>
    <content><![CDATA[<p>乘法逆元的定义及用途，以及求逆元的三种算法：扩展欧几里得、费马小定理、递推求逆元。</p>
<span id="more"></span>
<h3 id="乘法逆元">乘法逆元</h3>
<p>首先，数学上的乘法逆元就是指直观的倒数，即 <span
class="math inline">\(a\)</span> 的逆元是 <span
class="math inline">\(\frac{1}{a}\)</span>，也即与 <span
class="math inline">\(a\)</span> 相乘得 1 的数。<span
class="math inline">\(ax=1\)</span>，则<span
class="math inline">\(x\)</span>是<span
class="math inline">\(a\)</span>的乘法逆元。</p>
<p>这里我们讨论关于取模运算的乘法逆元，即对于整数 <span
class="math inline">\(a\)</span>，与 <span
class="math inline">\(a\)</span> 互质的数 <span
class="math inline">\(b\)</span> 作为模数，当整数 <span
class="math inline">\(x\)</span> 满足 <span class="math inline">\(ax
\bmod b \equiv 1\)</span> 时，称 <span class="math inline">\(x\)</span>
为 <span class="math inline">\(a\)</span> 关于模 <span
class="math inline">\(b\)</span>
的逆元，代码表示就是<code>a * x % b == 1</code>。</p>
<p>在算法竞赛中，经常会遇到求解数据很大，则输出模 <span
class="math inline">\(10^{9}+7\)</span>
的解这类要求。加法、减法、乘法等操作，基于同余理论直接取模即可。但遇到除法时，某步中间结果不一定能完成整除，就无法求解了。</p>
<p>举个例子：求<code>3 * 6 / 3</code> 对 <code>7</code>
取模的结果。我们直接算出<code>3 * 6 / 3</code>的结果是<code>6</code>，对<code>7</code>取模得最终答案是
<strong><code>6</code></strong> 。</p>
<p>但我们通常面对的问题是中间结果超过<code>int</code>甚至<code>long long</code>
的范围，而不得不在每一步基于同余理论取模，我们用这个例子尝试一下：</p>
<p>还是求 <code>3 * 6 / 3 % 7</code></p>
<p>第一步：<code>3 * 6 == 18</code>，<code>18 % 7 == 4</code></p>
<p>第二步：<code>4</code> 这个中间结果再做 <code>4 / 3</code>
无法整除，就无法进行下去了。</p>
<p>但我们可以求出除数 <code>3</code> 关于模数<code>7</code>的逆元
<code>5</code>（根据逆元定义，<code>5</code> 符合
<code>3 * 5 % 7 == 1</code>），从而，用乘以<code>5</code>代替除以<code>3</code>。</p>
<p>上述第二步除法变乘法：
<code>4 * 5 == 20</code>，<code>20 % 7 == 6</code></p>
<p>从而也计算出了正确的结果 <strong><code>6</code></strong> 。</p>
<p>乘法逆元的作用就是：</p>
<p>设 <span class="math inline">\(m\)</span> 是一个很大的数，<span
class="math inline">\(a\)</span>、<span
class="math inline">\(b\)</span>已知，预期要计算（假设答案为 <span
class="math inline">\(c\)</span>）：</p>
<p><span class="math display">\[
m / a \bmod b
\]</span></p>
<p>对于 <span class="math inline">\(a\)</span> 的逆元 <span
class="math inline">\(d\)</span>，能够满足</p>
<p><span class="math display">\[
m \cdot d \bmod b = m / a \bmod b = c
\]</span></p>
<p>在有些问题中，无法计算最终值很大的 <span
class="math inline">\(m\)</span> ，只能得到基于同余的一个中间值 <span
class="math inline">\(m \bmod b = e\)</span> 来计算 <span
class="math inline">\(e / a \bmod b\)</span> ，而 <span
class="math inline">\(e\)</span> 可能无法整除 <span
class="math inline">\(a\)</span>，就可以用 <span
class="math inline">\(a\)</span> 的逆元 <span
class="math inline">\(d\)</span>，来计算 <span class="math inline">\(e
\cdot d \bmod b\)</span>。</p>
<p>故而我们需要一个算法求 <strong>除数</strong> 的
<strong>取模逆元</strong>
，从而在四则运算取模的任务中，用逆元将除法转为乘法。</p>
<h3 id="方法1扩展欧几里得">方法1：扩展欧几里得</h3>
<p>先暂时将逆元的事放一放，来看下扩展欧几里得。</p>
<p>首先大多入门选手知道求两个数最大公约数的算法，即辗转相除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? <span class="built_in">GCD</span>(b, a % b) : a&#125;</span><br></pre></td></tr></table></figure>
<p>扩展欧几里得算法则是求 <span class="math inline">\(ax + by = GCD(a,
b)\)</span> 的一组可行解:</p>
<p>设两个式子</p>
<p><span class="math display">\[
ax + by=GCD(a, b)
\]</span></p>
<p><span class="math display">\[
bx&#39; + (a \bmod b)y&#39;=GCD(b, a \bmod b)
\]</span></p>
<p>由欧几里得算法知 <span class="math inline">\(GCD(a, b) = GCD(b, a
\bmod b)\)</span></p>
<p>所以</p>
<p><span class="math display">\[
ax + by = bx&#39; + (a \bmod b)y&#39;
\]</span></p>
<p>而</p>
<p><span class="math display">\[
a \bmod b = a - kb
\]</span></p>
<p>其中 <span class="math inline">\(k = \left \lfloor a / b \right
\rfloor\)</span>，<span class="math inline">\(\lfloor
\rfloor\)</span>表示向下取整。</p>
<p>所以有</p>
<p><span class="math display">\[
ax + by = bx&#39; + (a - kb)y&#39;
\]</span></p>
<p>展开移项得：</p>
<p><span class="math display">\[
ax + by = ay&#39; + b(x&#39;-ky&#39;)
\]</span></p>
<p>根据系数对应关系，可以设</p>
<p><span class="math inline">\(x = y&#39;\)</span>、<span
class="math inline">\(y = x&#39;-ky&#39;\)</span>
来进一步求一个可行解。</p>
<p>递归地用 <span class="math inline">\(x&#39;\)</span>、<span
class="math inline">\(y&#39;\)</span> 表示“上一步”的<span
class="math inline">\(x\)</span>、<span
class="math inline">\(y\)</span>，就能递归地把问题转换成</p>
<p><span class="math display">\[
bx&#39; + (a \bmod b)y&#39;=GCD(b, a \bmod b)
\]</span></p>
<p>类似 <code>GCD()</code>
的递归终点，当扩展欧几里得算法<code>ExGCD()</code>的<span
class="math inline">\(a&#39;x&#39;+b&#39;y&#39;=GCD(a&#39;,b&#39;)\)</span>中的<span
class="math inline">\(b&#39;\)</span> 为 0 时，可以得到递归终点的 <span
class="math inline">\(x&#39;=1,
y&#39;=0\)</span>，层层回溯套用前面等式</p>
<p><span class="math display">\[
x = y&#39;
\]</span></p>
<p><span class="math display">\[
y = x&#39; - ky&#39;
\]</span></p>
<p>就能得到 <span class="math inline">\(ax+by=GCD(a, b)\)</span>
的一组可行解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">ExGCD</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x, y 为引用传参，故最终程序结束后，x,y会被赋值为可行解</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 递归终点，ax+by=GCD(a,b)的b为0，故方程变为</span></span><br><span class="line">        <span class="comment">// ax=a，则可行解可以是 x=1, y=0</span></span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d = <span class="built_in">ExGCD</span>(b, a % b, x, y), t = x;</span><br><span class="line">    x = y, y = t - a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;  <span class="comment">// 这里返回值是GCD(a,b)的结果，即最大公约数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展欧几里得求逆元">扩展欧几里得求逆元</h4>
<p>了解了扩展欧几里得，我们来看它与乘法逆元的关系。</p>
<ul>
<li>逆元：<span class="math inline">\(a\)</span> 关于 模<span
class="math inline">\(b\)</span> 的逆元 整数<span
class="math inline">\(d\)</span> 满足 <span class="math inline">\(ad
\bmod b \equiv 1\)</span></li>
<li>扩展欧几里得：求方程 <span class="math inline">\(ax + by = GCD(a,
b)\)</span> 的一组可行解</li>
</ul>
<p>逆元的<span class="math inline">\(ad \bmod b \equiv
1\)</span>，等价于 <span
class="math inline">\(ad-kb=1\)</span>，其中<span
class="math inline">\(k\)</span>为未知整数。</p>
<p>设 <span class="math inline">\(d\)</span> 为 <span
class="math inline">\(x\)</span>，<span
class="math inline">\(-k\)</span> 为 <span
class="math inline">\(y\)</span>，则<span
class="math inline">\(ad-kb=1\)</span>转换为 <span
class="math inline">\(ax+by=1\)</span>，</p>
<img src="/2021-06-07-MultiplicativeInverse/minioncheer.gif" class="">
<p>求出 <span class="math inline">\(x\)</span> 就得到了 <span
class="math inline">\(a\)</span> 关于模 <span
class="math inline">\(b\)</span> 的逆元。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExGcdInv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">ExGCD</span>(a, b, x, y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：大约<code>O(logn)</code>（斐波那契复杂度）。</p>
<p>适用范围：存在逆元即可求，适用于个数不多但模数<code>b</code>很大的时候，最常用、安全的求逆元方式。</p>
<h3 id="方法2费马小定理">方法2：费马小定理</h3>
<p>除了扩展欧几里得，还有另一个方法可以求逆元。</p>
<p>费马小定理：对于整数 <span class="math inline">\(a\)</span> 与质数
<span class="math inline">\(b\)</span> ，若 <span
class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 互质，则有：</p>
<p><span class="math display">\[
a^{b − 1} \bmod b \equiv 1
\]</span></p>
<h4 id="快速幂取模">快速幂取模</h4>
<p>快速幂取模大家应该也学过了，这里复习一下：</p>
<p>求<code>x ^ n % MOD</code>， <code>n</code>
很大时需要用折半的思想。如下所示求<code>2^15</code>：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2 2 2 2 2 2 2 2 2 2 2 2 2 2 2</span><br><span class="line">4   4   4   4   4   4   4</span><br><span class="line">16      16      16</span><br><span class="line">256</span><br></pre></td></tr></table></figure>
<p>可以看到，两两结合的时候，如果数字个数是奇数就会有“零头”，把零头存入<code>ret</code>，最终结果就是<code>256*2*4*16</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PowMod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n, <span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="费马小定理求逆元">费马小定理求逆元</h4>
<p>上文费马小定理的式子等价于</p>
<p><span class="math display">\[
a \cdot a^{b-2} \bmod b \equiv 1
\]</span></p>
<p>显然 <span class="math inline">\(a^{b-2}\)</span> 就是 <span
class="math inline">\(a\)</span> 模 <span
class="math inline">\(b\)</span> 的逆元。</p>
<p>求逆元，就用 <code>b-2</code> 和 b 代替 快速幂取模中的 <code>n</code>
和 <code>mod</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FermatInv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PowMod</span>(a, b - <span class="number">2</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：大约<code>O(log b)</code>。</p>
<p>适用范围：一般在模数 <code>b</code> 是质数的时候。</p>
<h3 id="方法3递归递推求逆元">方法3：递归/递推求逆元</h3>
<p>求 <span class="math inline">\(a\)</span> 在模 <span
class="math inline">\(b\)</span> 时的逆元（如果 <span
class="math inline">\(a &gt; b\)</span>，先将 <span
class="math inline">\(a\)</span> 取模 <span class="math inline">\(a:=a
\bmod b\)</span> 再求逆元，其中模数 <span
class="math inline">\(b\)</span> 是质数。</p>
<p>设 $k = b / a <span class="math inline">\(，\)</span>r = b
i$，则有</p>
<p><span class="math inline">\(b = ak + r\)</span></p>
<p>=&gt;</p>
<p><span class="math inline">\(ak + r \equiv 0, (\bmod b)\)</span></p>
<p>=&gt;</p>
<p><span class="math inline">\(kr^{-1} + a^{-1} \equiv 0, (\bmod
b)\)</span></p>
<p>=&gt;</p>
<p><span class="math inline">\(a^{-1} \equiv -kr^{-1}, (\bmod
b)\)</span></p>
<p><span class="math inline">\(a^{-1}\)</span> 和 <span
class="math inline">\(r^{-1}\)</span> 可分别由其逆元 <span
class="math inline">\(inv(a)\)</span>和<span
class="math inline">\(inv(r)\)</span>代替，等式依然成立：</p>
<p><span class="math inline">\(inv(a) \equiv -k \cdot inv(r), (\bmod
b)\)</span></p>
<p>将 <span class="math inline">\(k\)</span> 和 <span
class="math inline">\(r\)</span> 由 <span
class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>
表达代入得：</p>
<p><span class="math inline">\(inv(a) \equiv - \lfloor b / a \rfloor
\cdot inv(b \bmod a), (\bmod b)\)</span></p>
<p>从而我们得到了由 <span class="math inline">\(inv(b \bmod a)\)</span>
推出 <span class="math inline">\(inv(a)\)</span> 的递推关系。</p>
<p>用递归方式计算的话，由于 <span class="math inline">\(b\)</span>
是质数，<span class="math inline">\(b \bmod (b \bmod (b \bmod
...a))\)</span> 总会到 <span class="math inline">\(1\)</span>， <span
class="math inline">\(inv(1) \equiv 1\)</span>，从而达到递归终点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">Inv</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (b - b / a) * <span class="built_in">Inv</span>(b % a, b) % b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：大约<code>O(log b)</code></p>
<p>适用范围： <span class="math inline">\(b\)</span>
一定要为质数，此方法代码简单，但使用需谨慎。</p>
<h4 id="逆元打表">逆元打表</h4>
<p>基于递推方法，就可以打表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> invList[mod + <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetInv</span><span class="params">(<span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    invList[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; mod; i ++)</span><br><span class="line">        invList[i] = <span class="number">1LL</span> * (mod - mod / i) * invList[mod % i] % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：显而易见。</p>
<p>适用场景：频繁调用不同数的逆元。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
        <tag>逆元</tag>
        <tag>扩展欧几里得</tag>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title>线性规划单纯形法代码实现解析</title>
    <url>/2022-06-08-code-for-simplex/</url>
    <content><![CDATA[<p>本文仅针对代码实现思路，并不完整讲解单纯形算法原理，建议先完成课本或资料的原理学习，再阅读本文。</p>
<span id="more"></span>
<h2 id="算法课本的实现">1. 算法课本的实现</h2>
<p><strong>本节代码完全按课本方式实现，竞赛选手可略过此部分，查看第2节</strong>。</p>
<h3 id="流程梳理">1.1 流程梳理</h3>
<p>首先，我们先回顾单纯形基本流程：</p>
<ol type="1">
<li>确定初始基本可行解</li>
<li>检查检验数 <span class="math inline">\(\lambda\)</span> 和 <span
class="math inline">\(B^{-1}A\)</span> 的 <span
class="math inline">\(\alpha\)</span> 矩阵做判断：
<ul>
<li>是最优解或无最优解则结束；</li>
<li>否则，做基变换，合理选择一个非基变量换入，一个基变量换出，更新变换后的各值</li>
</ul></li>
<li>重复2</li>
</ol>
<h3 id="参数定义">1.2 参数定义</h3>
<p>先看看课本的单纯形法有哪些量：</p>
<ul>
<li><span class="math inline">\(m\)</span> ：约束条件的行数</li>
<li><span class="math inline">\(n\)</span> ：变量的个数</li>
<li><span class="math inline">\(A\)</span> 矩阵： <span
class="math inline">\(m\times n\)</span>
的矩阵，约束条件的系数矩阵，通常情况 $ m &lt; n $ 且 <span
class="math inline">\(A\)</span> 的秩为 <span
class="math inline">\(m\)</span>
。如果完整构建，则该矩阵应该也存了松弛变量对应的单位矩阵那部分</li>
<li><span class="math inline">\(b\)</span>
：约束条件右侧的值向量，最小标准形应该不小于0</li>
<li><span class="math inline">\(c\)</span>
：目标函数的系数向量，最小标准形就是求 <span
class="math inline">\(\min{c^{T}x}\)</span></li>
<li><span class="math inline">\(z\)</span>
：目标函数，不过表达上经过了变换，在算法中每次由上一次的目标函数值来计算</li>
<li><span class="math inline">\(B\)</span> 基： <span
class="math inline">\(m\times m\)</span> 的矩阵，为 <span
class="math inline">\(A\)</span> 中选出的 <span
class="math inline">\(m\)</span>
列线性无关的一组基，如果是完美的松弛形，则恰好可以选由松弛变量系数构成的“最右边”那个
<span class="math inline">\(m\times m\)</span> 的单位矩阵</li>
<li><span class="math inline">\(\alpha=B^{-1}A\)</span> 矩阵：由基 <span
class="math inline">\(B\)</span> 和约束矩阵 <span
class="math inline">\(A\)</span> 得到的校验参数</li>
<li><span class="math inline">\(\beta=B^{-1}b\)</span>
：其实就是枚举的每一组基本可行解</li>
</ul>
<p>我们来个课本例子：</p>
<p><span class="math display">\[
\begin{align}
\min ~~ &amp; {z=-12x_{1}-15x_{2}} \\
s.t. ~~ &amp; 0.25x_{1} +0.5x_{2}&amp; + x_{3} &amp;&amp;&amp; =120 \\
&amp; 0.5x_{1} +0.5x_{2}&amp;&amp; + x_{4} &amp;&amp; =150 \\
&amp; 0.25x_{1}&amp;&amp;&amp; + x_{5} &amp;=50 \\
&amp; x_{i}\geq 0, i=1,2,\dots, 5
\end{align}
\]</span></p>
<p>用表来展现：</p>
<table>
<thead>
<tr class="header">
<th>-12</th>
<th>-15</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>c/b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(x_1\)</span></td>
<td><span class="math inline">\(x_2\)</span></td>
<td><span class="math inline">\(x_3\)</span></td>
<td><span class="math inline">\(x_4\)</span></td>
<td><span class="math inline">\(x_5\)</span></td>
<td></td>
</tr>
<tr class="even">
<td>0.25</td>
<td>0.50</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>120</td>
</tr>
<tr class="odd">
<td>0.50</td>
<td>0.50</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>150</td>
</tr>
<tr class="even">
<td>0.25</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>50</td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(A\)</span> 矩阵就是完整的系数矩阵：</p>
<table>
<tbody>
<tr class="odd">
<td>0.25</td>
<td>0.50</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0.50</td>
<td>0.50</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0.25</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>第一组可行基<span
class="math inline">\(B\)</span>我们就选右侧的单位矩阵：</p>
<table>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>既然选的这组基对应的变量序号是 <span
class="math inline">\(3,4,5\)</span> 列，那么基变量 $x_{B}=x_3,x_4,x_5$
，非基变量 $x_{N}=x_{1},x_{2}$ 。</p>
<p>相应的，基变量对应的目标函数的系数 $c_{B}=,0,0$
，非基变量对应的目标函数的系数 $c_{N}=,-15$
，发现了吗，松弛变量因为是我们构建标准形额外加的，所以它们序号对应的目标函数的系数都是0，也即最初的基变量对应的目标函数的系数都是0
。</p>
<p><strong>记住以上内容（或文章的位置），我们接下来的代码实现会参照这些内容</strong>。</p>
<h3 id="搭个框架">1.3 搭个框架</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Simplex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 标准型：min Σcx, s.t. ax=b, x&gt;=0</span></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; b, c;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">double</span>&gt; &gt;a;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n_, <span class="type">int</span> m_)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pivot</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 向量置换，参考课本公式更新 b, a, z, c 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 参考课本判断λ和α</span></span><br><span class="line">            <span class="comment">// 如果存在最优解且当前不是最优解，则计算置换的向量序号，进行向量置换（调用Pivot）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，我们用<code>a[][]</code>、<code>b[]</code>、<code>c[]</code>
保存最初的 <span class="math inline">\(A\)</span> 矩阵、 <span
class="math inline">\(b\)</span> 、 <span
class="math inline">\(c\)</span> 向量。</p>
<h3 id="实现">1.4 实现</h3>
<h4 id="循环枚举可行基">1.4.1 循环枚举可行基</h4>
<p>算法中“重复2”的过程体现在<code>Solve()</code>的<code>while(true)</code>里，在这里检查是否结束。
如果需要基变量置换，则在<code>Solve()</code>中调用<code>Pivot()</code>执行置换过程。</p>
<p><code>Solve()</code>的开头，参照课本最优性检验的定义， <span
class="math inline">\(k\)</span> 是换入变量序号， <span
class="math inline">\(l\)</span>
是换出变量在基里的序号，先把这俩序号定义出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>, l = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果 <span class="math inline">\(\lambda \geq 0\)</span>
则是最优解直接返回，否则如果有 <span class="math inline">\(\lambda_k
&lt; 0\)</span> ，则 <span class="math inline">\(k\)</span>
就是换入变量的序号。</p>
<p>代码用一个单行<code>for</code>循环找到 <span
class="math inline">\(k\)</span>
，利用了<code>for</code>循环里的判断条件，注意这个<code>for</code>的结尾直接跟分号“<code>;</code>”。如果循环结束<code>k==n</code>的话那就是没找到小于0的
<span class="math inline">\(\lambda\)</span>
，这C语言基础知识了，这种情况已经最优解，属于“情况<code>1</code>”，返回当前的目标函数值<code>z</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n &amp;&amp; c[k] &gt;= <span class="number">0</span>; k ++);</span><br><span class="line"><span class="keyword">if</span>(k == n) <span class="keyword">return</span> z;</span><br></pre></td></tr></table></figure>
<p>困惑来了：不是 <span class="math inline">\(\lambda\)</span>
吗，这里怎么用<code>c[k]&gt;=0</code>做条件？我们回顾课本检验数的公式：
<span class="math inline">\(\lambda^{T}=c^{T}-c_{B}^{T}B^{-1}A\)</span>
，翻一下上文的 <span class="math inline">\(c_{B}\)</span> 和 <span
class="math inline">\(c_{N}\)</span> ，当松弛变量为初始基的时候，对应的
<span class="math inline">\(c_{B}\)</span> 都是0呢，所以“恰好” <span
class="math inline">\(c\)</span> 就是初始的 <span
class="math inline">\(\lambda\)</span>
。由于单纯形法的过程中都是由“上一步”的 <span
class="math inline">\(\alpha,\beta,\lambda,z\)</span>
推“下一步”的，所以初始的 <span class="math inline">\(c\)</span>
可以不用保留，<strong>我们直接用<code>c[]</code>数组表示接下来所有的
<span class="math inline">\(\lambda\)</span></strong>。</p>
<p>接下来就处理有那么个 <span
class="math inline">\(\lambda_{k}&lt;0\)</span> 的情况，看 <span
class="math inline">\(\alpha\)</span> 的第 <span
class="math inline">\(k\)</span> 列是否有大于0的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> mn = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i][k] &gt; <span class="number">0</span> &amp;&amp; mn &gt; b[i] / a[i][k])</span><br><span class="line">    &#123;</span><br><span class="line">        mn = b[i] / a[i][k];</span><br><span class="line">        l = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mn == inf) <span class="keyword">return</span> inf;</span><br></pre></td></tr></table></figure>
<p>又有心细的同学问了，不是 <span class="math inline">\(\alpha\)</span>
吗，怎么直接用<code>a[][]</code>矩阵了？回忆上文 <span
class="math inline">\(\alpha\)</span> 是什么？是 <span
class="math inline">\(B^{-1}A\)</span> ，而初始基 <span
class="math inline">\(B\)</span> 是单位矩阵，所以初始的 <span
class="math inline">\(\alpha\)</span> 恰好就是 <span
class="math inline">\(A\)</span> 矩阵，我们又可以直接用
<code>a[][]</code>表示后续的 <span class="math inline">\(\alpha\)</span>
矩阵了。</p>
<p>如果临时变量<code>mn==inf</code>，意味 <span
class="math inline">\(\alpha\)</span> 的第 <span
class="math inline">\(k\)</span>
列没有遇到大于0的，根据算法，这种情况无最优解，属于“情况<code>2</code>”，返回一个信号，这里我们从简，返回个无穷大好了。</p>
<p><code>for</code>循环里面就是在顺便处理“情况<code>3</code>”了，即确定换出变量的序号
<span class="math inline">\(l\)</span> ，根据算法，是 <span
class="math inline">\(\alpha\)</span> 这第 <span
class="math inline">\(k\)</span> 列大于0的里面，对应的 <span
class="math inline">\(\beta_{i}/\alpha_{i,k}\)</span> 最小的那个 <span
class="math inline">\(i\)</span> 作为 <span
class="math inline">\(l\)</span> 。</p>
<p>如果“情况<code>1</code>”和“情况<code>2</code>”都没有遇到，即函数没有<code>return</code>，就要根据找到的
<span class="math inline">\(k\)</span> 和 <span
class="math inline">\(l\)</span>
做基变换了，我们调用<code>Pivot(k,l)</code>，完整的<code>Solve()</code>代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n &amp;&amp; c[k] &gt;= <span class="number">0</span>; k ++);</span><br><span class="line">        <span class="keyword">if</span>(k == n) <span class="keyword">return</span> z;</span><br><span class="line">        <span class="type">double</span> mn = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][k] &gt; <span class="number">0</span> &amp;&amp; mn &gt; b[i] / a[i][k])</span><br><span class="line">            &#123;</span><br><span class="line">                mn = b[i] / a[i][k];</span><br><span class="line">                l = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mn == inf) <span class="keyword">return</span> inf;</span><br><span class="line">        <span class="built_in">Pivot</span>(k, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基变换">1.4.2 基变换</h4>
<p>接下来看<code>void Pivot(int k, int l)</code>的实现。</p>
<p>回顾课本公式：</p>
<ul>
<li><span
class="math inline">\(\alpha_{lj}^{\prime}=\alpha_{lj}/\alpha_{lk},
1\leq j \leq n\)</span></li>
<li><span class="math inline">\(\alpha_{ij}^{\prime}=\alpha_{ij} -
\alpha_{ik}\alpha_{lj}/\alpha_{lk}, 1 \leq i \leq m 且i\neq l, 1\leq j
\leq n\)</span></li>
<li><span
class="math inline">\(\beta_{l}^{\prime}={\beta_l}/\alpha_{lk}\)</span></li>
<li><span class="math inline">\(\beta_{i}^{\prime}=\beta_{i} -
\alpha_{ik}\beta_{l}/\alpha_{lk}, 1\leq i \leq m 且 i \neq
l\)</span></li>
<li><span
class="math inline">\(\lambda_{j}^{\prime}=\lambda_{j}-\lambda_{k}\alpha_{lj}/\alpha_{lk},
1\leq j \leq n\)</span></li>
<li><span
class="math inline">\(z_{0}^{\prime}=z_{0}+\lambda_{k}\beta_{l}/\alpha_{lk}\)</span></li>
</ul>
<p>我们就依据公式把基变换之后所有的数都更新出来。</p>
<p>先看<code>l</code>这一行，这里我们一开始没有更新 <span
class="math inline">\(\alpha[l][k]\)</span>（即<code>a[l][k]</code>），因为它后面还要被用到，最后再更新它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b[l] /= a[l][k];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">    <span class="keyword">if</span>(j != k) a[l][j] /= a[l][k];</span><br></pre></td></tr></table></figure>
<p>接着处理除了第<code>l</code>行之外的每一行，<code>a[i][k]==0</code>时候可以跳过不用计算，看公式就知道为0时对结果没有影响。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(a[i][k]) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] -= a[i][k] * b[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(j != k) a[i][j] -= a[i][k] * a[l][j];</span><br><span class="line">        a[i][k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里更新<code>a[i][j]</code>时的代码为<code>a[i][j] -= a[i][k] * a[l][j];</code>，公式是
<span class="math inline">\(\alpha_{ij}^{\prime}=\alpha_{ij} -
\alpha_{ik}\alpha_{lj}/\alpha_{lk}\)</span>
，有同学可能要问“为什么少除了 <code>a[l][k]</code>
呢”？因为前面的代码已经更新了 <code>a[l][j]</code>的值，到这行代码时的
<code>a[l][j]</code> 已经是 <span
class="math inline">\(\alpha_{lj}/\alpha_{lk}\)</span> 了。</p>
<p>这里我们对第<code>k</code>列做了单独处理（置0），一方面计算过程中要用到<code>a[i][k]</code>的值，不能过早覆盖它，另一方面其实按公式算也是0，浮点数运算直接置0也能优化点精度。</p>
<p>接着更新目标函数 <span class="math inline">\(z\)</span> 和检验数
<span class="math inline">\(\lambda\)</span>
，前面已经讲解了我们直接用<code>c[]</code>数组保存后续更新的 <span
class="math inline">\(\lambda\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">z += c[k] * b[l];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">    <span class="keyword">if</span>(j != k) c[j] -= c[k] * a[l][j];</span><br><span class="line">c[k] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>c[k]</code>单独处理理由和前面一样的，过程中要用它不能过早覆盖。</p>
<p>最后别忘了前面的<code>a[l][k]</code>也要更新，按公式就是除以它自己，应该为<code>1</code>。<code>Pivot()</code>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pivot</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] /= a[l][k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">        <span class="keyword">if</span>(j != k) a[l][j] /= a[l][k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(a[i][k]) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i] -= a[i][k] * b[l];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(j != k) a[i][j] -= a[i][k] * a[l][j];</span><br><span class="line">            a[i][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    z += c[k] * b[l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">        <span class="keyword">if</span>(j != k) c[j] -= c[k] * a[l][j];</span><br><span class="line">    c[k] = <span class="number">0</span>;</span><br><span class="line">    a[l][k] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化">1.4.3 初始化</h4>
<p>代码中要用到行数<code>m</code>和列数<code>n</code>，当然要初始化好，可以定义个内置函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n_, <span class="type">int</span> m_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = n_, m = m_;</span><br><span class="line">    b.<span class="built_in">resize</span>(m);</span><br><span class="line">    a.<span class="built_in">resize</span>(m);</span><br><span class="line">    c.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : a) x.<span class="built_in">resize</span>(n + <span class="number">1</span>), <span class="built_in">fill</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">fill</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">fill</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点在于所有<code>a[][]</code>、<code>b[]</code>、<code>c[]</code>的值要根据输入初始化，不要在处理多组数据时残留之前的数据，初始化为<code>0</code>比较安全。<code>vector</code>容器增强代码的可伸缩性。</p>
<p>当然，习惯用C语言形式的数组也可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> a[maxn][maxm], b[maxn], c[maxm], z;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n_, <span class="type">int</span> m_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = n_, m = m_;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别注意的是，当存入了松弛变量，实质上变量数量增加了，传入<code>Init()</code>的<code>n</code>要对应哦。</p>
<h4 id="使用">1.4.4 使用</h4>
<p>以<a href="https://www.luogu.com.cn/problem/P3980">P3980 [NOI2008]
志愿者招募</a> 这道题为例：</p>
<blockquote>
<ul>
<li><code>n</code>天，第<code>i</code>天需要<code>bi</code>个人</li>
<li>有<code>m</code>类志愿者，第<code>j</code>类可以从第<code>si</code>天工作到第<code>ti</code>天，每人<code>ci</code>元</li>
<li>第一行输入<code>n m</code>，第二行<code>n</code>个数表示每天需要人数，接下来<code>m</code>行每行
3 个数表示一类志愿者的起止时间和花费</li>
<li>求满足要求的最省钱总费用</li>
</ul>
</blockquote>
<p>直接建线性规划模型，设<code>x</code>是每类志愿者个数，约束条件每一行是每一天的要求，<span
class="math inline">\(A\)</span>矩阵第<code>i</code>行为<code>01</code>向量，<span
class="math inline">\(A_{ij}\)</span>
表示第<code>j</code>类志愿者第<code>i</code>天是否可以服务。</p>
<p><span class="math display">\[
\begin{align}
\min ~~ &amp;{z=cx} \\
s.t. ~~ &amp;\sum A_{ij}x_{j} \geq b \\
    &amp;x\geq 0
\end{align}
\]</span></p>
<p>这全是 <span class="math inline">\(\geq\)</span>
，不便于我们建松弛变量，转成对偶问题来做：</p>
<p><span class="math display">\[
\begin{align}
\max ~~ &amp; {z=by} \\
s.t. ~~ &amp; \sum A_{ji}y_{i} \leq c \\
    &amp; y\geq 0
\end{align}
\]</span></p>
<p>这还不够，不是最小标准型，把目标函数系数取个负号变成</p>
<p><span class="math display">\[
\min{z=-by}
\]</span></p>
<p>求解完成后记得把负号乘回来。</p>
<p>接下来实现构造数据的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Simplex spx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> s, t, ci;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        spx.<span class="built_in">Init</span>(n + m, m); <span class="comment">// n+m 考虑了m个松弛变量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="comment">// 直接把每天需要的志愿者个数bi读入到对偶问题的目标函数系数`c`向量</span></span><br><span class="line">            <span class="comment">// 这里注意，对偶问题是个 max 问题，需要对目标函数的系数取负变为最小单纯形</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;spx.c[i]), spx.c[i] = -spx.c[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;ci);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = s; j &lt;= t; j ++)</span><br><span class="line">                <span class="comment">// 按对偶问题定义，A的每一行存一类志愿者的工作起止时间标记，哪天能工作哪天就是`1`</span></span><br><span class="line">                spx.a[i][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            spx.a[i][n + i] = <span class="number">1</span>;    <span class="comment">// 存松弛变量系数</span></span><br><span class="line">            spx.b[i] = ci;          <span class="comment">// 把每类志愿者费用存入对偶问题的`b`向量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求解后记得负号取回来，`+0.5`用于浮点数修正，比如`5`变成`4.999999...`的时候</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)(-spx.<span class="built_in">Solve</span>() + <span class="number">0.5</span>));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给一份完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> inf = <span class="number">1e20</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Simplex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 标准型：min Σcx, s.t. ax=b, x&gt;=0</span></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; b, c;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">double</span>&gt; &gt;a;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n_, <span class="type">int</span> m_)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = n_, m = m_;</span><br><span class="line">        b.<span class="built_in">resize</span>(m);</span><br><span class="line">        a.<span class="built_in">resize</span>(m);</span><br><span class="line">        c.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : a) x.<span class="built_in">resize</span>(n + <span class="number">1</span>), <span class="built_in">fill</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        std::<span class="built_in">fill</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        std::<span class="built_in">fill</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        z = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pivot</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b[l] /= a[l][k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(j != k) a[l][j] /= a[l][k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(a[i][k]) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b[i] -= a[i][k] * b[l];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                    <span class="keyword">if</span>(j != k) a[i][j] -= a[i][k] * a[l][j];</span><br><span class="line">                a[i][k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        z += c[k] * b[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(j != k) c[j] -= c[k] * a[l][j];</span><br><span class="line">        c[k] = <span class="number">0</span>;</span><br><span class="line">        a[l][k] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n &amp;&amp; c[k] &gt;= <span class="number">0</span>; k ++);</span><br><span class="line">            <span class="keyword">if</span>(k == n) <span class="keyword">return</span> z;</span><br><span class="line">            <span class="type">double</span> mn = inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i][k] &gt; <span class="number">0</span> &amp;&amp; mn &gt; b[i] / a[i][k])</span><br><span class="line">                &#123;</span><br><span class="line">                    mn = b[i] / a[i][k];</span><br><span class="line">                    l = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mn == inf) <span class="keyword">return</span> inf;</span><br><span class="line">            <span class="built_in">Pivot</span>(k, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Simplex spx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> s, t, ci;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        spx.<span class="built_in">Init</span>(n + m, m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;spx.c[i]), spx.c[i] = -spx.c[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;ci);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = s; j &lt;= t; j ++)</span><br><span class="line">                spx.a[i][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            spx.a[i][n + i] = <span class="number">1</span>;</span><br><span class="line">            spx.b[i] = ci;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)(-spx.<span class="built_in">Solve</span>() + <span class="number">0.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“啊！怎么MLE了，这不是正解啊？！”</p>
<p>是的，完全按课本来，我们遇到了一个问题，加了松弛变量之后，数据的两个维度都达到了这道题<code>m</code>
的 <span class="math inline">\(10^4\)</span>
级，<code>a[][]</code>矩阵达到 <span class="math inline">\(10^8\)</span>
，虽然过了部分数据，但大数据 <code>Memory Limit Exceed</code> 了。</p>
<p>看来这个写法只能解决规模没那么大的问题，那么应该怎么办呢？请看下一节。</p>
<h2 id="改进的实现">2. 改进的实现</h2>
<h3 id="松弛变量与置换策略">2.1 松弛变量与置换策略</h3>
<p>对于刚刚的例子，<code>n</code>的范围在 <span
class="math inline">\(10^3\)</span> ，<code>m</code>的范围在 <span
class="math inline">\(10^4\)</span> ，如果只是 <span
class="math inline">\(n\times m\)</span>
，还不至于MLE，但加上松弛变量，<code>a[][]</code>就要开到 <span
class="math inline">\((n+m)\times m\)</span> 。</p>
<p>我们知道松弛变量系数构成的矩阵是个单位矩阵，能不能不显式地保存它，却仍利用它为初始的可行基
<span class="math inline">\(B\)</span> 进行计算呢？</p>
<p>在构造数据的时候，先不保存松弛变量，注释掉的即我们调整的地方：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// spx.Init(n + m, m); --&gt;</span></span><br><span class="line">spx.<span class="built_in">Init</span>(n, m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;ci);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = s; j &lt;= t; j ++)</span><br><span class="line">        spx.a[i][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// spx.a[i][n + i] = 1;</span></span><br><span class="line">    spx.b[i] = ci;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后需要对<code>Pivot()</code>进行改变：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pivot</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] /= a[l][k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">        <span class="keyword">if</span>(j != k) a[l][j] /= a[l][k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(a[i][k]) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i] -= a[i][k] * b[l];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(j != k) a[i][j] -= a[i][k] * a[l][j];</span><br><span class="line">            <span class="comment">// a[i][k] = 0; --&gt;</span></span><br><span class="line">            a[i][k] /= -a[l][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    z += c[k] * b[l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">        <span class="keyword">if</span>(j != k) c[j] -= c[k] * a[l][j];</span><br><span class="line">    <span class="comment">// c[k] = 0; --&gt;</span></span><br><span class="line">    c[k] /= -a[l][k];</span><br><span class="line">    <span class="comment">// a[l][k] = 1; --&gt;</span></span><br><span class="line">    a[l][k] = <span class="number">1</span> / a[l][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们改变了三个地方，对应着特殊的<code>k</code> 这一列。课本上利用
<span class="math inline">\(H\)</span> 矩阵把 <span
class="math inline">\(\alpha_{lk}\)</span>
变为1，<code>k</code>这列的其他 <span
class="math inline">\(\alpha_{ik}\)</span> 消元为0，对应的 <span
class="math inline">\(\lambda_{k}\)</span> 也变为了0。</p>
<p>而改变之后，<code>a[][]</code>数组里没有再存储松弛变量对应的单位矩阵，基变换的过程中也没有了那些列的信息，第<code>k</code>列相应改变了基变换时更新的方式，<code>a[l][k]</code>变为<code>1/a[l][k]</code>，其它的<code>a[i][k]</code>变为<code>-a[i][k]/a[l][k]</code>。</p>
<p>“不对呀，这跟课本的公式就不一样了啊，为什么按课本的方法要在<code>a[][]</code>里存松弛变量，而这个不用存？不用存就罢了，<code>a[][k]</code>这第<code>k</code>列为什么这样更新？”</p>
<p>我们需要先理清课本方法做了什么事：</p>
<p>把<code>a[][]</code>的第<code>k</code>列的<code>a[l][k]</code>变为<code>1</code>，其它<code>a[i][k]</code>变为<code>0</code>，是
<span class="math inline">\(H\)</span> 矩阵的作用，即让可行基 <span
class="math inline">\(B\)</span> 乘特意设计的 <span
class="math inline">\(H\)</span> 矩阵完成基变换，将原始 <span
class="math inline">\(A\)</span> 矩阵的第 <span
class="math inline">\(k\)</span> 列换入，基 <span
class="math inline">\(B\)</span> 的第 <span
class="math inline">\(l\)</span> 列换出，导致的 <span
class="math inline">\(\alpha\)</span>
矩阵的变化。我们需要存储松弛变量对应的那些列，才能完整体现换入和换出的所有信息。</p>
<p>以这样一组数据为例：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">10 10</span><br><span class="line">8 3 5 2 2 5 5 2 7 9 </span><br><span class="line">9 10 900</span><br><span class="line">6 7 57</span><br><span class="line">1 1 978</span><br><span class="line">4 8 887</span><br><span class="line">8 8 215</span><br><span class="line">3 5 433</span><br><span class="line">4 6 843</span><br><span class="line">5 10 326</span><br><span class="line">8 9 397</span><br><span class="line">1 4 108</span><br></pre></td></tr></table></figure>
<p>我们以课本方法进行一次换入换出，打印一个中间步骤的<code>l</code>、<code>k</code>、<code>a[][]</code>(
<span class="math inline">\(\alpha\)</span> )和<code>c</code>( <span
class="math inline">\(\lambda\)</span> )：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">l:   7 k:   9</span><br><span class="line">a:</span><br><span class="line">  0  0  0  0 -1  0  0 -1  0  0  1  1  0  0  0  0  0 -1  0  0</span><br><span class="line">  0  0  0  0  0  1  1  0  0  0  0  1  0  0  0  0  0  0  0  0</span><br><span class="line">  0 -1 -1 -1  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0 -1</span><br><span class="line">  0  0  0  1  1  0  0  1  0  0  0 -1  0  1  0  0  0  0  0  0</span><br><span class="line">  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0</span><br><span class="line">  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0</span><br><span class="line">  0  0  0  1  1  0 -1  0  0  0  0 -1  0  0  0  0  1  0  0  0</span><br><span class="line">  0  0  0  0  1  0  0  1  1  1  0 -1  0  0  0  0  0  1  0  0</span><br><span class="line">  0  0  0  0  0  0  0  1  1  0  0  0  0  0  0  0  0  0  1  0</span><br><span class="line">  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1</span><br><span class="line">c:</span><br><span class="line">  0  5  3  6  7  0  0  7  2  0  0 [-4]  0  0  0  0  0  9  0  8</span><br></pre></td></tr></table></figure>
<p>经过公式计算，第<code>12</code>列的<code>c[]</code>是<code>-4</code>，这里加上了中括号<code>[]</code>方便找到。这一列在<code>a[][]</code>中一开始存储的是松弛变量的系数。</p>
<p>有一点不要混淆：我们只是因为初始的<code>a[][]</code>恰好等于 <span
class="math inline">\(\alpha\)</span>
矩阵，才用<code>a[][]</code>数组继续保存后续的 <span
class="math inline">\(\alpha\)</span> ，但 <span
class="math inline">\(A\)</span> 矩阵和 <span
class="math inline">\(\alpha\)</span> 矩阵并不等价， <span
class="math inline">\(A\)</span>
是不会变的，改变的是完成变量置换这个任务的 <span
class="math inline">\(H\)</span> ，且 <span
class="math inline">\(\alpha=H^{-1}B^{-1}A\)</span> 。</p>
<p>如果<code>a[][]</code>中不保存松弛变量系数，则这些列便不再存在，在更新
<span class="math inline">\(\alpha\)</span>
的过程中，这一次<code>c[]</code>的第<code>12</code>列为负的信息就无从知晓，本应当在某一次迭代作为换入变量的它却遗失了，导致后续计算错误。</p>
<p>知道这个情况之后，我们再考虑改进的方法，不保存松弛变量，那么<code>a[][]</code>的第<code>k</code>列新的更新方式是什么原理呢？我们打印一份第一步的结果，对比课本方法带松弛变量系数列的结果，和改进方法不带松弛变量列的结果：</p>
<p>课本方法：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">l:   9 k:   0</span><br><span class="line">a:</span><br><span class="line">  0  0  0  0  0  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0</span><br><span class="line">  0  0  0  0  0  1  1  0  0  0  0  1  0  0  0  0  0  0  0  0</span><br><span class="line">  0 -1 -1 -1  0  0  0  0  0  0  0  0  1  0  0  0  0  0  0 -1</span><br><span class="line">  0  0  0  1  1  1  1  1  0  0  0  0  0  1  0  0  0  0  0  0</span><br><span class="line">  0  0  0  0  0  0  0  1  0  0  0  0  0  0  1  0  0  0  0  0</span><br><span class="line">  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0</span><br><span class="line">  0  0  0  1  1  1  0  0  0  0  0  0  0  0  0  0  1  0  0  0</span><br><span class="line">  0  0  0  0  1  1  1  1  1  1  0  0  0  0  0  0  0  1  0  0</span><br><span class="line">  0  0  0  0  0  0  0  1  1  0  0  0  0  0  0  0  0  0  1  0</span><br><span class="line">  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1</span><br><span class="line">c:</span><br><span class="line">  0  5  3  6 -2 -5 -5 -2 -7 -9  0  0  0  0  0  0  0  0  0  [8]</span><br></pre></td></tr></table></figure>
<p>改进方法：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">l:   9 k:   0</span><br><span class="line">a:</span><br><span class="line">  0  0  0  0  0  0  0  0  1  1</span><br><span class="line">  0  0  0  0  0  1  1  0  0  0</span><br><span class="line"> -1 -1 -1 -1  0  0  0  0  0  0</span><br><span class="line">  0  0  0  1  1  1  1  1  0  0</span><br><span class="line">  0  0  0  0  0  0  0  1  0  0</span><br><span class="line">  0  0  1  1  1  0  0  0  0  0</span><br><span class="line">  0  0  0  1  1  1  0  0  0  0</span><br><span class="line">  0  0  0  0  1  1  1  1  1  1</span><br><span class="line">  0  0  0  0  0  0  0  1  1  0</span><br><span class="line">  1  1  1  1  0  0  0  0  0  0</span><br><span class="line">c:</span><br><span class="line">  [8]  5  3  6 -2 -5 -5 -2 -7 -9</span><br></pre></td></tr></table></figure>
<p>更新的是换入变量<code>k=0</code>列（数组下标从<code>0</code>开始），换出变量<code>l=9</code>列（最后一列）。</p>
<p>我们看到，课本方法最后一列的 <span
class="math inline">\(\lambda\)</span> 变为了
8（用中括号<code>[]</code>标记了），换入变量的<code>k=0</code>的 <span
class="math inline">\(\lambda\)</span> 变为了0 。</p>
<p>于是发现，改进方法并不是基于 <span class="math inline">\(H\)</span>
矩阵更新第<code>k=0</code>列的值，而是把<code>k=0</code>列变成了更新后的<code>l=9</code>那一列的
<span class="math inline">\(\alpha\)</span> 值。</p>
<p>这样做，就保留了课本方法里松弛变量对应的那些列的更新信息，不会缺失后期需要变量置换的列的信息。</p>
<p>“那原本<code>k=0</code>那一列就丢掉了？”</p>
<p>是的，暂时“丢掉了”，它被“换入”了，一个已经在基中的变量，不可能再次被选中进行换入，所以暂时丢掉它的信息，不影响我们后续寻找用于换入的变量。</p>
<p>这样每次都用换出变量的列序号（<span
class="math inline">\(l\)</span>）对应的 <span
class="math inline">\(\alpha\)</span> 值替换换入变量对应的列（<span
class="math inline">\(k\)</span>）的 <span
class="math inline">\(\alpha\)</span>
值，就使得课本方法里存储的松弛变量那些列序号被换入后的信息，存在了一个“虚空”里，它会基于数学推导的结果被换入换出，而不影响计算结果。</p>
<h3 id="检验数的选取">2.2 检验数的选取</h3>
<p>肯定会有多个 <span class="math inline">\(\lambda\)</span>
分量小于<code>0</code>的情况，无论选哪个都肯定对，这次没换入，下次也就换入了。</p>
<p>但是如果更深入了解单纯形与凸优化的话，会发现，选取最小的负<span
class="math inline">\(\lambda_k\)</span>作为换入变量，会让算法收敛更快，起到提速作用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// *****</span></span><br><span class="line">        <span class="comment">// 这里不再遇到小于0的c[k]就停止，而是找最小的那个</span></span><br><span class="line">        <span class="type">double</span> minc = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(c[i] &lt; minc)</span><br><span class="line">                minc = c[k = i];</span><br><span class="line">        <span class="keyword">if</span>(minc &gt;= <span class="number">0</span>) <span class="keyword">return</span> z;</span><br><span class="line">        <span class="comment">// *****</span></span><br><span class="line">        <span class="type">double</span> minba = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][k] &gt; <span class="number">0</span> &amp;&amp; minba &gt; b[i] / a[i][k])</span><br><span class="line">                minba = b[i] / a[i][k], l = i;</span><br><span class="line">        <span class="keyword">if</span>(minba == inf) <span class="keyword">return</span> inf;</span><br><span class="line">        <span class="built_in">Pivot</span>(k, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题外话浮点数计算的好习惯">2.3 题外话：浮点数计算的好习惯</h3>
<p>浮点数在计算过程中有精度损失，一个本应为<code>0</code>的数，就可能在<code>0</code>的左右浮动，如果我们直接判断它是否大于等于<code>0</code>，而恰好浮动在很小的<code>-0.00...01</code>，就得到了错误的判断。</p>
<p>解决方法是定义一个全局的精度控制<span
class="math inline">\(eps=10^{-8}\)</span>，这个大小只是经验之谈，<span
class="math inline">\(10^{-7}\)</span>、<span
class="math inline">\(10^{-6}\)</span>也不是不行。</p>
<p>这时我们判断一个数是否大于<code>0</code>，就将<code>if(x &gt; 0)</code>
改为
<code>if(x &gt; eps)</code>，如果判断是否大于等于<code>0</code>，就将<code>if(x &gt;= 0)</code>
改为 <code>if(x &gt; -eps)</code>。</p>
<p>两数比大小也类似，<code>if(x &gt; y)</code> 改为
<code>if(x - y &gt; eps)</code>。</p>
<h3 id="以例题为例的完整代码">2.4 以例题为例的完整代码</h3>
<p>题目：<a href="https://www.luogu.com.cn/problem/P3980">P3980
[NOI2008] 志愿者招募</a></p>
<p>该代码可做模板保存使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> inf = <span class="number">1e20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Simplex</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; b, c;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">double</span>&gt; &gt;a;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n_, <span class="type">int</span> m_)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = n_, m = m_;</span><br><span class="line">        b.<span class="built_in">resize</span>(m);</span><br><span class="line">        a.<span class="built_in">resize</span>(m);</span><br><span class="line">        c.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : a) x.<span class="built_in">resize</span>(n + <span class="number">1</span>), <span class="built_in">fill</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        std::<span class="built_in">fill</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        std::<span class="built_in">fill</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        z = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pivot</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b[l] /= a[l][k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(j != k) a[l][j] /= a[l][k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(a[i][k]) &gt; eps)</span><br><span class="line">            &#123;</span><br><span class="line">                b[i] -= a[i][k] * b[l];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                    <span class="keyword">if</span>(j != k) a[i][j] -= a[i][k] * a[l][j];</span><br><span class="line">                a[i][k] /= -a[l][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        z += c[k] * b[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(j != k) c[j] -= c[k] * a[l][j];</span><br><span class="line">        c[k] /= -a[l][k];</span><br><span class="line">        a[l][k] = <span class="number">1</span> / a[l][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>, l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> minc = inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">                <span class="keyword">if</span>(c[i] &lt; minc)</span><br><span class="line">                    minc = c[k = i];</span><br><span class="line">            <span class="keyword">if</span>(minc &gt; -eps) <span class="keyword">return</span> z;</span><br><span class="line">            <span class="type">double</span> minba = inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">                <span class="keyword">if</span>(a[i][k] &gt; eps &amp;&amp; minba - b[i] / a[i][k] &gt; eps)</span><br><span class="line">                    minba = b[i] / a[i][k], l = i;</span><br><span class="line">            <span class="keyword">if</span>(minba == inf) <span class="keyword">return</span> inf;</span><br><span class="line">            <span class="built_in">Pivot</span>(k, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">Simplex spx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s, t, c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        spx.<span class="built_in">Init</span>(n, m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;spx.c[i]), spx.c[i] = -spx.c[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;t, &amp;c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = s; j &lt;= t; j ++)</span><br><span class="line">                spx.a[i][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            spx.b[i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)(-spx.<span class="built_in">Solve</span>() + <span class="number">0.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="输出解">3. 输出解</h1>
<p>如果要输出求解 <span class="math inline">\(x\)</span>
向量的值，我们需要记录换入换出的情况，增加两个数组<code>IdA[], IdB[]</code>
分别记录原始变量的序号id、基变量的序号id，在<code>Pivot()</code>函数增加换入换出后的序号信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pivot</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(IdB[l], IdA[k]);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何初始化<code>IdA</code>与<code>IdB</code>，最终如何输出解，就留给大家尝试吧。</p>
<hr />
<p>本文不涉及单纯形的原理和数学证明，仅解析代码实现。</p>
<p>如有原理性错误欢迎指正。</p>
<p>主要参考：</p>
<ul>
<li>屈婉玲，刘田，张立昂，王捍贫，《算法设计与分析》，清华大学出版社，2014.</li>
<li>网上的单纯形模板</li>
</ul>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2022-11-18-MobiusInversion/</url>
    <content><![CDATA[<p>莫比乌斯反演是组合数学中的一个重要技巧，可以用一个易解问题表达难解问题，从而得到解答.</p>
<span id="more"></span>
<h3 id="序">0. 序</h3>
<blockquote>
<p>本节用于增加莫比乌斯反演的感性认识，可略读.<br />
如果详读的话，不排除可能有些劝退，那么也是可以跳过的，对学习算法竞赛的莫反套路影响不大.<br />
如果读下来的话，应该会有更全面一些的认识.</p>
</blockquote>
<p>莫比乌斯反演是定义在偏序关系计数问题的方法.
要理解偏序，我们先聊全序，比如自然数<span
class="math inline">\({1,2,3,\cdots}\)</span>，<span
class="math inline">\(1&lt;2,
2&lt;3...\)</span>，任意两个不同的自然数都一定有一个小于另一个，那么自然数集合就构成一个全序关系.</p>
<p>偏序，就是任意两个元素，或者在某种意义上一个小/弱/包含于另一个，或者两个不可比，从而形成一个拓扑关系，比如</p>
<ul>
<li>整除关系，<span class="math inline">\(2|4\)</span> 表示<span
class="math inline">\(2\)</span>能整除<span
class="math inline">\(4\)</span>，而<span
class="math inline">\(3\)</span>就不能整除<span
class="math inline">\(4\)</span>，那么自然数集合能构成一个“关于整除的偏序关系”</li>
<li>包含关系，集合<span class="math inline">\(\{1,2\}\subseteq
\{1,2,4\}\)</span>，而<span
class="math inline">\(\{1,3\}\)</span>和<span
class="math inline">\(\{1,2\}\)</span>就不存在谁包含谁，不同集合之间可以构成一个“关于包含的偏序关系”</li>
<li>全序关系可以理解为特殊的偏序关系</li>
</ul>
<p>对于偏序关系，我们可以赋予小于等于号“<span
class="math inline">\(\leq\)</span>”一个更通用的含义来表示各类偏序，即整除关系的“<span
class="math inline">\(|\)</span>”、包含关系的“<span
class="math inline">\(\subseteq\)</span>”，在偏序问题中可以通用地用“<span
class="math inline">\(\leq\)</span>”来表达，那么莫比乌斯反演可以通用的表达为：</p>
<p>对于一个要求解的问题，表达为函数<span
class="math inline">\(f(n)\)</span>，可以定义一个函数<span
class="math inline">\(g(n)=\sum_{d\leq
n}f(d)\)</span>，则可以反解出<span
class="math inline">\(f(n)=\sum_{d\leq n}\mu(d)g(d)\)</span>.</p>
<p>这里出现了一个函数 <span
class="math inline">\(\mu()\)</span>，称为莫比乌斯函数，<strong>不同的偏序关系下有不同的莫比乌斯函数</strong>.</p>
<p>解释一下上面的变化过程：</p>
<ul>
<li><span class="math inline">\(f(n)\)</span>：一个关于<span
class="math inline">\(n\)</span>的计算任务，<span
class="math inline">\(n\)</span>可以是集合，可以是自然数，作为<span
class="math inline">\(f()\)</span>的输入，<span
class="math inline">\(f()\)</span>可以是集合的子集个数、自然数的约数个数这类计数问题.</li>
<li><span class="math inline">\(g(n)=\sum_{d \leq
n}f(d)\)</span>：一个“强行定义”的函数，这里不用理解为啥这么定义。固定形式就是<span
class="math inline">\(g(n)\)</span>是所有和<span
class="math inline">\(n\)</span>符合偏序关系的<span
class="math inline">\(d\)</span>代入<span
class="math inline">\(f(d)\)</span>的和. 但是通常<span
class="math inline">\(g(n)\)</span>能从另一个角度“讲个故事”，从而发现按这个故事
<strong>用另一种方式很容易计算<span
class="math inline">\(g(n)\)</span></strong> ，这是关键点.</li>
<li><span class="math inline">\(f(n)=\sum_{d\leq
n}\mu(d)g(d)\)</span>：对于特定的偏序关系，莫比乌斯函数<span
class="math inline">\(\mu(d)\)</span>的形式是固定的，而<span
class="math inline">\(g(d)\)</span>如果是一个比较好算的东西，那么我们用<span
class="math inline">\(n\)</span>每个符合偏序关系的<span
class="math inline">\(d\)</span>代入<span
class="math inline">\(\mu(d)g(d)\)</span>再求和，就可能较为容易的算出我们要的<span
class="math inline">\(f(n)\)</span>了.</li>
</ul>
<p>以上就是莫比乌斯反演的典型形式和用途，这里需要一个例子更好去理解，我们就用“集合包含于”这个偏序关系举例吧：</p>
<p>有<span class="math inline">\(n\)</span>个字母组成的集合<span
class="math inline">\(S\)</span>，<span
class="math inline">\(n\)</span>个小孩，小孩编号的全集为<span
class="math inline">\(X_{n}\)</span>，他们分别有自己不喜欢的字母，比如有<span
class="math inline">\(S=\{a,b,c\}\)</span>共<span
class="math inline">\(3\)</span>个字母，有小孩<span
class="math inline">\(X_{n}=\{1,2,3\}\)</span>，<span
class="math inline">\(1\)</span>号小孩不喜欢<span
class="math inline">\(A_{1}=\{a,c\}\)</span>，<span
class="math inline">\(2\)</span>号小孩不喜欢<span
class="math inline">\(A_{2}=\{c\}\)</span>，<span
class="math inline">\(3\)</span>号小孩不喜欢<span
class="math inline">\(A_{3}=\{a\}\)</span>，那么哪些字母是所有小孩都喜欢的？答案是<span
class="math inline">\(1\)</span>个字母，是<span
class="math inline">\(\{b\}\)</span>.</p>
<p>这个问题的数学化描述是</p>
<ul>
<li>设全集为 <span class="math inline">\(S=\{a,b,\cdots
\}\)</span>;</li>
<li><span
class="math inline">\(n\)</span>个小孩每个小孩不喜欢的字母集合分别为<span
class="math inline">\(A_{1}, A_{2}, \cdots, A_{n}\)</span>;</li>
<li>其中每个<span class="math inline">\(A_{i}=\{若干个S中的字母
\}\)</span>;</li>
<li>求 <span class="math inline">\(|\bar{A_{1}}\cap \bar{A_{2}} \cap
\cdots \cap \bar{A_{n}}|\)</span>，其中 <span
class="math inline">\(\bar{A_{i}}\)</span> 表示<span
class="math inline">\(A_{i}\)</span>的补集，“<span
class="math inline">\(||\)</span>” 表示求集合元素个数.</li>
</ul>
<p>你可能看出来这是容斥原理模型，但我们先假设这是个比较难算的问题。</p>
<p>定义一个拗口的函数 <span
class="math inline">\(f(K)\)</span>，其中<span
class="math inline">\(K\)</span> 表示<span
class="math inline">\(X_{n}\)</span> 的子集，或者说是<span
class="math inline">\(A_{i}\)</span>的序号——不同的<span
class="math inline">\(i\)</span>组成的集合，比如 <span
class="math inline">\(K=\{1,2\}\)</span>表示<span
class="math inline">\(1\)</span>和<span
class="math inline">\(2\)</span>这两个序号，<span
class="math inline">\(f(K)\)</span> 这个函数求的是“序号不在<span
class="math inline">\(K\)</span>中的那些<span
class="math inline">\(A_{i}\)</span>集合的交集，且去掉所有序号在<span
class="math inline">\(K\)</span>中的那些<span
class="math inline">\(A_{j}\)</span>的元素之后，剩下的元素个数”.</p>
<p>举个例子：<span class="math inline">\(𝐴_{1} = \{𝑎, 𝑏, 𝑐\}\)</span>，
<span class="math inline">\(𝐴_{2} = \{𝑎, 𝑐\}\)</span>， <span
class="math inline">\(𝐴_{3} = \{𝑐, d, e\}\)</span>， <span
class="math inline">\(𝐴_{4} = \{𝑐, d, e, 𝑓\}\)</span>，<span
class="math inline">\(𝑋_{𝑛} = \{1,2,3,4\}\)</span>，如果<span
class="math inline">\(K=\{1,2\}\)</span>，则序号在<span
class="math inline">\(K\)</span>中的 <span class="math inline">\(A_{1},
A_{2}\)</span>中出现过的<span class="math inline">\(\{a, b, c\}\)</span>
都要被排除，序号不在<span class="math inline">\(K\)</span>中的<span
class="math inline">\(A_{3},A_{4}\)</span>的交集是<span
class="math inline">\(\{c,d,e\}\)</span>，但要排除前面的<span
class="math inline">\(\{a,b,c\}\)</span>，所以<span
class="math inline">\(f(K)\)</span>计数的是<span
class="math inline">\(\{d,e\}\)</span>，也就是 <span
class="math inline">\(f(K)=2\)</span>.</p>
<p><span class="math inline">\(f(K)\)</span>这个函数是个啥呢？
把序号全集<span class="math inline">\(X_{n}\)</span>
代进去，你会发现，<span class="math inline">\(f(X_{n})\)</span>
就是我们要求的<span class="math inline">\(|\bar{A_{1}}\cap \bar{A_{2}}
\cap \cdots \cap \bar{A_{n}}|\)</span>.</p>
<p><span class="math inline">\(f(K)\)</span>
是不是一看就好难算的样子？那么我们开始尝试莫比乌斯反演.</p>
<p>按照莫比乌斯反演的流程，我们设</p>
<p><span class="math inline">\(g(K)=\sum\limits_{D\subseteq
K}f(D)\)</span></p>
<p>这里不用通用的偏序符号“<span
class="math inline">\(\leq\)</span>”而用集合的“包含于”符号“<span
class="math inline">\(\subseteq\)</span>”以免不习惯，套反演公式得</p>
<p><span class="math inline">\(f(K)=\sum\limits_{D\subseteq
K}\mu(D,K)g(D)\)</span></p>
<p>按前面的介绍，<span
class="math inline">\(g(K)\)</span>应该是个容易计算的东西，那我们试着给<span
class="math inline">\(g(K)\)</span>讲个故事：</p>
<p>观察<span class="math inline">\(g(K)=\sum\limits_{D\subseteq
K}f(D)\)</span> ，它是对于<span
class="math inline">\(K\)</span>的所有子集<span
class="math inline">\(D\)</span>，“序号不在<span
class="math inline">\(D\)</span>中的那些<span
class="math inline">\(A_{i\notin
D}\)</span>集合的交集，且去掉所有序号在<span
class="math inline">\(D\)</span>中的那些<span
class="math inline">\(A_{j\in
D}\)</span>的元素之后，剩下的元素个数，枚举每个<span
class="math inline">\(D\)</span>得到的结果的总和”
，更拗口了！这是个啥呢？</p>
<p>它表示的其实是“序号不在<span
class="math inline">\(K\)</span>中的那些<span
class="math inline">\(A_{i}\)</span>集合的交集元素个数”. 相对<span
class="math inline">\(f(K)\)</span>的区别是不用去掉“序号在<span
class="math inline">\(K\)</span>中的那些<span
class="math inline">\(A_{j}\)</span>”的元素了.</p>
<p>数学表述为 <span class="math inline">\(g(K)=\sum\limits_{D\subseteq
K}f(D)=|\cap_{i\notin K} A_{i} |\)</span>. 证明：</p>
<p>可以这样考虑，对于每个元素<span
class="math inline">\(s\)</span>，它在计数时对<span
class="math inline">\(g(K)\)</span>是否有贡献. 对于每个<span
class="math inline">\(s\)</span>，所有包含<span
class="math inline">\(s\)</span>的序号集合<span
class="math inline">\(M\)</span>（<span class="math inline">\(M=\{i|s\in
A_{i}\}\)</span>）， 如果<span class="math inline">\(X_{n}-M \subseteq
K\)</span>，那么<span class="math inline">\(s\)</span>对<span
class="math inline">\(g(K)\)</span>有贡献. 而<span
class="math inline">\(X_{n}-M \subseteq K \Leftrightarrow X_{n}-K
\subseteq M\)</span>，而<span class="math inline">\(X_{n}-K \subseteq
M\)</span> 意味着<span class="math inline">\(s\)</span>对<span
class="math inline">\(|\cap_{i\notin K} A_{i}
|\)</span>有贡献，从而说明，每个对<span
class="math inline">\(g(K)\)</span>有贡献的<span
class="math inline">\(s\)</span>，刚好对应着对<span
class="math inline">\(|\cap_{i\notin K} A_{i} |\)</span>有贡献，即 <span
class="math inline">\(g(K)=|\cap_{i\notin K} A_{i} |\)</span>.</p>
<p>“<span class="math inline">\(|\cap_{i\notin K} A_{i} |\)</span> ”
这个表述可就不拗口了，它就是“序号不在<span
class="math inline">\(K\)</span>中的集合<span
class="math inline">\(A_{i\notin
K}\)</span>交集元素个数”，它的计算要简单得多，也即我们找到了一个容易计算的<span
class="math inline">\(g(K)\)</span>，来利用莫比乌斯反演计算<span
class="math inline">\(f(K)\)</span>.</p>
<p>这里回顾一下上面的问题及莫比乌斯反演过程：</p>
<ul>
<li>每个小孩有不喜欢的字母，我们要求所有小孩都喜欢的字母；</li>
<li>设<span class="math inline">\(f(K)\)</span> 是“序号不在<span
class="math inline">\(K\)</span>中的那些<span
class="math inline">\(A_{i\notin K}\)</span>的交集且去掉序号在<span
class="math inline">\(K\)</span>中的所有<span
class="math inline">\(A_{j\in K}\)</span>元素的总数；</li>
<li>则<span
class="math inline">\(f(X_{n})\)</span>就是所求目标，也即<span
class="math inline">\(|\bar{A_{1}}\cap \bar{A_{2}} \cap \cdots \cap
\bar{A_{n}}|\)</span></li>
<li>设<span class="math inline">\(g(K)=\sum\limits_{D\subseteq
K}f(D)\)</span>，而<span
class="math inline">\(g(K)\)</span>是一个容易计算的问题，<span
class="math inline">\(g(K)=|\cap_{i\notin K} A_{i} |\)</span>；</li>
<li>莫比乌斯反演得 <span
class="math inline">\(f(K)=\sum\limits_{D\subseteq
K}\mu(D,K)g(D)\)</span></li>
</ul>
<p>还剩最后一步，<span class="math inline">\(\mu(D,K)\)</span>
是个啥.</p>
<p>不同的偏序关系下有不同的莫比乌斯函数，这个问题是定义在“包含关系<span
class="math inline">\(\subseteq\)</span>”的偏序集上的，包含关系偏序集的莫比乌斯函数是
<span
class="math inline">\(\mu(A,B)=(-1)^{|B|-|A|}\)</span>，它可以通过数学归纳法证明，这里证明过程略，感兴趣可以查阅组合数学相关资料.</p>
<p>最终呈现整个问题的答案：</p>
<p><span class="math display">\[
\begin{align*}
&amp; f(X_{n}) \\
&amp; = |\bar{A_{1}}\cap \bar{A_{2}} \cap \cdots \cap \bar{A_{n}}| \\
&amp; = \sum\limits_{D\subseteq X_{n}}\mu(D,X_{n})g(D) \\
&amp; = \sum\limits_{D\subseteq K}(-1)^{|X_{n}-|D|}|\cap_{i\notin D}
A_{i} | \\
&amp; = \sum\limits_{J\subseteq K}(-1)^{J}|\cap_{i\in J} A_{i} | \\
\end{align*}
\]</span></p>
<p>最后一步用<span class="math inline">\(D\)</span>的补集<span
class="math inline">\(J=X_{n}-D\)</span>做了换元.</p>
<p>到这里就完成了例题的解答，这就是容斥原理公式啊！<strong>容斥原理是莫比乌斯反演在有限偏序集上的一个实例</strong>.</p>
<p>大家可能会感兴趣其它的偏序关系的莫比乌斯函数是什么样呢？这里不加证明地给出两个：</p>
<ul>
<li><p>线性有序集，即最直观的<span
class="math inline">\(X_{n}=\{1,2,\cdots,n\}, 1&lt;2&lt;\cdots&lt;
n\)</span></p>
<p><span class="math inline">\(\mu(k,l)=\left \{ \begin{matrix}1 &amp;
l=k \\ -1 &amp; l=k+1 \\ 0 &amp;
other\end{matrix}\right.\)</span></p></li>
<li><p>整除关系，比如<span class="math inline">\(3\)</span> 能整除 <span
class="math inline">\(6\)</span> 即写作“<span
class="math inline">\(3|6\)</span>”，因为<span
class="math inline">\(\mu()\)</span>用在枚举符合偏序关系的对象的时候，从而如果<span
class="math inline">\(a|b\)</span>则<span
class="math inline">\(\mu(a,b)=\mu(1,\frac{b}{a})\)</span>，于是知道任意<span
class="math inline">\(n\)</span>的<span
class="math inline">\(\mu(1,n)\)</span>即可，省略“<span
class="math inline">\(1\)</span>”简写为<span
class="math inline">\(\mu(n)\)</span></p>
<p><span class="math inline">\(\mu(n)=\left \{ \begin{matrix}1 &amp; n=1
\\ (-1)^k &amp; n是k个互不相同质数之积 \\ 0 &amp;
other\end{matrix}\right.\)</span></p></li>
</ul>
<p>这里“n是k个互不相同质数之积”指<span
class="math inline">\(n\)</span>的因数分解对应<span
class="math inline">\(k\)</span>个质数，且每个质数仅出现 1 次，比如
<span
class="math inline">\(6=2*3\)</span>，而如果有任何质因数出现多于一次，比如<span
class="math inline">\(12=2*2*3\)</span>，<span
class="math inline">\(\mu(12)=0\)</span>就是<span
class="math inline">\(other\)</span>的情况.</p>
<p>虽然不同偏序关系的莫比乌斯函数不同，但我们常见的这类问题其实不多，记几个常见的通常就够用了.</p>
<h3 id="若干定义">1. 若干定义</h3>
<p>算法竞赛中莫比乌斯反演题目一般是处理数论问题，考虑整除关系、最大公约数、最小公倍数这些，以下内容都围绕这类问题阐述.</p>
<ul>
<li>数论函数：定义域为正整数集的函数</li>
<li>积性函数：对于互质的整数<span
class="math inline">\(a,b\)</span>，有<span
class="math inline">\(f(ab)=f(a)f(b)\)</span>的函数
<ul>
<li><span class="math inline">\(\phi(n)\)</span>：欧拉函数，不大于<span
class="math inline">\(n\)</span>的与<span
class="math inline">\(n\)</span>互质的数的个数</li>
<li><span
class="math inline">\(\mu(n)\)</span>：莫比乌斯函数，<strong>这里以及下文特指整除关系偏序下的莫比乌斯函数</strong></li>
</ul></li>
<li>完全积性函数：对<span
class="math inline">\(a,b\)</span>没有互质限制的<span
class="math inline">\(f(ab)=f(a)f(b)\)</span>的函数
<ul>
<li><span
class="math inline">\(\epsilon(n)=[n=1]\)</span>：单位函数，<span
class="math inline">\(n\)</span>为1时函数值为<span
class="math inline">\(1\)</span>，否则为<span
class="math inline">\(0\)</span>的函数</li>
<li><span class="math inline">\(id(n)=n\)</span>：恒等函数</li>
<li><span class="math inline">\(1(n)=1\)</span>：常数函数</li>
</ul></li>
<li>狄利克雷卷积：<span
class="math inline">\((f*g)(n)=\sum\limits_{d|n}f(d)g(\frac{n}{d})\)</span>，像是“函数之间的乘法”，满足交换律、结合律</li>
</ul>
<p>下文中的莫比乌斯函数都指整除偏序关系中的莫比乌斯函数，即：</p>
<p><span class="math display">\[
\mu(n)=\left \{ \begin{matrix}1 &amp; n=1 \\ (-1)^k &amp;
n是k个互不相同质数之积 \\ 0 &amp; other\end{matrix}\right.
\]</span></p>
<p>且它有<strong>这样一个性质</strong>：</p>
<p><span class="math display">\[
(\mu * 1)(n)=\sum\limits_{d|n}\mu(d)=\epsilon(n)=[n=1]
\]</span></p>
<p>证明：设<span
class="math inline">\(n=\prod\limits_{i=1}^{k}p_{i}^{c_{i}}\)</span>，<span
class="math inline">\(n&#39;=\prod\limits_{i=1}^{k}p_{i}\)</span></p>
<p><span
class="math inline">\(\sum\limits_{d|n}\mu(d)=\sum\limits_{d|n&#39;}\mu(d)=\sum\limits_{i=1}^{k}C_{k}^{i}\cdot(-1)^{i}=(1+(-1))^{k}\)</span></p>
<p>仅当<span class="math inline">\(k=0\)</span>时值为1，<span
class="math inline">\(k=0\)</span>对应着<span
class="math inline">\(n=1\)</span>.</p>
<p>以上是下文会用到的东西，放在这里以便遇到的时候查询.</p>
<h3 id="数论分块">2. 数论分块</h3>
<p>这个话题出现在这里有点突兀，但莫比乌斯反演题目经常会需要数论分块，所以这里我们也了解一下.</p>
<p>我们会遇到“除法向下取整的求和问题”： <span
class="math inline">\(\sum\limits_{i=1}^{n}\lfloor \frac{n}{i}
\rfloor\)</span></p>
<p>如果<span class="math inline">\(n\)</span>很大，直接循环累加<span
class="math inline">\(O(n)\)</span>的复杂度是无法接受的. 我们会发现
<span class="math inline">\(\lfloor \frac{n}{i} \rfloor\)</span>
的值其实是分段的，由一段又一段相等的值组成，我们只要计算出每一段的起止位置，就可以加速整个过程.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">    j = n / (n / i);</span><br><span class="line">    ret += (n / i) * (j - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对每一段的起点 <span class="math inline">\(i\)</span>，对于区间 <span
class="math inline">\([i, \lfloor \frac{n}{\lfloor\frac{n}{i}\rfloor}
\rfloor]\)</span>上的所有 <span class="math inline">\(x\)</span>，<span
class="math inline">\(\lfloor \frac{n}{x} \rfloor\)</span>
都是相等的.</p>
<p>问题提高点难度：<span
class="math inline">\(\sum\limits_{i=1}^{n}\lfloor \frac{n}{i} \rfloor
\lfloor \frac{m}{i} \rfloor, n&lt; m\)</span></p>
<p>原理类似，虽然<span class="math inline">\(\lfloor \frac{n}{i}
\rfloor\)</span> 和 <span class="math inline">\(\lfloor \frac{m}{i}
\rfloor\)</span>
各自的区间起止点可能不重叠，但我们可以细分每一个它俩都稳定的小段，代码是类似的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">    j = std::<span class="built_in">min</span>(n / (n / i), m / (m / i));</span><br><span class="line">    ret += (n / i) * (m / i) * (j - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意，<strong>括号不能乱删</strong>，存在除法向下取整的问题不能随便修改计算顺序.</p>
<p>再进一步，计算<span
class="math inline">\(\sum\limits_{i=1}^{n}\mu(i)\lfloor \frac{n}{i}
\rfloor \lfloor \frac{m}{i} \rfloor, n&lt; m\)</span></p>
<p>也没有很麻烦，我们预处理莫比乌斯函数 <span
class="math inline">\(\mu()\)</span>，并处理好它的前缀和，就可以融入到数论分块里了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">    j = std::<span class="built_in">min</span>(n / (n / i), m / (m / i));</span><br><span class="line">    ret += (n / i) * (m / i) * (mup[j] - mup[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>mup[j]</code> 表示莫比乌斯函数前<span
class="math inline">\(j\)</span>项和 <span
class="math inline">\(\sum\limits_{t=1}^{j}\mu(t)\)</span></p>
<h3 id="莫比乌斯函数线性筛">3. 莫比乌斯函数线性筛</h3>
<p>在开始莫比乌斯反演之旅前，我们再解决一个问题，莫比乌斯函数的计算.</p>
<p>那一句“n是k个互不相同质数之积”，说得轻巧，对每个<span
class="math inline">\(n\)</span>做一遍质因数分解，这复杂度也略高了.</p>
<p>其实<span class="math inline">\(\mu(n)\)</span>
也可以类似质数、欧拉函数那样筛出来.</p>
<p>大致原理是在筛质数的过程中，对每个新处理的数<code>i</code>，枚举所有已发现的质数<code>prm[j]</code>，如果<code>prm[j]</code>是<code>i</code>的约数，则<code>prm[j]*i</code>的质因数中<code>prm[j]</code>超过<code>1</code>个，其莫比乌斯函数是<code>mu[prm[j]*i]=0</code>，否则<code>prm[j]*i</code>比<code>i</code>多<code>1</code>个质因数，其莫比乌斯函数是<code>mu[prm[j]*i]=-mu[i]</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; mu, prm, mup;  <span class="comment">// mu为莫比乌斯函数，prm为质数表，mup为莫比乌斯函数前缀和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MuList</span><span class="params">(<span class="type">int</span> mxn)</span> </span>&#123;</span><br><span class="line">    mu.<span class="built_in">resize</span>(mxn + <span class="number">10</span>); mup.<span class="built_in">resize</span>(mxn + <span class="number">10</span>);</span><br><span class="line">    std::<span class="built_in">fill</span>(mu.<span class="built_in">begin</span>(), mu.<span class="built_in">end</span>(), <span class="number">-2</span>);</span><br><span class="line">    mu[<span class="number">1</span>] = mup[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    prm.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= mxn; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mu[i] == <span class="number">-2</span>) prm.<span class="built_in">push_back</span>(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; prm.<span class="built_in">size</span>() &amp;&amp; i * prm[j] &lt;= mxn; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % prm[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prm[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * prm[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= mxn; i ++) mup[i] = mup[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整除关系中的莫比乌斯反演">4. 整除关系中的莫比乌斯反演</h3>
<p>回顾第0节的典型形式：</p>
<ul>
<li>已知<span class="math inline">\(f(n)\)</span>是一个数论函数</li>
<li>设<span
class="math inline">\(g(n)=\sum\limits_{d|n}f(d)\)</span></li>
<li>则<span
class="math inline">\(f(n)=\sum\limits_{d|n}\mu(d)g(\frac{n}{d})\)</span></li>
</ul>
<p>不过它还有另一个形式：</p>
<ul>
<li>设<span
class="math inline">\(g(n)=\sum\limits_{n|d}f(d)\)</span></li>
<li>则<span
class="math inline">\(f(n)=\sum\limits_{n|d}\mu(\frac{d}{n})g(d)\)</span></li>
</ul>
<p>主要区别在于，前一种形式，和式枚举的是每一个能整除<span
class="math inline">\(n\)</span>的<span
class="math inline">\(d\)</span>（<span class="math inline">\(d\leq
n\)</span>），而后一种形式，和式枚举的是每一个<span
class="math inline">\(n\)</span>能整除的<span
class="math inline">\(d\)</span>（<span class="math inline">\(n\leq
d\)</span>）.</p>
<p>简要证明：<span class="math inline">\(g*\mu=f*1*\mu = f*\epsilon =
f\)</span></p>
<h3 id="算法竞赛中的莫比乌斯反演套路">5.
算法竞赛中的莫比乌斯反演套路</h3>
<p>先用 例1 感受这类问题的解决推导过程，然后建议对照第 5.6
节典型套路尝试推导例2～例5.</p>
<h4 id="例1">5.1 例1</h4>
<p>求<span
class="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[gcd(i,j)=1],
(n&lt; m)\)</span></p>
<p>设</p>
<ul>
<li><span
class="math inline">\(f(x)=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[gcd(i,j)=x]\)</span></li>
<li><span class="math inline">\(g(x)=\sum\limits_{x|d}f(d)\)</span></li>
<li><span
class="math inline">\(f(x)=\sum\limits_{x|d}\mu(\frac{d}{x})g(d)\)</span></li>
</ul>
<p>其中 <span
class="math inline">\(g(x)=\sum\limits_{x|d}f(d)=\sum\limits_{x|d}\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[gcd(i,j)=d]\)</span>求的<span
class="math inline">\(gcd(i,j)\)</span>是<span
class="math inline">\(x\)</span>的倍数的所有情况，其实就是 <span
class="math inline">\(\lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{x}
\rfloor\)</span>.</p>
<p>于是 <span class="math inline">\(f(x)
=\sum\limits_{x|d}\mu(\frac{d}{x})\lfloor \frac{n}{d} \rfloor \lfloor
\frac{m}{d} \rfloor\)</span></p>
<p>回到题目，我们要求的是<span
class="math inline">\(x=1\)</span>的情况，故</p>
<p><span class="math display">\[
\begin{align*}
f(1) &amp; =\sum\limits_{1|d}\mu(\frac{d}{1})\lfloor \frac{n}{d} \rfloor
\lfloor \frac{m}{d} \rfloor \\
&amp; = \sum\limits_{d=1}^{n}\mu(d)\lfloor \frac{n}{d} \rfloor \lfloor
\frac{m}{d} \rfloor
\end{align*}
\]</span></p>
<p>这里用上一节的数论分块就搞定了.</p>
<p>不过，每次推导都要设置<span class="math inline">\(f\)</span>和<span
class="math inline">\(g\)</span>两个函数以及进行莫比乌斯反演的流程可能稍觉麻烦，其实利用第
1 节的性质</p>
<p><span class="math inline">\((\mu *
1)(n)=\sum\limits_{d|n}\mu(d)=\epsilon(n)=[n=1]\)</span></p>
<p><strong>很多题目都可以直接等价变换而不需要做一遍反演</strong>.</p>
<p>还以这道题为例，求<span
class="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[gcd(i,j)=1],
(n&lt; m)\)</span>，因为</p>
<p><span
class="math inline">\(\sum\limits_{d|gcd(i,j)}\mu(d)=\epsilon(gcd(i,j))=[gcd(i,j)=1]\)</span></p>
<p>式子可直接化为</p>
<p><span
class="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\sum\limits_{d|gcd(i,j)}\mu(d)\)</span></p>
<p>作求和顺序交换，原则是对求和枚举变量的范围“入内求交，出外求并”，这个知识点可另外了解.</p>
<p><span
class="math inline">\(\sum\limits_{d=1}^{n}\mu(d)\sum\limits_{d|i}^{n}\sum\limits_{d|j}^{m}1=\sum\limits_{d=1}^{n}\mu(d)\lfloor
\frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor\)</span></p>
<p>得到了相同的结果.</p>
<h4 id="例2">5.2 例2</h4>
<p><span
class="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[gcd(i,j)=k],
(n&lt; m)\)</span><br />
解：<span class="math inline">\(\sum\limits_{i=1}^{\lfloor
\frac{n}{k}\rfloor}\sum\limits_{j=1}^{\lfloor
\frac{m}{k}\rfloor}[gcd(i,j)=1], (n&lt; m)\)</span>，然后同例1.</p>
<h4 id="例3">5.3 例3</h4>
<p><span
class="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}ij[gcd(i,j)=k],
(n&lt; m)\)</span><br />
解：<span class="math inline">\(k^{2}\cdot \sum\limits_{d=1}^{\lfloor
\frac{n}{k}\rfloor}\mu(d)\cdot d^2
\cdot\sum\limits_{i=1}^{\lfloor\frac{n}{kd}\rfloor}i \cdot
\sum\limits_{j=1}^{\lfloor\frac{m}{kd}\rfloor}j\)</span>，后两个和式是等差数列求和，前面的一样预处理前缀和，整体上数论分块.</p>
<h4 id="例4">5.4 例4</h4>
<p><span
class="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}lcm(i,j),
(n&lt; m)\)</span><br />
解：<span class="math inline">\(\sum\limits_{d=1}\limits^{n}
d\sum\limits_{t=1}\limits^{\lfloor \frac{n}{d} \rfloor}t^2\mu(t)
\sum\limits_{i}\limits^{\lfloor \frac{n}{td} \rfloor
}\sum\limits_{j}\limits^{\lfloor \frac{m}{td} \rfloor } ij\)</span>，见
<a
href="./luoguP1829.md">luoguP1829<code>[国家集训队]Crash的数字表格 / JZPTAB</code></a></p>
<h4 id="例5">5.5 例5</h4>
<p><span
class="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}d(i\cdot
j), (n&lt; m)\)</span>，其中<span
class="math inline">\(d(k)\)</span>表示<span
class="math inline">\(k\)</span>的约数个数<br />
解：<span
class="math inline">\(\sum\limits_{d}^{\min(n,m)}\mu(d)(\sum_{x=1}^{\lfloor
\frac{n}{d} \rfloor}\lfloor \frac{n}{xd} \rfloor)(\sum_{y=1}^{\lfloor
\frac{m}{d} \rfloor}\lfloor \frac{m}{yd} \rfloor)\)</span>，见<a
href="./luoguP3327.md">luoguP3327<code>[SDOI2015]约数个数和</code></a></p>
<h4 id="典型套路">5.6 典型套路</h4>
<ol type="1">
<li><p><span class="math inline">\(LCM(a,b)\)</span>可转为<span
class="math inline">\(\frac{ab}{gcd(a,b)}\)</span>.</p></li>
<li><p><span class="math inline">\(\sum \sum gcd(a,b)\)</span>
可转为条件求和 <span class="math inline">\(\sum\limits_{d} \sum\sum
[gcd(a,b)==d]\)</span></p></li>
<li><p>条件求和<span
class="math inline">\(\sum\limits^{n}\sum\limits^{m}
[gcd(a,b)==d]\)</span>可通过换元变为<span
class="math inline">\(\sum\limits^{\lfloor \frac{n}{d}
\rfloor}\sum\limits^{\lfloor \frac{m}{d} \rfloor}
[gcd(a^{&#39;},b^{&#39;})==1]\)</span></p>
<p>类似的另一种形式<span
class="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[d|gcd(i,j)]
\Leftrightarrow \sum\limits_{i=1}^{\lfloor \frac{n}{d}
\rfloor}\sum\limits_{j=1}^{\lfloor \frac{m}{d}
\rfloor}1\)</span>，即用枚举<span
class="math inline">\(xd,jd\)</span>替代枚举<span
class="math inline">\(i,j\)</span>消除<span
class="math inline">\([d|gcd(i,j)]\)</span>.</p></li>
<li><p>可转为莫比乌斯函数表示 <span class="math inline">\([gcd(a,b)==1]
\Leftrightarrow \sum\limits_{d|gcd(a,b)}\mu(d)\)</span></p></li>
<li><p>求和顺序交换以消除枚举<span
class="math inline">\(d|gcd(i,j)\)</span> <span class="math display">\[
\sum\limits_{i=1}\limits^{n}
\sum\limits_{j=1}\limits^{m} ij
\sum\limits_{d|gcd(i,j)}\mu(d)
\Leftrightarrow
\sum\limits_{d=1}\limits^{\min(n,m)}\mu(d)
\sum\limits_{d|i}\limits^{n}
\sum\limits_{d|j}\limits^{m} ij
\]</span></p></li>
<li><p>枚举约数改为枚举全部，观察等价关系： <span
class="math display">\[
\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\sum_{x|i}\sum_{y|j}
\Leftrightarrow
\sum_{x=1}^{n}\sum_{y=1}^{m} \lfloor \frac{n}{x} \rfloor \lfloor
\frac{m}{y}\rfloor
\]</span> 由所有<span
class="math inline">\(i,j\)</span>的所有约数和变为枚举所有约数对其倍数的总贡献.</p></li>
<li><p><span class="math inline">\(\sum\limits_{d|i}^{n} i\)</span>
可以换元消除约束条件 <span
class="math inline">\(\sum\limits_{i^{&#39;}}^{\lfloor
\frac{n}{d}\rfloor}i^{&#39;}\)</span></p></li>
<li><p>求和提前，式中加“<code>[]</code>”条件： <span
class="math inline">\(\sum\limits_{x|i}\sum\limits_{y|j}\sum\limits_{p|gcd(x,y)}\mu(p)=\sum\limits_{p=1}^{min(i,j)}\sum\limits_{x|i}\sum\limits_{y|j}[p|gcd(x,y)]\mu(p)\)</span>，相当于把内层<code>for</code>循环提到外层，内层则增加了<code>if</code>.</p></li>
<li><p><span class="math inline">\(\sum\sum [gcd(i,j)=p]\)</span>
这类问题适合莫反，设<span
class="math inline">\(f(x)=\sum\sum[gcd(i,j)=x]\)</span>，则<span
class="math inline">\(g(x)=\sum\limits_{x|d}f(d)\)</span>，从而莫反得到<span
class="math inline">\(f(x)=\sum\limits_{x|d}\mu(\lfloor \frac{d}{x}
\rfloor)g(d)\)</span></p></li>
<li><p><span
class="math inline">\(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\sum\limits_{x|d}[gcd(i,j)=d]=\lfloor
\frac{n}{d} \rfloor \lfloor \frac{m}{d}
\rfloor\)</span>，即最大公约数为<span
class="math inline">\(x\)</span>的所有倍数的个数.</p></li>
</ol>
<h3 id="基础题单">6. 基础题单</h3>
<p>其实就对应着上文的例题</p>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 15%" />
<col style="width: 32%" />
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="header">
<th>序号</th>
<th>题号</th>
<th>标题</th>
<th>题型</th>
<th>难度评级</th>
<th style="text-align: left;">题解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>luogu P3455</td>
<td>[POI2007]ZAP-Queries</td>
<td>整除关系的计数问题</td>
<td>⭐⭐</td>
<td style="text-align: left;"><a
href="https://github.com/CSGrandeur/icpc_solution/blob/master/solutions/Math/NumberTheory/MobiusInversion/luoguP3455.md">👍</a></td>
</tr>
<tr class="even">
<td>2</td>
<td>luogu P2522</td>
<td>[HAOI2011]Problem b</td>
<td>整除关系的计数问题</td>
<td>⭐⭐⭐</td>
<td style="text-align: left;"><a
href="https://github.com/CSGrandeur/icpc_solution/blob/master/solutions/Math/NumberTheory/MobiusInversion/luoguP2522.md">👍</a></td>
</tr>
<tr class="odd">
<td>3</td>
<td>luogu P2257</td>
<td>YY的GCD</td>
<td>整除关系的计数问题</td>
<td>⭐⭐⭐</td>
<td style="text-align: left;"><a
href="https://github.com/CSGrandeur/icpc_solution/blob/master/solutions/Math/NumberTheory/MobiusInversion/luoguP2257.md">👍</a></td>
</tr>
<tr class="even">
<td>4</td>
<td>luogu P3327</td>
<td>[SDOI2015]约数个数和</td>
<td>整除关系的计数问题</td>
<td>⭐⭐⭐⭐</td>
<td style="text-align: left;"><a
href="https://github.com/CSGrandeur/icpc_solution/blob/master/solutions/Math/NumberTheory/MobiusInversion/luoguP3327.md">👍</a></td>
</tr>
<tr class="odd">
<td>5</td>
<td>luogu P1829</td>
<td>[国家集训队]Crash的数字表格 / JZPTAB</td>
<td>整除关系的计数问题</td>
<td>⭐⭐⭐⭐</td>
<td style="text-align: left;"><a
href="https://github.com/CSGrandeur/icpc_solution/blob/master/solutions/Math/NumberTheory/MobiusInversion/luoguP1829.md">👍</a></td>
</tr>
<tr class="even">
<td>6</td>
<td>SPOJ LCMSUM</td>
<td>LCM Sum</td>
<td>整除关系的计数问题</td>
<td>⭐⭐⭐⭐</td>
<td style="text-align: left;"><a
href="https://github.com/CSGrandeur/icpc_solution/blob/master/solutions/Math/NumberTheory/MobiusInversion/SPOJ-LCMSUM.md">👍</a></td>
</tr>
</tbody>
</table>
<h3 id="参考资料">参考资料</h3>
<ol type="1">
<li>Richard A. Brualdi著, 冯速等译. 组合数学(原书第5版). 北京:
机械工业出版社, 2012</li>
<li><a href="https://oi-wiki.org/math/number-theory/mobius/">oi-wiki
莫比乌斯反演</a></li>
<li><a
href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">An_Account
莫比乌斯反演-让我们从基础开始</a></li>
<li><a href="https://www.cnblogs.com/peng-ym/p/8647856.html">peng-ym
莫比乌斯反演</a></li>
</ol>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>与我有关，又似乎不再那么有关</title>
    <url>/2022-11-14-notaboutcsuacm/</url>
    <content><![CDATA[<p>距离ACM退役正好十年整，最近两周CSU先拿下ICPC区域赛第五，再赢得CCPC分站赛冠军，尘封十年的历史成绩被井喷式突破，CSUACMer的一场狂欢。</p>
<span id="more"></span>
<img src="/2022-11-14-notaboutcsuacm/icpc.jpg" class="">
<img src="/2022-11-14-notaboutcsuacm/cc.png" class="">
<img src="/2022-11-14-notaboutcsuacm/c2.png" class="">
<p>十年来新题型层出不穷，高考政策的变化也让湖南高校多了很多OI选手，CSU如今的主力队员实力不可同日而语。</p>
<p>朋友圈刷屏了师兄们和师弟们的欢欣。也算是第一时间为大家转发这些消息和截图的我，开心之余却不免心里空了一块。</p>
<p>本不想煞风景专门来写一篇日志，然而昨晚竟然还梦见教练陈老师了，今早醒来，复杂的情绪一时难以控制。</p>
<p>那年的校排第7，在最终的全赛区Z字形排名中取前16Final名额而差了一名，是赛场第七题的一念之差，还是那几次提交的罚时。</p>
<p>遗憾往往不是没有得到，而是一步之遥。</p>
<p>Word Final
成为了CSUACMer的执念，或许更多的是我的执念。曾以为会像电影与小说中那样，有一天成为CSU的教练，换一种身份圆梦，也是一种不完美中的完美。然而现实总不那么容易随人愿。</p>
<p>梦想实现了一半，与我有关，又似乎不再那么有关。</p>
<p>这大概是更现实的平凡人生吧。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么做了CSGOJ，又为什么继续做CSGOJ</title>
    <url>/2023-10-16-CSGOJ-Why/</url>
    <content><![CDATA[<p>CSGOJ指本人开发的一个算法竞赛在线评测系统，OJ即Online
Judge，CSG取自竞赛生涯的ID：CSGrandeur的前三个字母，同时有
长沙/中南（Central
Source）/反恐精英（FPS游戏，Counter-Strike）/计算机（Computer
Science）等若干与我人生相关的缩写 CS + 姓首字母 G</p>
<span id="more"></span>
<h3 id="一缘起">一、缘起</h3>
<p>2012年ACM退役，被研究生老板拉去搞省赛的环境，时间仓促环境都被指定好了，硬着头皮在Windows下体验了一把<span
class="math inline">\(PC^2\)</span>，那疯狂的5小时至今难忘。百般劝说下省赛决定之后用OJ，也是在World
Final的<span
class="math inline">\(PC^2\)</span>大潮下较早使用OJ的省赛之一了吧。</p>
<p>那么就提前开始准备第二年的省赛，在当时最有名的国内开源OJ——HUSTOJ上二次开发，因为省赛有一些特定的团队排名需求，且当时受到之前在武汉打华中南邀请赛时Web提交打印的启发，当时就有了做一站式OJ的想法，把代码打印、气球管理一起做进系统，如果cnblogs（博客园）没挂的话，或许还能找到当年“ajax初尝试”的博客。</p>
<p>另外觉得当时的 vjudge
的滚动rank很炫酷（就是常规rank有滚榜的动效），就模仿着做了一个动态rank。</p>
<p>在经历了半年多的月赛校赛洗礼后，OJ在2013年的省赛运行很顺利，刘汝佳老师出题的数据非常优雅，很小的数据量，仍然可以考察各种复杂的算法，在这一点上也是我后来几年出题的准则之一。</p>
<h3 id="二做一个自己的oj">二、做一个自己的OJ</h3>
<p>早些年POJ的名气让很多学校都希望有个自己的品牌OJ，中南在2010年基于HUSTOJ+Wordpress二次开发有了自己的带新闻页的校OJ，不过学长们毕业匆匆，OJ还放在一个犄角旮旯服务器的虚拟机上，加上那时候管理经验不足，大约2012年左右老OJ的代码都遗失了。接下来的若干年，先是用原生HUSTOJ，再然后是我给省赛二次开发的OJ，虽然校内训练够用，但总觉得当不了门面，打不了品牌。</p>
<p>2017年在经历了几个不大不小的项目后，自我感觉PHP已炉火纯青，带熬夜用一个星期戳了一个全新OJ，当时自己都觉得效率惊人。不过评测机这方面是无法一蹴而就的，加之需要兼容用了这么多年的学校OJ的旧数据，就沿用了开源HUSTOJ的评测机。</p>
<img src="/2023-10-16-CSGOJ-Why/csgoj_init_wechat.jpg" class="" title="刚做完OJ时发的朋友圈">
<p>还有当年刚做完OJ时发的博客：http://blog.csgrandeur.cn/2017-03-07-csunewoj/</p>
<p>虽然没有丰富的前端经验，只是用bootstrap搭界面，但还是在审美上下了许多功夫，在国内众多OJ中不能说多么好看，但绝对是一抹不一样的色彩。</p>
<p>在校赛和多次训练的验证之后，这一年省赛OJ的惊艳亮相非常成功，之后的湖南多校也以新OJ作为了主场。</p>
<p>那一年，真正的CSUOJ诞生——没错，是这个名字。</p>
<h3 id="三csgoj来了">三、CSGOJ来了</h3>
<p>阴差阳错毕业后没有留在母校，OJ服务校赛和省赛非常稳定，也就好几年都没有做什么更新，或许会成为一个被渐渐遗忘的系统。</p>
<p>可能是因为放不下当年一念之差没进World
Final的某些执念，成为了一名ACM教练，那么第一件事就是先搭个OJ。</p>
<p>这几年MVVM开发已经很普遍了，要不要重构一个呢。不过早已没有了年轻时候的冲动，越发觉得“够用就好”非常的有道理，放下一个颜值还没太落伍、结构成熟的OJ，再去开发一个新的，重复造轮子这事不是太吸引人。于是决定拿出之前的代码好好地升升级。</p>
<p>容器时代了，首先就全容器化吧，有系统洁癖的我太爱docker了。</p>
<p>在新学校还是不要让OJ的名字带有校名比较好，所以从源码类名上一起都改为了有个人色彩的名称。</p>
<p>评测端去掉了用了好多年的直接读写数据库的古早方式，而在数据请求远达不到性能瓶颈的情况下，也不要引入redis等额外的东西了，就保留了基于http请求处理评测机与Web端的通信，简洁明了。</p>
<p>对多年来一些耿耿于怀不太便捷的功能都做了优化，也与时代接轨更新了诸如多组样例分别独立显示等feature。</p>
<h3 id="四为什么继续做csgoj">四、为什么继续做CSGOJ</h3>
<p>18年Domjudge在World
Final横空出世以来，出现了大量拥趸，但是翻阅一个又一个踩坑博客，一篇又一篇部署记录的文章，冗长的文档，不禁皱了皱眉。</p>
<p>是不是可以有另一个OJ不需要面对丰富多样的个性化需求，以最简单的方式部署，满足国内通用的比赛场景？</p>
<p>校赛的时候尝试了一下滚榜，看着ICPC
tools琳琅满目的介绍，resolver那别别扭扭的对接方式，不禁又皱了皱眉。</p>
<p>很多功能为什么不可以集成在一起，而要分别去部署工具？</p>
<p>于是开始尝试把所有XCPC比赛需要的，且能够做进Web的功能都做到一起。截止2023.10.16，有以下这些集成：</p>
<ol type="1">
<li>12年开始就已经集成的代码打印：在Web比赛界面里由对应角色进行控制</li>
<li>12年就已集成的气球全局管理与标记</li>
<li>新增为每个气球配送员的手机准备的任务队列以及标记操作：从此告别手写便笺或打印小票</li>
<li>抽签与直接导入：动效抽签，结果直接导入到比赛里</li>
<li>滚榜（resolver）：就是看不惯官方的resolver，在比赛里直接滚它不好吗</li>
<li>主动式外榜：可以主动把内榜数据推送至外网，有历史记录信息而非静态html，外榜有滚榜动效，可以直接转为滚榜状态（虽然外榜的滚榜功能没啥用，主要给大家自己娱乐）</li>
</ol>
<p>愿景就是让和十几年前的小白的我一样的小白们能够在需要的时候轻松组织比赛，不用踩任何坑地、在一个OJ上便捷的完成比赛的整个流程。</p>
<h3 id="五闲聊最近2023.10">五、闲聊最近（2023.10）</h3>
<p>虽然CSGOJ在自己手上的大大小小比赛一直很顺利，上半年与SUA合作的GDCPC在赛前加强了一波补丁，优秀的题目加优秀的高性能工作站，让比赛非常顺利。</p>
<p>但想让部署用户也能不踩坑一定还有很长的路要走。</p>
<p>今年的CCPC秦皇岛受王老师邀尝试CSGOJ的整体方案，因为周五白天和周一早八都有课，两头夹的排课让行程很赶。</p>
<p>与OJ相关的部署、出题人测试、志愿者培训不遗余力，只希望CSGOJ的首次国赛表现能好一些，再好一些。</p>
<p>然而低配笔记本和见所未见的超大规模评测数据的双重压力下，出现了一个题目概率性OLE的问题。要说硬件性能问题是因，在此环境下其它OJ是否也会暴露问题未可知，但显然不可能甩锅说CSGOJ没有问题。</p>
<p>于是评测数据行末有空格的PE问题也一并被选手们迁怒于OJ。</p>
<p>自己也是选手过来的，很理解大学四年满打满算也没几场大赛，特殊情况遇到了怎么气都不为过，“傻逼OJ”已经算克制了吧。</p>
<p>幕后的气球与代码打印，台前的外榜与滚榜，也不再有人关心与OJ有什么关系，光芒是他人的。</p>
<p>Domjudge多次成功的比赛自带完美光环，或许CSGOJ在国赛级别的亮相还不是最佳的时候，而应该在开源后，在校赛，在省赛，慢慢地被熟悉与接受。</p>
<p>并没有多大的野心去推销它，只希望这个OJ能在合适的地方真的帮助到他人。</p>
<p>初心不改，做一个易用的一站式OJ。</p>
]]></content>
  </entry>
  <entry>
    <title>01.算法竞赛与编程</title>
    <url>/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="算法竞赛与编程">算法竞赛与编程</h1>
<p>本章介绍算法竞赛与编程的核心概念，阐述程序、编程语言及算法的基本定义，解析编辑器、编译器与集成开发环境（IDE）的作用机制，对比ACM与IOI两种主流赛制的评判规则，列举ICPC、CCPC等国内外权威赛事体系，并指导读者配置CodeBlocks开发环境，推荐掌握Git版本控制、Linux命令行操作及Markdown文档编写等实用技能，为算法竞赛实践奠定基础。</p>
<span id="more"></span>
<h2 id="算法竞赛">算法竞赛</h2>
<h3 id="什么是程序">什么是“程序”</h3>
<p>让电脑按部就班做一系列事情的一个打包好的东西，在windows系统里我们通常称为“文件”，大家最熟悉的就是“.exe”文件，QQ的启动程序是，游戏的启动程序也是，双击它，电脑就开始做它所定义的事情。</p>
<p>我们通常用的程序都是有“界面”的程序，打开它，总能看到点什么。不过程序并不是必须有界面的，比如在windows里打开“任务管理器”，能看到很多正在运行的不知道在做什么的程序，它们就没有看得见的界面，但都在有条不紊地执行着系统需要的任务。</p>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/taskmgr.png" class="" title="任务管理器">
<h3 id="什么是编程">什么是编程</h3>
<p>编程就是要制作可以执行的程序。</p>
<p>用一系列指令告诉计算机要做什么。这种指令从最早的机械开关，到纸带打孔，到“<code>010110</code>”的二进制输入，到指令分类并起名的汇编，再到C语言、C++、Java、Python编程语言的百花齐放。</p>
<p>加减乘除是人类易于理解的最基础的计算，计算机在指令中通过“<code>0</code>”与“<code>1</code>”的变化来模拟这些过程，进而可以做更复杂的事情：</p>
<ul>
<li>比如把颜色编码为数字，实现画面的显示，得到软件的界面</li>
<li>比如把文字编码为数字，实现消息的传输</li>
<li>比如用数字做矩阵运算，用矩阵运算得到三维形状的模拟，实现3D引擎，做出3D游戏</li>
<li>……</li>
</ul>
<h4 id="编辑器">编辑器</h4>
<p>当我们在文本编辑器中写下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);</span><br></pre></td></tr></table></figure>
<p>是想告诉电脑，我定义了两个变量“<code>a</code>”和“<code>b</code>”，并且让<code>a</code>的值是<code>1</code>，<code>b</code>的值是<code>2</code>，然后对屏幕输出<code>a+b</code>的结果。这样就写出了一个简单的
C 语言代码片段。</p>
<p>凡是能用键盘敲字进去的地方都可以称为“编<strong>辑</strong>器”。</p>
<h4 id="编译器">编译器</h4>
<p>但想让电脑真正执行这套指令，需要给的是电脑唯一能看懂的东西：“<code>01101001...</code>”这样的二进制内容，这时需要用到“编<strong>译</strong>器”。</p>
<p>编译器也是一种可执行程序，它不需要界面，充当“人看得懂的语言”到“电脑看得懂的指令”之间的翻译。通过“参数”的方式告诉它把什么翻译成什么，就可以完成这一过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main.exe</span><br></pre></td></tr></table></figure>
<p>这里<code>g++</code>就是一个编译器的可执行程序（如果系统里安装了mingw，你能看到一个<code>g++.exe</code>文件，就是在执行它），而<code>main.cpp</code>和<code>-o</code>、<code>main.exe</code>就是参数。</p>
<h4 id="集成开发环境">集成开发环境</h4>
<p>作为一个没学过编程的新手，看到上面的内容已经开始头大了，能不能不要管什么编辑器、编译器、执行、参数，我就想写代码，然后跑起来。</p>
<p>可以的，这就是集成开发环境（integrated development
environment，IDE），在一个有界面的软件里，集成了编辑器、编译器，且把编译、执行所需的一套指令打包在了快捷键里，就想打游戏时候所谓的“金手指”、“按键精灵”，让你“一键连招”。</p>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/text_and_coding.jpg" class="" title="编辑器与编译器">
<h3 id="什么是算法">什么是算法</h3>
<p>学了小学数学，你可以轻松计算加减乘除，解二元一次方程，基本的面积计算等等。而圆锥曲线方程、柯西不等式、微积分、立体几何……就需要更高阶的知识。</p>
<p>学会编程，当你想让电脑计算加减乘除、矩阵运算、显示界面、传递数据等事情的时候，按部就班地去做就可以了。而这时如果有图像标注（哈希、BFS）、事务审批（有穷自动机）、进销存管理（线性规划）等需求，就束手无策了。</p>
<p>聪明的你或许此时已经感受到了知识之间的联系，数学虽不外乎加减乘除乘方开方，但许多事情仍无法用初等数学直接解决。电脑的<code>01</code>逻辑不外乎“与/或/非/与非”，但若没有高阶的数据处理技巧，许多事情仍然会一筹莫展。</p>
<p>将“编程”中的基本操作以不同的方式结合，有效解决具体的问题的方案，就是“算法”。</p>
<h3 id="什么是算法竞赛">什么是算法竞赛</h3>
<p>将工业界、生活中的具体问题，抽象为能用数据表达的模型，设计算法，编写程序高效地解决它们的比赛。</p>
<p>具体地，会给出问题的描述，具体的输入数据的形式、取值范围，输出的要求。</p>
<p>将程序提交至系统，系统会编译运行这个程序，然后将一系列选手看不到的输入数据输入至程序。</p>
<p>获取程序的输出，与答案比对，判断程序是否完成任务。</p>
<p>此外会限制程序执行时长、所使用的内存大小。</p>
<p>主流算法竞赛主要有两类赛制</p>
<h4 id="acm赛制">ACM赛制</h4>
<p>一个题目所有数据的答案全部正确视为题目通过，通过时距离比赛开始的时间作为“罚时”，错一次则额外计
20分钟 的罚时，排名按通过题目个数为第一优先级，总罚时为第二优先级。</p>
<h4 id="ioi赛制">IOI赛制</h4>
<p>每道题有分数，与解题时间、通过数据组数有关，得到一个综合分数，最后比较总分。</p>
<h3 id="官方认定赛事类">官方认定赛事类</h3>
<h4 id="acm-icpc">ACM-ICPC</h4>
<p>国际大学生程序设计竞赛（International Collegiate Programming
Contest，ICPC）由 ICPC 基金会（ICPC
Foundation）主办，始于1970年，是全球历史最悠久、规模最大且最负盛名、最具影响力的大学生计算机竞赛。由于该竞赛由国际计算机学会（Association
for Computing Machinery，ACM）发起，也有很多人习惯叫它 ACM
竞赛。竞赛提倡创新和团队协作，鼓励学生在构建全新的软件程序时尽情发挥创意，帮助学生检验自在强压力下的工作能力。是世界各地计算机程序设计者大显身手的舞台，也是世界一流大学展现教育成果的最佳窗口。</p>
<p>由于比赛受限于场地及设备数量、服务器压力，ICPC在全球各大洲进行区域赛（Regional），各赛区每年也会设置多个赛站以实现人员分流。每年选拔约120支队伍参加世界总决赛（World
Final）。我国高校参加亚洲区域赛，每年国内仅有不超过20所高校能够获得世界总决赛资格，通常将亚洲区域赛（Asia
Regional）级别认定为国际级，而世界总决赛（World
Final）参赛资格这一至高殊荣额外单列。</p>
<p>中国大陆目前有6个亚洲区域赛赛区（赛站），每支队伍每赛季最多可以正式队伍身份参加
2
场区域赛，以队伍排名计金银铜奖，以每个学校正式队伍排名最高的队伍计算学校排名。每年晋级总决赛规则不尽相同，大致而言所有赛区综合排名在国内18名以内的高校有极大希望进入总决赛，即单个赛区的学校排名进入前四会有较大概率。</p>
<ul>
<li>官方全称：国际大学生程序设计竞赛</li>
<li>简称：ICPC（即 ACM-ICPC）</li>
<li>举办时间：每年下半年，各赛站分别进行</li>
<li>主办方：ICPC 基金会</li>
<li>创始机构：国际计算机学会（Association for Computing Machinery,
ACM）</li>
<li>目前国内ICPC信息总站：http://icpc.pku.edu.cn/index.htm</li>
<li>ICPC官方网站：https://icpc.global/</li>
</ul>
<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=808188965&amp;bvid=BV1y34y1B7PQ&amp;cid=484846892&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>【ICPC世界总决赛莫斯科站的回忆】
https://www.bilibili.com/video/BV1y34y1B7PQ/?share_source=copy_web&amp;vd_source=c617b7e2cc89265d6f82e07b3c66bc6c</p>
<h4 id="ccpc">CCPC</h4>
<p>中国大学生程序设计竞赛（China Collegiate Programming
Contest，CCPC）与ICPC赛制一致，每年也有多个赛站，各赛站优秀的队伍能够获得资格参加决赛，一般而言各赛站与决赛为同等级的国家级竞赛，是国内主办的最高级别算法竞赛。</p>
<ul>
<li>官方全称：中国大学生程序设计竞赛</li>
<li>简称：CCPC</li>
<li>举办时间：每年下半年，各赛站分别进行</li>
<li>主办方：中国大学生程序设计竞赛组委会</li>
<li>CCPC官方网站：https://ccpc.io/</li>
</ul>
<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=706271009&amp;bvid=BV18Q4y147tZ&amp;cid=1343604196&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>【CCPC2023深圳-混剪】
https://www.bilibili.com/video/BV18Q4y147tZ/?share_source=copy_web&amp;vd_source=c617b7e2cc89265d6f82e07b3c66bc6c</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=578432468&amp;bvid=BV1oz4y1w7tB&amp;cid=1332784644&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>【CCPC2023深圳-滚榜及颁奖】
https://www.bilibili.com/video/BV1oz4y1w7tB/?share_source=copy_web&amp;vd_source=c617b7e2cc89265d6f82e07b3c66bc6c</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=280917548&amp;bvid=BV1Xc411X7AH&amp;cid=1332043703&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>【CCPC2023深圳-正赛5小时全程直播回放】
https://www.bilibili.com/video/BV1Xc411X7AH/?share_source=copy_web&amp;vd_source=c617b7e2cc89265d6f82e07b3c66bc6c</p>
<h4 id="gdcpc">GDCPC</h4>
<p>广东省大学生程序设计竞赛（Guangdong Collegiate Programming
Contest，GDCPC）旨在将中国大学生程序设计竞赛（CCPC）引入广东省校园，提高广东省学生学习程序设计的兴趣和能力，推动广东省大学计算机课程的教学改革，为计算机程序设计方面有特长的同学提供展示才能的舞台。同时也可为各高校选拔、培训参加CCPC
的队员、为加强广东省内各高校之间的交流和相互学习提供了机会。从2019年开始，中国大学生程序设计竞赛
（CCPC）挂靠教育部计算机类教学指导委员会，经向 CCPC
组委会申请，广东省大学生程序设计竞赛隶属于CCPC，也称为 CCPC
广东省赛，其参赛报名将归入
CCPC。赛事由广东省计算机学会主办，广东省计算机学会普及工作委员会（广东省大学生程序设计竞赛的指导委员会）承办。</p>
<ul>
<li>官方全称：广东省大学生程序设计竞赛</li>
<li>简称：GDCPC</li>
<li>举办时间：每年5-6月</li>
<li>主办方：广东省计算机学会</li>
<li>GDCPC官方网站：http://www.gdcpc.cn/</li>
</ul>
<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=229753412&amp;bvid=BV14h411T7PW&amp;cid=1164443946&amp;p=1&amp;autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
<p>【气球飘扬的赛场——第二十届广东省大学生程序设计竞赛（GDCPC）暨中国大学生程序设计竞赛(CCPC)广东省赛】
https://www.bilibili.com/video/BV14h411T7PW/?share_source=copy_web&amp;vd_source=c617b7e2cc89265d6f82e07b3c66bc6c</p>
<h4 id="百度之星">百度之星</h4>
<p>百度之星是百度公司发起并主办的一项面向全球高校学生和编程爱好者的程序设计竞赛。自举办以来，它已成为计算机领域备受瞩目的赛事，吸引了众多编程高手参与，在推动计算机技术发展和人才培养方面发挥着重要作用。</p>
<p>大赛以提升全球程序员的算法设计与编程实践能力为目标，致力于挖掘和培养计算机领域的优秀人才。比赛内容紧密围绕算法设计、编程实现以及问题解决能力，通过一系列具有挑战性的编程题目，考察选手对数据结构、算法知识的掌握程度，以及灵活运用这些知识解决实际问题的能力。</p>
<p>大赛一般包含多个阶段，初赛通常采用线上编程的形式，选手需在规定时间内完成一系列算法题目，系统自动评判代码的正确性和运行效率，根据成绩排名筛选出晋级复赛的选手。复赛的难度进一步提升，对选手的编程技巧、思维敏捷度以及在复杂问题面前的应变能力提出更高要求。最终脱颖而出的选手将获得参加现场总决赛的资格，在总决赛中，选手们现场同场竞技，气氛紧张而激烈，最终角逐出大赛的各个奖项。</p>
<ul>
<li>官方全称：百度之星·程序设计大赛</li>
<li>简称：百度之星</li>
<li>举办时间：每年举办，具体时间根据当年赛事安排而定</li>
<li>主办方：百度公司</li>
<li>建议认定：在计算机编程竞赛领域，具有较高认可度，影响力覆盖全球高校及编程爱好者群体</li>
<li>官方网站：https://star.baidu.com/ （具体以实际官网为准）</li>
</ul>
<h4 id="ccf-ccsp">CCF-CCSP</h4>
<p>CCF大学生计算机系统与程序设计竞赛（CCF Collegiate Computer Systems
&amp; Programming Contest,
CCSP），由中国计算机学会(CCF)于2016年发起的一个面向大学生的竞赛，每年举办一次，考察的是算法、编程以及计算机系统设计能力，赛制接近OI，旨在进一步提高计算机教育质量，使学生通过竞赛进一步学习和掌握计算机系统知识，同时对高校计算机教育产生引领作用。</p>
<p>CCSP需要以有近四次的一次CCF-CSP认证的较好成绩为前提才能参加。比赛分为全国赛与全国分赛，同时进行，全国赛在承办高校进行，分赛在全国各高校组织，比全国赛减少部分困难题目。</p>
<ul>
<li>官方全称：CCF大学生计算机系统与程序设计竞赛</li>
<li>简称：CCSP</li>
<li>举办时间：每年10-11月</li>
<li>主办方：中国计算机学会（China Computer Federation, CCF）</li>
<li>CCSP官方网站：https://www.ccf.org.cn/ccsp/</li>
</ul>
<h4 id="robocom-caip">RoboCom-CAIP</h4>
<p>RoboCom机器人开发者大赛-CAIP编程设计赛道由工业和信息化部人才交流中心、RoboCom国际公开赛组委会举办，旨在提升大学生利用计算机分析问题、解决问题的重要基础能力。竞赛时长为
2 小时。竞赛中分为 2
个不同组别（高职组、本科组）使用不同题目，在同一时间按照统一评分规则进行比赛，研究生学历的参赛选手可选择本科组进行参赛。省级选拔赛评分：同一省内的参赛选手首先根据总得分进行排名。在确定其获得奖项时，如果总得分相同，则根据最高得分所提交的时间进行排名，时间短者排名居前；若扔有并列，则获得并列名次。决赛评分：参赛选手首先根据总得分进行排名。在决定获得奖项时，如果总得分相同，则根据最高得分所提交的时间进行排名，时间短者排名居前；若扔有并列，则获得并列名次。</p>
<ul>
<li>官方全称：RoboCom机器人开发者大赛 - CAIP编程设计赛道</li>
<li>简称：CAIP</li>
<li>举办时间：每年7-8月</li>
<li>主办方：工业和信息化部人才交流中心</li>
<li>RoboCom官方网站：https://www.robocom.com.cn/</li>
</ul>
<h4 id="gplt">GPLT</h4>
<p>团体程序设计天梯赛（Group Programming Ladder Tournament,
GPLT）是中国高校计算机大赛（China Collegiate Computing Contest,
CCCC）的竞赛版块之一，旨在提升学生计算机问题求解水平，增强学生程序设计能力，培养团队合作精神，提高大学生的综合素质，同时丰富校园学术气氛，促进校际交流，提高全国高校的程序设计教学水平。比赛重点考查参赛队伍的基础程序设计能力、数据结构与算法应用能力，并通过团体成绩体现高校在程序设计教学方面的整体水平。竞赛题目均为在线编程题，由搭建在网易服务器上的PAT在线裁判系统自动评判。难度分3个梯级：基础级、进阶级、登顶级。以个人独立竞技、团体计分的方式进行排名。</p>
<ul>
<li>官方全称：中国高校计算机大赛 - 团体程序天梯赛</li>
<li>简称：GPLT</li>
<li>举办时间：每年4-5月</li>
<li>主办方：全国高等学校计算机教育研究会</li>
<li>赛事官网：https://gplt.patest.cn/</li>
</ul>
<h4 id="蓝桥杯大赛">蓝桥杯大赛</h4>
<p>蓝桥杯全国软件和信息技术专业人才大赛（简称“蓝桥杯”）由中华人民共和国工业和信息化部人才交流中心主办，
旨在推动软件和信息技术产业的发展，促进软件和信息技术专业技术人才培养，向软件和信息技术行业输送具有创新能力和实践能力的高端人才，提升高校毕业生的就业竞争力，全面推动行业发展及人才培养进程的全国性竞赛。赛制接近OI，比赛分为省赛和国赛部分，省赛一等奖选手可以晋级国赛。</p>
<ul>
<li>官方全称：蓝桥杯全国软件和信息技术专业人才大赛</li>
<li>简称：蓝桥杯大赛</li>
<li>举办时间：每年4-6月，4月省赛，6月国赛。</li>
<li>主办方：中华人民共和国工业和信息化部人才交流中心</li>
<li>蓝桥杯官方网站：https://dasai.lanqiao.cn/</li>
</ul>
<h3 id="民间赛事类">“民间”赛事类</h3>
<h4 id="codeforces">CodeForces</h4>
<p>CodeForces很大的特点就是题目兼容并蓄，什么难度等级的题目都可以找到。并且题目很有意思，思维题比较多。</p>
<p>CodeForces另外一个很大的特点就是它有自己的上分系统，基本上每周会举办一到两次在线的算法比赛。一般的比赛时长是两个小时，只要注册账号就可以免费参加。由于参加的选手水平实力强度不一，所以它开设了好几个档次(Div)，不同层次的选手面对的题目难度也不一样，这样保证了大家都可以愉快地参赛。大约一周一次，时长2小时。</p>
<ul>
<li>官方全称：CodeForces</li>
<li>简称：CodeForces</li>
<li>举办时间：大约一周举办一到两次，每次时长2小时</li>
<li>主办方：无明确提及</li>
<li>官方网站：https://codeforces.com/</li>
</ul>
<h4 id="atcoder">Atcoder</h4>
<p>AtCoder是日本最大的算法竞技网站，也是全球第二流行的算法竞技网站。与Codeforces不同的是，AtCoder代码提交后没有预测试，参赛者提交程序后即可知道自己的程序是否正确。AtCoder的比赛有四大类：
1. AtCoder Beginner
Contest（ABC），主要面向算法初学者。每周六或周日20点举行，时长100分钟。通常是8道题，AtCoder积分在0~1999区间的选手参与这种比赛，积分会根据做题结果而涨或跌。
2. AtCoder Regular Contest
（ARC），主要面向有一定算法基础的选手。举办频率低于AtCoder Beginner
Conste，对标Codeforces Div2。 3. AtCoder Grand
Contest（AGC），主要面向较高水平的选手，每两个月左右举办一次。 4.
除ABC、ARC、AGC以外的非常规比赛，比如日本企业赞助的比赛，面向招聘的比赛，算法马拉松比赛。</p>
<ul>
<li>官方全称：AtCoder</li>
<li>简称：AtCoder</li>
<li>举办时间：ABC每周六或周日20点举行，时长100分钟；ARC举办频率低于ABC；AGC每两个月左右举办一次；非常规比赛依具体安排</li>
<li>主办方：无明确提及</li>
<li>官方网站：https://atcoder.jp/</li>
</ul>
<h2 id="开启编程之旅">开启编程之旅</h2>
<h3 id="下载安装一个ide">下载安装一个IDE</h3>
<p>不少大学基础课会使用 Visual
Studio，可能是因为有中文界面、简单易上手、大多机房都会安装的缘故。但入门编程，特别是对算法竞赛感兴趣的新手，非常不推荐使用
Visual Studio，其 MSVC 编译器对部分 C/C++ 标准支持与评测机常用的 GCC
存在差异，与评测机的不一致会导致一个新手常见问题：“本地跑的好好的，为什么提交就是不对呢”。</p>
<p>日常编程而言，更推荐 Visual Studio Code 或 Jetbrains 的
Clion。不过为了轻量、简单、易上手，这里以 Codeblocks
为例开始编程之旅。</p>
<p>在这里下载：https://www.codeblocks.org/downloads/binaries/</p>
<p>注意选择“mingw-nosetup.zip”这个版本</p>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/codeblocks_download.jpg" class="">
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/codeblocks_download2.jpg" class="">
<p>如果官网下载不太顺利，可以从这个网盘链接下载：</p>
<p>https://share.weiyun.com/QMLclZWZ</p>
<p>解压到任意目录即可，最好<strong>路径上不要有中文</strong>，比如“<code>E:/IDE/CodeBlocks</code>”
就可以。</p>
<p>双击打开它</p>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/codeblocks_open.jpg" class="">
<p>第一次打开会有一些弹窗，默认下一步就好</p>
<p>点击“File”，选择“New-&gt;Project”</p>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/codeblocks_newpro_1.jpg" class="">
<p>新建“Console Application”</p>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/codeblocks_newpro_2.jpg" class="">
<p>各选项都按默认下一步，然后选择一个只有字母数字下划线的路径（中文系统里有各种中文文件夹，避免路径带中文或空格，
这个软件不兼容这样的路径），起一个纯字母的名称</p>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/codeblocks_newpro_3.jpg" class="">
<p>在左侧打开“main.cpp”，就可以看到一个“Hello World”程序了</p>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/codeblocks_newpro_4.jpg" class="">
<p>按下键盘的“F9”试一下，应该<strong>编译</strong>并<strong>运行</strong>出一个黑框框（命令行）</p>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/codeblocks_newpro_5.jpg" class="">
<h2 id="应当熟悉的其他工具">应当熟悉的其他工具</h2>
<h3
id="git与版本控制养成整理备份的好习惯">git与版本控制：养成整理备份的好习惯</h3>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/git.png" class="">
<p>git（分布式版本控制系统）并不等同于github。</p>
<p>git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。</p>
<p>github提供git服务，其他网站当然也可以，自己也可以搭建git服务器。</p>
<p>今天改了代码，明天又改了，后天甲方爸爸说还是喜欢第一个版本……</p>
<p>用git可以方便的查看/回滚任意commit过的版本，并查看文本类文件的差异。</p>
<p>当然也可以当个文档云服务，方便地在不同地点同步自己的代码与文档。严格的版本控制能够保证文件不出差错。</p>
<p>推荐使用git管理自己的ACM代码、解题报告、模板、技术日志等。</p>
<p>详细介绍见： <a
href="/2021-03-31-git-newbie/">用git管理自己的代码与文档</a></p>
<h3
id="linux环境与命令行克服windows之外世界的恐惧">Linux环境与命令行：克服Windows之外世界的恐惧</h3>
<img src="/2025-03-05-01-%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%8E%E7%BC%96%E7%A8%8B/linux.jpg" class="">
<p><a
href="/2021-03-31-vscode-wsl-acm/">基于vscode与wsl配置c++环境（ACM向）</a></p>
<p><a
href="https://learn.microsoft.com/en-au/windows/wsl/install-manual">WSL官方文档</a></p>
<h3
id="markdown与latex快捷省力出文档">Markdown与Latex：快捷省力出文档</h3>
<p><a href="https://www.zhihu.com/question/20409634">怎样引导新手使用
Markdown？</a></p>
<p><a
href="https://www.zhihu.com/question/29227449">国外教授的讲义都是自己用
LaTeX 打出来的吗？</a></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>02.程序设计入门</title>
    <url>/2025-03-05-02-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="程序设计入门">程序设计入门</h1>
<p>本章介绍程序设计的基础知识，重点讲解C语言的核心要素。内容涵盖头文件的作用、变量类型定义、主函数结构及程序语句规范，详细解析输入输出函数<code>scanf</code>与<code>printf</code>的格式化用法。通过顺序结构示例（如数值运算、图形输出）和分支结构（条件判断、运算符选择）演示基本逻辑设计，并结合评测系统机制强调代码格式与数据精度的重要性。本章通过典型例题帮助读者掌握程序设计的基本流程、语法规则及调试技巧，为后续算法学习奠定基础。</p>
<span id="more"></span>
<h2 id="c语言基本要素">C语言基本要素</h2>
<p>C++ 兼容 C
语言的语法，所以我们不必拘泥于“.c”还是“.cpp”这样的扩展名，新手不用管那么多，无论是写C++风格还是C语言风格，一律在C++的编译环境（.cpp文件）中写就好。</p>
<h3 id="头文件">头文件</h3>
<p>为了避免从电脑直接看得懂的“01011...”写起，或者从“MOV”、“ADD”这类非常底层的“汇编语言”写起，我们学习一个相对“高级”的语言，即C语言。那些高频使用的“向屏幕输出一些字符”等操作，C语言已经帮我们做好了，我们只需要“告诉”C语言，让C语言去要求电脑做这些事。</p>
<p>“告诉”这个动作需要特定的指令来做，而C语言怎么知道这个指令是做什么的呢？它把不同类型的功能封装在了不同的文件里，所以我们要先让编译器知道，我们要用哪些文件里的功能，就要把这些文件“包含”进来，这就是“include”指令，包含进来的文件叫“头文件”。</p>
<p>现在要包含一个处理“输入输出”这类操作的功能包，这个头文件是“stdio.h”，“std”是标准（standard）的缩写，“io”是“input/output”的缩写。</p>
<p>这样接下来的程序，就可以用“stdio.h”里包含的功能。</p>
<p>包含头文件的语法是：</p>
<ul>
<li>一个<code>#</code>符号，表示现在要做一些“特殊”的事情，“#”后面不同的内容对应不同的事情</li>
<li><code>#</code>后紧跟“include”，表示我们现在要做的是“包含头文件”这样的事情，至于能做其它什么事情，以后再了解</li>
<li>头文件用一对<code>&lt;&gt;</code>包裹</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br></pre></td></tr></table></figure>
<h3 id="变量">变量</h3>
<p>要计算总要有计算的对象，基础的计算对象就是“变量”，可以类比学过的代数，<span
class="math inline">\(x,y,z...\)</span>
这样的代数，然后把数字代进去就能计算不同的数据。</p>
<p>代数有整数有小数，在电脑中还有字符，要让电脑看得懂，能合理的用“0101...”这样的二进制存储，需要告诉它这些代数是什么类型，这就是变量类型。</p>
<p>先了解最常用的：</p>
<ul>
<li>int：整数（1，2，-6... 这样的数）</li>
<li>double： 浮点数（0.4、2.5、5.0...这样有小数部分的精度的数）</li>
</ul>
<p>变量还有一些其它的类型，以后用到再了解。</p>
<h3 id="主函数">主函数</h3>
<p>C语言的功能是由“函数”组成的，初高中学过“函数”的概念，是把一些代数丢进去，完成固定的一套计算。比如
<span class="math inline">\(f(y)=x*2+1\)</span>
，C语言的函数可以延申这个概念，把一些变量（变量可以是 <span
class="math inline">\(x,y,z\)</span>
这样的代数，也可以是更复杂的结构）丢进去，完成固定的程序逻辑。</p>
<p>一个程序运行，总得有一个开端，即从哪里开始，这就是“主函数”的作用，告诉系统从这里开始。</p>
<p>函数可以有返回值（算完之后告诉调用它的地方它算出了个什么类型的东西），也可以没有返回值，但主函数必须有返回值，这是C语言的规则，它用来告诉操作系统这个程序执行的是否成功。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主函数的代码 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数的语法是：</p>
<ul>
<li><code>int</code>：主函数返回值必须是
<code>int</code>，不能是别的</li>
<li><code>main</code>：表示函数的名字，<code>main</code>这个名字是专门用于主函数的，不能用其它名字，大小写也不能改</li>
<li><code>()</code>：一个小括号里写函数的参数，主函数有特定的参数，不过可以省略，初学时可以先不管它的参数</li>
<li><code>&#123;&#125;</code>：包裹定义主函数要做的事的代码</li>
<li><code>return 0;</code>：主函数包裹的代码的末尾必须是<code>return 0;</code>，表示当执行到这里的时候，向调用主函数的“东西”（比如操作系统的某个进程）告知本程序正常结束。</li>
</ul>
<p>这里“<code>//</code>”是注释语法，用于写一些帮助自己回忆代码是干什么的注释，对电脑来说这些内容不存在，纯粹是给人看的。</p>
<h3 id="程序语句">程序语句</h3>
<p>C语言中常规程序的语句末尾都要有分号“<code>;</code>”，表示一个语句的结束（以下语句的含义后文会说明）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> c = a + b;</span><br></pre></td></tr></table></figure>
<h3 id="定义变量">定义变量</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br></pre></td></tr></table></figure>
<p>这里定义两个变量 <code>a</code> 和 <code>b</code>，他们是
<code>int</code> 类型。</p>
<h3 id="赋值">赋值</h3>
<p>数学中“<code>=</code>”表示两个变量/数字相等，而程序中，“<code>=</code>”表示将右边的值存入左边的变量，变量是一个可以改变的代数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b;</span><br><span class="line">b = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3 id="输入">输入</h3>
<p>让用户在弹出的黑框框中输入想要的数字，再用输入的数字计算，就有了用户交互，这样程序就可以做很多事了。</p>
<p>我们前面已经<code>#include&lt;stdio.h&gt;</code>，所以可以用输入输出相关的功能了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure>
<p><code>scanf</code>
也是函数，<code>"%d%d", &amp;a, &amp;b</code>就是传给它的参数。</p>
<ul>
<li><code>"%d%d"</code>
表示要输入两个整数，这里<code>%</code>用于标识输入，<code>%</code>之后跟的内容具体定义了要输入什么，好让电脑在内存中做好准备，<code>%d</code>就是要输入一个整数（<code>int</code>），如果是<code>%lf</code>就是要输入一个<code>double</code>。</li>
<li><code>&amp;a</code>对应前一个<code>%d</code>，用户在黑框框输入的第一个数就会存入<code>a</code>这个变量，同理<code>&amp;b</code>对应第二个<code>%d</code>，<code>&amp;</code>是“取地址”符号，<code>&amp;a</code>表示指向<code>a</code>的内存地址，这里先不用了解那么多，知道这个格式能输入数据即可。</li>
</ul>
<blockquote>
<p>知识点：<code>int</code>的输入输出都用<code>%d</code>，<code>double</code>的输入用<code>%lf</code>，输出用<code>%f</code>。这时你可能有个疑问，没错确实有个输入是<code>%f</code>的变量类型<code>float</code>，但编程之初我们不想讨论过多内容，减轻初学者压力，这里简单说就是<code>float</code>能表达的精度不够，而现代计算机性能很好，在算法竞赛中我们都用<code>double</code>就好了。</p>
</blockquote>
<h3 id="计算">计算</h3>
<p>计算<code>a+b</code>的和，很直观在代码中写<code>a+b</code>即可，它得到的结果可以存入一个变量，也可以直接当参数传给函数。</p>
<p>比如 <code>int c = a + b;</code> 就把 <code>a+b</code> 的结果存入
<code>c</code>。</p>
<h3 id="输出">输出</h3>
<p><code>printf("%d\n", a + b);</code> 就把<code>a+b</code>
的结果作为参数传给 <code>printf</code>这个函数，这里的<code>%d</code>
和<code>scanf</code>的<code>%d</code>含义一样，<code>printf</code>用于输出，所以就是把<code>a+b</code>的结果作为整数的格式输出。
<code>\n</code>
表示输出后换一行（在文本编辑器里换一行就是敲一下回车）。</p>
<p><code>double</code>的输出用<code>%f</code>，注意这里没有“<code>l</code>”。</p>
<blockquote>
<p>知识点：输出也会有一些特异的需求，比如输出小数保留多少位，输出整数能不能右对齐前面补空格让总长度固定等，就会有
<code>%.3f</code>、<code>%02d</code>
等用法，当遇到时，可查资料寻找可用的格式化方法。</p>
</blockquote>
<h3 id="一个基本的ab">一个基本的<code>a+b</code></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2025-03-05-02-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/codeblocks_a_plus_b.jpg" class="">
<h3 id="例输出浮点数">例：输出浮点数</h3>
<p>读入一个双精度浮点数（<code>double</code>），分别按输出格式
<code>%f</code> ，<code>%f</code> 保留 5 位小数，<code>%e</code> 和
<code>%g</code> 的形式输出这个数，每次在单独一行上输出。</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12.3456789</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12.345679</span><br><span class="line">12.34568</span><br><span class="line">1.234568e+01</span><br><span class="line">12.3457</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n%.5f\n%e\n%g\n&quot;</span>, x, x, x, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="评测系统的机制">评测系统的机制</h2>
<p>把代码通过网页（或软件）提交到评测系统，评测系统会在后台编译并执行你的代码，将一系列你看不到的输入数据发送给你的程序，将输出的内容和答案对比，然后告诉你你的代码是否正确。</p>
<p>新手经常会问“我样例都通过了为什么提交了还不对呢”，这里再次强调一下：评测系统会测许多并不会让你看到的其它数据。</p>
<p>在电脑中，空格“<code></code>”，回车等内容也都是由“字符”来表达的，它们都有编码，传统评测系统对答案的格式有严格的要求，<strong>你的程序的输出结果要与评测机上的答案完全一致才能通过</strong>。</p>
<p>比如假设评测机上的答案是</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>如果你的程序输出的是 <code>123</code> 或
<code>1 2 3</code>，就都无法通过。</p>
<p>找一个OJ的<code>a+b</code>的题，提交你的代码试试把</p>
<img src="/2025-03-05-02-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8/oj_a_plus_b.jpg" class="">
<h2 id="顺序结构">顺序结构</h2>
<p>顺序结构是程序设计中最基本、最简单的控制结构之一。它指的是程序按照代码书写的先后顺序依次执行，从上到下逐条执行语句，没有跳跃、分支或循环。在顺序结构中，每一条语句都会被执行一次，并且严格按照它们在源代码中的排列顺序执行。</p>
<p>上文的例子都是顺序结构，先定义变量，然后输入，然后输出，然后<code>return</code>……</p>
<h3 id="例用输出菱形">例：用“<code>*</code>”输出菱形</h3>
<p>用 <code>*</code> 构造一个对角线长 5 个字符，倾斜放置的菱形。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br></pre></td></tr></table></figure>
<p>因为图形很简单，不需要做特别的逻辑处理，简单粗暴用<code>printf</code>输出它就好。</p>
<p>图形分为 5
行，且要考虑每个空格也是答案的一部分，输出这样的内容肯定是错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">***</span><br><span class="line">*</span><br></pre></td></tr></table></figure>
<p>每一行要把“<code></code>”和“<code>*</code>”都打出来，且要把换行的符号（“<code>\n</code>”）也打出来，答案如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  *\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*****\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ***\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  *\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例-计算-abc-的值">例 计算 <span
class="math inline">\((a+b)/c\)</span> 的值</h3>
<p>给定 3 个整数 <span class="math inline">\(a, b, c\)</span>， 计算
<span class="math inline">\((a+b)/c\)</span> ，其中 <span
class="math inline">\(/\)</span> 是整除运算。</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 3</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<p>“整除运算”的意思是只取计算结果的整数部分，小数部分省略。</p>
<blockquote>
<p>知识点：大多编程语言默认相同类型的变量在计算过程中类型不变，<code>int</code>只能存整数，它无法表达
<code>1/2=0.5</code>这样的概念，故<code>int</code>与<code>int</code>之间的计算，编译器默认结果自动取整，也就刚好符合“整除运算”的要求，即<code>1整除2=0</code>，保留<code>0.5</code>的整数部分<code>0</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (a + b) / c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知识点：在读入多个数字的时候，<code>scanf</code>的格式化输入<code>%d</code>会自动跳过不是数字的符号，从而方便我们不用关心输入的数字之间有多少空格、多少换行，即无论输入的是
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 3</span><br></pre></td></tr></table></figure> 还是 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1     1</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<code>scanf("%d%d%d", &amp;a, &amp;b, &amp;c);</code>
都能正确地完成输入</p>
</blockquote>
<h3 id="例-浮点数向零舍入">例 浮点数向零舍入</h3>
<p>输入一个双精度浮点数，将其向零舍入到整数。说明：向零舍入的含义是，正数向下舍入，负数向上舍入。</p>
<p>输入数据范围是 <span class="math inline">\(-10^{15}\leq x \leq
10^{15}\)</span>。</p>
<p>这是一个 <code>double</code>
向整数转换的任务，在编程语言中向<code>0</code>舍入是默认机制，不需要我们写特别的代码逻辑。</p>
<p>关于强制转换，可以直接将<code>double</code>赋值给整数变量，也可以给值前面加<code>(变量类型)</code>来得到转换后的值。</p>
<blockquote>
<p>知识点：题目告知输入范围，并不是让你来判断题目输入的对不对，而是给你一个信息，让你知道在处理一个什么规模的问题，从而调整自己的实现思路。</p>
</blockquote>
<blockquote>
<p>知识点：<code>int</code>可以表达的范围是
<code>-2147483648~2147483647</code>，也就是<code>32</code>个二进制位能表达的范围，更大的整数类型是
<code>long long</code>，它有<code>64</code>个二进制位，能表达
<code>-9,223,372,036,854,775,808~9,223,372,036,854,775,807</code>，大约
<span
class="math inline">\(10^{19}\)</span>，它对应的输入输出占位符是<code>%lld</code></p>
</blockquote>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2.3</span><br><span class="line">-2.3</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分支结构">分支结构</h2>
<p>分支结构（也称为选择结构）是程序设计中用于实现条件判断和不同路径执行的重要控制结构。通过分支结构，程序可以根据特定条件选择执行不同的代码块，从而实现更复杂的功能和逻辑处理。</p>
<h3 id="if语句">if语句</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件) &#123;</span><br><span class="line">    <span class="comment">// 满足条件则执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 满足条件1则执行这里</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 满足条件2则执行这里</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 剩下的情况执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例-整数大小比较">例 整数大小比较</h3>
<p>输入两个整数，比较它们的大小。若 <span
class="math inline">\(x&gt;y\)</span> ，输出 <code>&gt;</code> ；若
<span class="math inline">\(x=y\)</span> ，输出 <code>=</code> ；若
<span class="math inline">\(x&lt;y\)</span>，输出 <code>&lt;</code>
。</p>
<p>数据范围 <span class="math inline">\(0\leq x \leq 2^{32}, -2^{31}
\leq y \leq 2^{31}\)</span></p>
<p>输入：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1000 100</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>这题范围很大，用<code>long long</code></li>
<li>因为<code>=</code>是赋值用的，判断相等得用<code>==</code></li>
<li>输出的好习惯：单行输出都带上<code>\n</code>在结尾换行</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span>(x &gt; y) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x == y) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三元运算符">三元运算符</h3>
<p>在“非此即彼”且逻辑简单的时候，用三元运算可简化代码，写起来很“帅”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件 ? 符合条件执行这里 : 不符合条件执行这里</span><br></pre></td></tr></table></figure>
<p>上题用三元运算符也可以完成，不过它不是“非此即彼”的，有三种情况，可以三元运算套三元运算，这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(x &gt; y ? <span class="string">&quot;&gt;\n&quot;</span> : (x == y ? <span class="string">&quot;=\n&quot;</span> : <span class="string">&quot;&lt;&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch">switch</h3>
<p>一个变量或表达式有多种可能的目标值，可以用switch：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>: 变量是值<span class="number">1</span>时的逻辑; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>: 变量是值<span class="number">2</span>时的逻辑; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">3</span>: 变量是值<span class="number">3</span>时的逻辑; <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>: 除了以上情况外时的逻辑;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：除最后的default外，每个 <code>case</code> 最后必须有
<code>break</code> ，否则它之后的 <code>case</code> 也会被执行</p>
<h3 id="例-简单计算器">例 简单计算器</h3>
<p>给两个数字、一个符号，如果符号不是加减乘除则输出<code>Invalid operator!</code>，如果除0则输出<code>Divided by zero!</code></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 +</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d %c&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a - b); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a * b); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: </span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Divided by zero!\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a / b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;Invalid operator!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知识点： - 字符需要用<code>char</code>这个变量类型， -
读入<code>%d</code>能自动跳过空白，但<code>%c</code>不行，它会读空白字符，题目输入由空格隔开，所以要加一个空格占位后再写<code>%c</code>
- 字符常量用单引号<code>'</code>，后面课程的字符串章节会更详细的讲解</p>
</blockquote>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>03.数组与循环结构</title>
    <url>/2025-03-06-03-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数组与循环结构">数组与循环结构</h1>
<p>本章介绍数组与循环结构。内存存储运行数据，数组管理同类型数据集合，占用连续内存空间。定义数组通过指定类型和大小，支持多维数组。循环包括<code>for</code>、<code>while</code>、<code>do...while</code>，用于重复执行代码块，支持嵌套及控制语句<code>break</code>和<code>continue</code>。实例展示如何应用这些概念解决编程问题，如分糖果游戏和质数口袋问题，强调基础知识的重要性。核心技能涵盖变量作用域、内存管理和逻辑控制。</p>
<span id="more"></span>
<h2 id="内存">内存</h2>
<p>内存就像计算机的"临时便签纸"，程序运行时把当前要用的数据和指令快速写在这张纸上（高速存取），关机时便签内容会被全部撕掉（断电清空），而硬盘才是长期存档的"笔记本"。</p>
<p>开一个变量<code>int a;</code>，会占据<code>32</code>个<code>bit</code>（<code>bit</code>是0101....这样的一个二进制位的单元）的内存，内存通常是以8个bit位单位处理的，所以8个比特称为“字节”，<code>int</code>就占据<code>4</code>个字节。</p>
<h2 id="数组">数组</h2>
<p>管理一连串<strong>相同类型</strong>的数据的结构，占据内存连续的一段地址。</p>
<ul>
<li>定义数组：<code>类型 数组名[数组大小]</code></li>
<li>赋值：<code>数组名[在内存中偏移开始地址的偏移量] = 要赋的值</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">11</span>];</span><br><span class="line"><span class="type">double</span> b[<span class="number">11</span>];</span><br><span class="line">a[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>
<p><code>a[10]</code>在内存里开辟了连续的 <code>10</code>
个int大小的存储空间，取值和赋值能用的偏移量是<code>0~9</code>，</p>
<img src="/2025-03-06-03-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/array.jpg" class="" title="数组">
<p>数组可以多个维度，从而表示“几行几列”这样的概念，甚至更高维度，“几页几行几列”/“几层几行几列”等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="type">char</span> c[<span class="number">11</span>][<span class="number">11</span>];</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>c[0]</code>
表示偏移为<code>0</code>（也就是第<code>1</code>个）的一个长度为<code>11</code>的数组，把长度为<code>11</code>的数组当作单位数组的话，<code>c[1]</code>对准了偏移了1个数组的内存地址，或者说偏移了<code>11</code>个<code>char</code>的地址，<code>c[2]</code>就是偏移了2个数组，或者说偏移了<code>22</code>个<code>char</code>的地址……</p>
<h2 id="循环">循环</h2>
<p>循环就像工厂的流水线传送带，让相同的处理流程反复执行。当需要处理大量同类数据（比如数组元素）时，循环能避免写重复代码，通过"模式复用"实现高效操作。</p>
<h3 id="for循环">for循环</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 继续进行的条件; 更新操作) &#123;</span><br><span class="line">    循环的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行顺序是：
初始化-&gt;循环的内容-&gt;更新操作-&gt;继续进行的条件（true）-&gt;循环的内容-&gt;更新操作-&gt;继续进行的条件（true）-&gt;循环的内容……</p>
<p>直到某一步“继续进行的条件”是false，则循环结束。</p>
<p>例如为数组<code>int a[10]</code>的<code>0~9</code>位置顺次输入数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while循环">while循环</h3>
<p>先判断是否继续，再执行，如果一开始继续进行的条件就是<code>false</code>，则循环的内容完全不会被执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(继续进行的条件) &#123;</span><br><span class="line">    循环的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do...while循环">do...while循环</h3>
<p>先执行，再判断是否继续，与 while
循环的主要区别是循环的内容至少一开始就会执行一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环的内容</span><br><span class="line">&#125; <span class="keyword">while</span>(继续进行的条件);</span><br></pre></td></tr></table></figure>
<h3 id="循环可以嵌套">循环可以嵌套</h3>
<p>“循环的内容”可以是任何常规代码，循环套循环可以处理二维数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, c[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环的提前结束">循环的提前结束</h3>
<p>有时候需要在达到特定目的时让循环“戛然而止”，而不是等到下一次“继续进行的条件”，用<code>break</code>，执行
<code>break</code> 时，循环整个结束，会继续循环之后的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i ++) &#123;</span><br><span class="line">    x += <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x *= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环的跳过">循环的跳过</h3>
<p>有时候在循环的重复操作中，想跳过部分特殊情况，用<code>continue</code>，遇到<code>continue</code>时，<code>for</code>循环直接跳到下一次“更新操作”，<code>while</code>循环直接跳到下一次“继续进行的条件”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;    <span class="comment">// % 是取模，对 2 取模余数为 0，即 i 是偶数的时候</span></span><br><span class="line">        <span class="keyword">continue</span>;   <span class="comment">// 遇到continue，跳到循环体中的“i++”位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="number">2</span>;         <span class="comment">// 如果刚刚执行了continue，则这里 x += 2 被跳过不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题">例题</h2>
<h3 id="例分糖果">例：分糖果</h3>
<p>有 5 位小朋友编号依次为 1,2,3,4,5
他们按照自己的编号顺序围坐在一张圆桌旁。他们身上有若干糖果，现在他们玩一个分糖果游戏。从
1 号小朋友开始，将自己的糖果均分成 3
份（如果有多余的糖果，就自己立即吃掉），自己留一份，其余两份分给和他相邻的两个小朋友。接着
2,3,4,5
号小朋友也这样做。问一轮结束后，每个小朋友手上分别有多少糖果。</p>
<p>输入：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">8 9 10 11 12</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 7 9 11 6</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>建议的竞赛习惯：</p>
<ol type="1">
<li>数组开在 main
函数外面作为全局变量，因为函数内能用的内存（称为栈内存）比较少</li>
<li>数组大小比需要的开多一些，减少失误读写到数组外面的情况</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">11</span>];   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        <span class="comment">// 用数组的 0~4 下标代替题目的 1~5 编号</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> eatnum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        <span class="comment">// 会发现这样 0 号能找到正确的左边的 4，4 号也能找到正确的右边的 0</span></span><br><span class="line">        <span class="type">int</span> left = (i - <span class="number">1</span> + <span class="number">5</span>) % <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> right = (i + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        eatnum += a[i] % <span class="number">3</span>;</span><br><span class="line">        a[i] /= <span class="number">3</span>;</span><br><span class="line">        a[left] += a[i];</span><br><span class="line">        a[right] += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, eatnum);   <span class="comment">// 上一行没打 \n，这里补上前一个\n</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例质数口袋">例：质数口袋</h3>
<p>小 A 有一个质数口袋，里面可以装各个质数。他从 2
开始，依次判断各个自然数是不是质数，如果是质数就会把这个数字装入口袋。</p>
<p>口袋的负载量就是口袋里的所有数字之和。</p>
<p>但是口袋的承重量有限，装的质数的和不能超过
L。请问口袋里能装下几个质数？将这些质数从小往大输出，然后输出最多能装下的质数的个数，数字之间用换行隔开。</p>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; L &gt; <span class="number">0</span>; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">sqrt</span>(i);  <span class="comment">// j 在 for 循环之后还要用，考虑作用域，j的定义不能放在for里面</span></span><br><span class="line">        <span class="keyword">for</span>( ; j &gt; <span class="number">1</span>; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明 i 不是质数</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没continue，执行到了这里，说明 i 是质数</span></span><br><span class="line">        <span class="keyword">if</span>(L &lt; i) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 已经无法再装了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L &gt;= i) &#123;</span><br><span class="line">            L -= i;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知识点：在C语言中，变量的作用域（Scope）指的是变量在程序中可以被访问的有效范围。作用域决定了变量的可见性，即在代码的哪些部分可以引用该变量。</p>
</blockquote>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>04.函数与结构体</title>
    <url>/2025-03-06-04-%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="函数与结构体">函数与结构体</h1>
<p>本章讲解C语言中函数与结构体的核心概念。函数通过定义、调用与参数传递实现代码复用与逻辑分离。递归用于解决分治问题，需注意栈溢出风险。结构体封装多种数据类型，定义自定义对象，支持成员函数与运算符重载，提升代码可读性与维护性。实例演示函数、递归与结构体的应用，帮助掌握模块化编程与复杂数据管理。</p>
<span id="more"></span>
<h2 id="函数基本概念">函数基本概念</h2>
<h3 id="什么是函数">什么是函数</h3>
<ul>
<li>一段具有特定功能的代码块</li>
<li>可以执行某项特定任务并返回结果</li>
</ul>
<p>例如输入<code>a</code>与<code>b</code>求<code>a+b</code>这件事，不使用函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Add</span>(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的定义">函数的定义</h3>
<p>函数的定义：</p>
<ol type="1">
<li>返回值类型：定义返回类型，<code>void</code>则表示不返回内容；</li>
<li>函数名：用该名字调用函数；</li>
<li>参数类型： <span
class="math inline">\(0\)</span>个或多个参数，参数之间用“<code>,</code>”隔开；</li>
<li>参数名：每个参数类型之后跟参数名，在函数里可以使用这些参数；</li>
<li>函数内逻辑：执行特定任务；</li>
<li>返回值：如果返回值类型不是<code>void</code>，则必须用<code>return</code>返回一个变量的值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;返回值&gt; &lt;函数名&gt;(&lt;参数类型<span class="number">1</span>&gt; &lt;参数名<span class="number">1</span>&gt;, &lt;参数类型<span class="number">2</span>&gt; &lt;参数名<span class="number">2</span>&gt;, ...) &#123;</span><br><span class="line">    &lt;函数逻辑&gt;</span><br><span class="line">    <span class="keyword">return</span> &lt;返回值&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>&lt;返回值&gt;</code>不是<code>void</code>，则函数结尾必须<code>return &lt;返回值&gt;</code></p>
<p>无返回值的函数示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>推荐将自定义函数写在<code>int main</code>的上面，否则编译器在执行<code>main()</code>的时候不知道这个函数；</li>
<li>函数的名称和变量名都是大小写敏感的，定义<code>Add()</code>就不能用<code>add()</code>去调用；</li>
</ul>
<h3 id="函数的调用与参数传递">函数的调用与参数传递</h3>
<p>函数通过函数名调用，格式是
<code>&lt;函数名&gt; (&lt;参数1&gt;, &lt;参数2&gt;, ...);</code></p>
<ol type="1">
<li>没有返回值的函数，直接调用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>有返回值的函数，将返回值赋值给变量，或直接使用返回值
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">Add</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Add</span>(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>参数要与变量类型对应，定义<code>int</code>则对应传入<code>int</code>，定义<code>double</code>则对应传入<code>double</code>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;****</span><br><span class="line">    <span class="comment">// scanf ...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="built_in">Add</span>(x, y));</span><br><span class="line">    <span class="comment">// 错误示例：char x, y; Add(x, y); Add的参数是double，不能传char参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>函数内对参数的修改，不会影响到调用函数所传的变量</strong></p>
<p>尝试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test1: %d\n&quot;</span>, a);</span><br><span class="line">    a += <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test2: %d\n&quot;</span>, a);</span><br><span class="line">    a *= <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test3: %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">Change</span>(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test4: %d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Test1: 10</span><br><span class="line">Test2: 12</span><br><span class="line">Test3: 36</span><br><span class="line">Test4: 10</span><br></pre></td></tr></table></figure>
<p>可以这样认为，将<code>main</code>中的<code>x</code>传入<code>Change</code>函数时，函数得到的是<code>x</code>的一个副本<code>a</code>，对<code>a</code>的任何修改都是对副本的修改，不会影响<code>x</code>本来的值。</p>
<p>这里传给函数的<code>x</code>称为“实际参数”，函数得到的<code>a</code>称为“形式参数”。</p>
<p>在<code>C++</code>中，如果想让函数得到变量“本体”，可使用叫做“引用”的语法，即在参数前加“<code>&amp;</code>”符号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">(<span class="type">int</span> &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test1: %d\n&quot;</span>, a);</span><br><span class="line">    a += <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test2: %d\n&quot;</span>, a);</span><br><span class="line">    a *= <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test3: %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">Change</span>(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test4: %d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Test1: 10</span><br><span class="line">Test2: 12</span><br><span class="line">Test3: 36</span><br><span class="line">Test4: 36</span><br></pre></td></tr></table></figure>
<p>两份代码唯一区别是
<code>Change</code>函数定义时，其参数定义由<code>int a</code>改为了<code>int &amp;a</code>，表示对传入参数的引用，这样对<code>a</code>的修改会对本体<code>x</code>生效。</p>
<p><strong>函数的返回可以“截断”后续的逻辑</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(<span class="number">8</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当满足
<code>a&lt;b</code>时，<code>return a</code>的逻辑会被执行，函数中任何<code>return</code>被执行时，之后的代码都不会再被执行。</p>
<p>当不满足<code>a&lt;b</code>时，代码会继续向下执行到<code>return b</code>。</p>
<h3 id="函数的意义">函数的意义</h3>
<ul>
<li>复用同一段代码处理相同的任务</li>
<li>让程序更加模块化，更易于理解和维护</li>
</ul>
<p>例：分别求 <span class="math inline">\(1\sim 10\)</span>、 <span
class="math inline">\(200\sim 300\)</span>的和并输出</p>
<p>不使用函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1~10的和=%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">200</span>; i &lt;= <span class="number">300</span>; i ++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;200~300的和=%d&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用函数：</span><br><span class="line"></span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CalSum</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; i ++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d~%d的和=%d&quot;</span>, start, end, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CalSum</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">CalSum</span>(<span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数精简了代码，且逻辑清晰。</p>
<p>如果这时任务改成，“求一段数从第一个数开始，奇数位置上的和”，如果没有使用函数，则每个执行此任务的地方都要修改代码。当使用函数时，只需要修改<code>CalSum</code>这个函数内的<code>i ++</code>改成<code>i += 2</code>就可以，代码维护变得简单。</p>
<h2 id="函数的递归">函数的递归</h2>
<h3 id="递归的定义">递归的定义</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">名词定义 递归() &#123;</span><br><span class="line">    <span class="keyword">return</span> 递归();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归即函数自己调用自己，或若干个函数在互相调用。当然上面的示例看起来永远不会结束，它是一个无限递归。</p>
<p>通常用递归来解决可以被分解的问题，在问题足够小的时候有一个终点。比如给出
<span class="math inline">\(n\)</span>，求 <span
class="math inline">\(n\)</span>的阶乘，即 <span
class="math inline">\(n!=1\times 2\times, \dots,
n\)</span>，递归可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(x - <span class="number">1</span>) * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以一个合理的递归，应该有两部分组成</p>
<ol type="1">
<li>对问题的分解：调用函数本身去解决一个“更小”的问题
<ul>
<li>这里<code>f(x - 1)</code>
就是对问题的分解，递归地去处理规模更小的<code>x-1</code>的阶乘，并乘以<code>x</code>得到<code>f(x)</code>的解</li>
</ul></li>
<li>递归的终点：当问题足够小时，以一个确定的逻辑返回，而不再继续分解
<ul>
<li><code>if(x == 0) return 1</code>就是在做这件事，确保递归不会无限进行下去，<code>0</code>是一个足够小的问题</li>
</ul></li>
</ol>
<h3 id="递归的意义">递归的意义</h3>
<p>实际上，任何递归逻辑都可以用非递归的代码去完成，比如阶乘，用一个循环将
<span class="math inline">\(1\sim n\)</span>累乘起来也能实现。</p>
<p>但在一些复杂问题中，递归能帮助我们更好地理清思路，将问题抽丝剥茧，要比从全局思考正确步骤更为容易。</p>
<p>以汉诺塔问题为例，有三根柱子，一根柱子上有 <span
class="math inline">\(n\)</span>个大小不同的盘子，将所有的盘子移动到另一根柱子上，在移动过程中，任何时候都不能让大盘子在小盘子上面。</p>
<img src="/2025-03-06-04-%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/hanoi.gif" class="" title="三个盘子的汉诺塔">
<p>如果把柱子从左到右命名为 <span class="math inline">\(A\)</span>、
<span class="math inline">\(B\)</span>、 <span
class="math inline">\(C\)</span>，以“<code>A to C</code>”这样的指令表示把
<span class="math inline">\(A\)</span>最顶部的盘子挪到 <span
class="math inline">\(C\)</span>的最顶部，当一开始 <span
class="math inline">\(A\)</span>柱有 <span
class="math inline">\(n\)</span>个盘子，以一系列指令给出将所有盘子在约束条件下从
<span class="math inline">\(A\)</span>移到 <span
class="math inline">\(C\)</span>的方案。</p>
<p>不用递归的话，面对这个问题还是很懵的，那么定义一个这样的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> x, <span class="type">char</span> y, <span class="type">char</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示把<code>n</code>个盘子从变量<code>x</code>所表示的柱子，利用<code>y</code>作为辅助柱子，以符合题目要求的方式全部移动到<code>z</code>所表示的柱子上。</p>
<p>那么第一次调用这个函数应该是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Hanoi</span>(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>可以这样分解该问题：</p>
<ol type="1">
<li><span class="math inline">\(A\)</span>上的 <span
class="math inline">\(n-1\)</span>个盘子通过 <span
class="math inline">\(C\)</span>先移到 <span
class="math inline">\(B\)</span></li>
<li><span class="math inline">\(A\)</span>上最底部的那个盘子直接移到
<span class="math inline">\(C\)</span>，即输出“<code>A to C</code>”</li>
<li><span class="math inline">\(B\)</span>上当前的 <span
class="math inline">\(n-1\)</span>个盘子通过 <span
class="math inline">\(A\)</span>移到 <span
class="math inline">\(C\)</span>， <span
class="math inline">\(C\)</span>上在第2步放的那个最大的盘子完全不影响这
<span class="math inline">\(n-1\)</span>个盘子的任何移动</li>
</ol>
<p>这3步就完成了整个任务。而第1步和第3步是相同的问题，只是问题规模减小了1，且起点柱子和终点柱子不同了而已，他们可以递归地调用<code>Hanoi</code></p>
<p>完整的递归代码这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c to %c\n&quot;</span>, x, z); <span class="comment">// x 和 z 具体是哪个柱子这里并不重要</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Hanoi</span>(n - <span class="number">1</span>, x, z, y);      <span class="comment">// 执行第 1 步</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c to %c\n&quot;</span>, x, z); <span class="comment">// 执行第 2 步</span></span><br><span class="line">        <span class="built_in">Hanoi</span>(n - <span class="number">1</span>, y, x, z);      <span class="comment">// 执行第 3 步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">Hanoi</span>(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归栈">递归栈</h3>
<p>当一个函数被调用或被递归地调用，调用结束时代码还要继续往下进行，操作系统怎么“恢复现场”呢？</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">1</span> : <span class="built_in">f</span>(x - <span class="number">1</span>) * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>, a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(n));</span><br><span class="line">    <span class="comment">// 当刚刚的 f(n) 运行结束，操作系统如何回到这里，并知道 n==10，a==5？</span></span><br><span class="line">    n ++;</span><br><span class="line">    a += n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, n, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就有一个“栈内存”的概念，每当调用函数，在进入函数执行前，系统会“保护现场”，把所有信息保存到一块内存中。当函数执行完毕，会从这块栈内存把所有信息读回来“恢复现场”并继续执行接下来的代码。</p>
<p>通常系统的栈内存有一个固定大小，当递归时，每次调用都会“保护现场”，占用一些栈内存，那么递归得太深，就可能把栈内存用尽，程序就会出错，这种情况称为“栈溢出”。</p>
<p>比如递归求一个很大的阶乘</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = n == <span class="number">0</span> ? <span class="number">1</span> : <span class="built_in">f</span>(n - <span class="number">1</span>) * n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now: %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    n = <span class="number">1000000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为现代编译器会做一些优化来尽可能避免栈溢出，这里作为栈溢出的例子增加了一些无用代码来确保溢出不会被优化掉，这方面的知识大家以后会了解。</p>
<p>栈溢出的知识点告诉我们，在思考一个问题解法的时候，如果需要的递归深度离谱的高，就要慎重考虑一下是不是最好的方案了。</p>
<p>当然还有一个更常见的情况，也是建议，较大的数组放在<code>main</code>函数外面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐做法：</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不建议做法：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数内的一切变量都开在“栈内存”中，过大会导致栈溢出。而函数外的变量会开在“堆内存”中，这就是其他话题了，此处不再赘述。</p>
<h2 id="结构体">结构体</h2>
<h3 id="结构体的概念">结构体的概念</h3>
<p>将多种变量封装到一起从而自定义一种类型。</p>
<p>一个“学生”有学号、年龄、身高、体重等信息，如果一个程序想以“学生”作为对象来做数据处理，或者以某种条件筛选学生并返回学生信息：</p>
<p>不使用结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出学生信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStu</span><span class="params">(<span class="type">int</span> ID, <span class="type">int</span> age, <span class="type">int</span> height, <span class="type">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, ID, age, height, weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取特定ID的学生信息并输出</span></span><br><span class="line"><span class="type">int</span> ID_list[<span class="number">1000</span>], age_list[<span class="number">1000</span>], height_list[<span class="number">1000</span>], weight_list[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Search</span><span class="params">(<span class="type">int</span> ID_search)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> id_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; id_i &lt; <span class="number">1000</span>; id_i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ID_list[id_i] == ID_search) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintStu</span>(ID_list[id_i], age_list[id_i], height_list[id_i], weight_list[id_i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这还只是简单的需求。如果一个学生要记录更多维度的信息如姓名、住址、手机号等等等等，代码的编写将十分繁琐且不便维护。</p>
<p>将一个学生作为一个统一的对象，把信息打包封装：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID, age, height, weight;</span><br><span class="line">&#125;;</span><br><span class="line">Student s[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Search</span><span class="params">(<span class="type">int</span> ID_search)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> id_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; id_i &lt; <span class="number">1000</span>; id_i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[id_i].ID == ID_search) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintStu</span>(s[id_i].ID, s[id_i].age, s[id_i].height, s[id_i].weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样<code>Student</code>
就可以作为一个自定义的数据类型，去定义变量或数组，每个该类型的变量都会包含“学生”这一概念的各种信息。</p>
<p>用结构体定义的变量称为该结构体的“对象”，用“<code>.</code>”来调用对象内的变量。</p>
<h3 id="成员函数">成员函数</h3>
<p>如果一些功能只与结构体自身有关，可以理解为这个结构体自身的某种功能，那么可以将函数定义为结构体的“成员函数”，同样用“<code>.</code>”来调用对象内的成员函数，成员函数可以直接使用和修改对象内的变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID, age, height, weight;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ID = age = height = weight = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, ID, age, height, weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Student s[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Search</span><span class="params">(<span class="type">int</span> ID_search)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    s[id_i].<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符的重载">运算符的重载</h3>
<p><code>int</code>、<code>double</code>这些类型天然具备的
<code>+,-,*,/,&gt;,&lt;</code>
等操作，作为自定义变量类型的结构体并没有良好的定义。</p>
<p>我们当然可以用函数实现结构体之间的各种运算，但如果能用这些运算符，会让代码逻辑更为清晰。</p>
<p>比如两个学生的大小用年龄的大小关系来定义，函数可以这样实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID, age, height, weight;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Bigger</span><span class="params">(<span class="type">const</span> Student &amp;that)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前对象比 that 对象的 age 更大则返回 true</span></span><br><span class="line">        <span class="keyword">return</span> age &gt; that.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Student a, b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a.age = <span class="number">10</span>;</span><br><span class="line">    b.age = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">Bigger</span>(b)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a is bigger\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a is not bigger\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而重载运算符，就可以在结构体的对象之间执行相应的运算，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID, age, height, weight;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Student &amp;that) &#123;</span><br><span class="line">        <span class="comment">// 当前对象比 that 对象的 age 更大则返回 true</span></span><br><span class="line">        <span class="keyword">return</span> age &gt; that.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Student a, b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a.age = <span class="number">10</span>;</span><br><span class="line">    b.age = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a is bigger\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a is not bigger\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>05.线性表</title>
    <url>/2025-03-06-05-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="线性表">线性表</h1>
<p>线性表是数据结构的基础，分为顺序存储与链式存储。顺序表通过数组实现，支持快速随机访问，适用于频繁读取的场景；链表通过节点链接实现，适合频繁增删操作。本文详细介绍了顺序表的基本操作、STL中的vector容器、二分查找算法，以及单链表、循环链表和双向链表的实现与应用。通过实例演示了线性表在多项式表示中的使用，帮助掌握线性表的核心概念与操作技巧。</p>
<span id="more"></span>
<h2 id="线性表的顺序存储">线性表的顺序存储</h2>
<h3 id="顺序表基本操作">顺序表基本操作</h3>
<p><strong>逻辑上相邻的数据，存储在物理上相邻的存储单元</strong></p>
<p>不同变量类型可能占据不同大小的内存，比如<code>char</code>占 <span
class="math inline">\(1\)</span> 字节，<code>int</code> 占 <span
class="math inline">\(4\)</span> 字节，下表用 <span
class="math inline">\(b\)</span> 表示数组 <span
class="math inline">\(a\)</span> 的起始地址， <span
class="math inline">\(L\)</span>表示数组单个元素占内存大小。</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 5%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 13%" />
<col style="width: 6%" />
<col style="width: 13%" />
<col style="width: 7%" />
<col style="width: 6%" />
<col style="width: 19%" />
<col style="width: 3%" />
</colgroup>
<thead>
<tr class="header">
<th>存储地址：</th>
<th>b</th>
<th>b+L</th>
<th>...</th>
<th>b+(i-1)L</th>
<th>...</th>
<th>b+(n-1)L</th>
<th>b+nL</th>
<th>...</th>
<th>b+(maxlen-1)L</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>内存状态：</td>
<td>a[0]</td>
<td>a[1]</td>
<td>...</td>
<td>a[i]</td>
<td>...</td>
<td>a[n]</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>线性表位序：</td>
<td>0</td>
<td>1</td>
<td>...</td>
<td>i</td>
<td>...</td>
<td>n</td>
<td>空闲地址</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>基本操作</p>
<ul>
<li>单个增加</li>
<li>单个插入</li>
<li>单个缩短</li>
<li>单个删除</li>
<li>批量增加</li>
<li>批量插入</li>
<li>定长缩短</li>
<li>批量删除</li>
<li>特定值存在性判断</li>
<li>元素非重复式插入</li>
<li>无序表非重复合并</li>
<li>有序表合并</li>
</ul>
<p>单个插入示例</p>
<table>
<thead>
<tr class="header">
<th>下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数值</td>
<td>12</td>
<td>32</td>
<td>50</td>
<td>17</td>
<td>18</td>
<td>30</td>
<td>27</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td>插入33</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>插入后</td>
<td>12</td>
<td>32</td>
<td>50</td>
<td>33</td>
<td>17</td>
<td>18</td>
<td>30</td>
<td>27</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXLEN=<span class="number">100</span>;   <span class="comment">// 要求至多存100个元素</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>], len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> x, <span class="type">int</span> &amp;len, <span class="type">int</span> ith)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将x插入坐标ith，超过表限制长度则报错，并维护表长度</span></span><br><span class="line">    <span class="keyword">if</span>(len == MAXLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;          <span class="comment">// 假设-1为报错信号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt; ith; i --) &#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>];    <span class="comment">// 把ith位置之后的元素向后挪</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[ith] = x;             <span class="comment">// ith位置已空出，放入x</span></span><br><span class="line">    len ++;                 <span class="comment">// 维护元素个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    len = <span class="number">0</span>;    <span class="comment">// 最初没有元素</span></span><br><span class="line">    <span class="built_in">Insert</span>(a, <span class="number">3</span>, len, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(a, <span class="number">1</span>, len, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(a, <span class="number">5</span>, len, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(a, <span class="number">8</span>, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 查看输出是否为 3 8 1 5 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>批量删除示例，按左闭右开区间 <span class="math inline">\([s,
e)\)</span>进行批量删除</p>
<table>
<thead>
<tr class="header">
<th>下标</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数值</td>
<td>12</td>
<td>32</td>
<td>50</td>
<td>17</td>
<td>18</td>
<td>30</td>
<td>27</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td>s</td>
<td></td>
<td>e</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>插入后</td>
<td>12</td>
<td>32</td>
<td>50</td>
<td>30</td>
<td>27</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXLEN=<span class="number">100</span>;   <span class="comment">// 要求至多存100个元素</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>], len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DelRange</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> x, <span class="type">int</span> &amp;len, <span class="type">int</span> s, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除 [s, e) 左闭右开区间内的元素，也就是把 e 之后所有元素平移到 s</span></span><br><span class="line">    <span class="type">int</span> i = s, j = <span class="built_in">min</span>(len, e);</span><br><span class="line">    <span class="keyword">for</span>(; j &lt; len; i ++, j ++) &#123;</span><br><span class="line">        a[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    len = i;    <span class="comment">// 平移结束时，i 指向的就是最后一个元素的下一个位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stl用vector作为顺序表">STL：用vector作为顺序表</h3>
<p>C++的STL提供了vector容器，可以更灵活动态地创建顺序表并使用内置的功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;         <span class="comment">// 初始化一个长为10的vector</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, a.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 上句输出 10</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;       <span class="comment">// 初始化一个长为5，所有值为3的vector</span></span><br><span class="line">    <span class="comment">// 用传统循环遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上句输出 3 3 3 3 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    b.<span class="built_in">insert</span>(b.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">999</span>);   <span class="comment">// 在下标 3 位置插入 999</span></span><br><span class="line">    <span class="comment">// 用迭代器 iterator 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(std::vector&lt;<span class="type">int</span>&gt;::iterator it = b.<span class="built_in">begin</span>(); it != b.<span class="built_in">end</span>(); it ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上句输出 3 3 3 999 3 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    b.<span class="built_in">push_back</span>(<span class="number">666</span>);               <span class="comment">// 在末尾插入 666</span></span><br><span class="line">    <span class="comment">// 用C++11开始支持的“auto”遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : b) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上句输出 3 3 3 999 3 3 666</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    b.<span class="built_in">resize</span>(<span class="number">200</span>);                  <span class="comment">// 大小改为200，扩展出的数值未定义</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>, b.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 上句输出 200</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector更多丰富功能可参考<a
href="https://zh.cppreference.com/w/cpp/container/vector">CPP官方文档</a></p>
<h3 id="二分查找">二分查找</h3>
<p>在一个已经从小到大有序的数组中查找特定数值的位置，可以有比一遍循环挨个查看更快的方法.</p>
<p>猜数小游戏：想一个 <span
class="math inline">\(1000\)</span>以内的整数，让朋友猜，只提示高了还是低了.
显而易见的策略是先猜 <span
class="math inline">\(500\)</span>，如果低了那么下一次就猜 <span
class="math inline">\(750\)</span>，如果高了就猜 <span
class="math inline">\(250\)</span>，很快（大约 <span
class="math inline">\(10\)</span> 次）就能得到答案.</p>
<p>在有序数组上的二分查找就是这个道理，可以快速判断特定数值是否在数组中存在，以及在哪个位置.</p>
<img src="/2025-03-06-05-%E7%BA%BF%E6%80%A7%E8%A1%A8/bsearch.gif" class="" title="二分查找">
<p>上图对应这样一份二分查找代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">100</span>], length; <span class="comment">// 有序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BiSearch</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> a[], <span class="type">int</span> alen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// left right 标识左闭右开区间</span></span><br><span class="line">    <span class="comment">// 即 left 指向首元素，right指向末元素的下一个位置</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = alen;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// left与right的中间位置，这里右移运算与除以2等价</span></span><br><span class="line">        <span class="type">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt;= num) left = mid;</span><br><span class="line">        <span class="keyword">else</span> right = mid; <span class="comment">// right 保持考察区间右侧开区间，这里已排除mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// left 的位置是搜索结果</span></span><br><span class="line">    <span class="keyword">return</span> a[left] == num ? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当有序数组中有重复元素时，需求可能会分为 Lower Bound 和 Upper
Bound，他们的定义是：</p>
<ul>
<li><strong>Lower Bound</strong>：对于给定的元素 <span
class="math inline">\(x\)</span>，不小于 <span
class="math inline">\(x\)</span> 的第一个元素的位置</li>
<li><strong>Upper Bound</strong>：对于给定的元素 <span
class="math inline">\(x\)</span>，大于 <span
class="math inline">\(x\)</span>的第一个元素的位置</li>
</ul>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LowerBound</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在元素个数为 n 的有序数组 a[] 中查找 x 的 Lower Bound</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n, mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt;= x) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left == n ? <span class="number">-1</span> : left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UpperBound</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在元素个数为 n 的有序数组 a[] 中查找 x 的 Upper Bound</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n, mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; x) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left == n ? <span class="number">-1</span> : left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发现 LowerBound 与 UpperBound
有微妙的区别，为了加深理解，可以自己设计一个有重复元素的有序数组，模拟一下过程，或者用调试的方式单步执行。</p>
<p>二分查找的写法并不唯一，比如前面动图的代码和后面的 Lower Bound
写法就有区别，新手很容易在处理边界时困惑或出错，比如
<code>if(a[mid] &gt; x)</code>还是<code>if(a[mid] &gt;= x)</code>？为什么
<code>right = mid</code> 而 <code>left = mid + 1</code>？循环条件是
<code>left &lt; right</code> 还是 <code>left &lt;= right</code> ？</p>
<p>在手动模拟过程理解一份正确的二分查找代码后，<strong>把它背下来</strong>，可以减少未来可能的出错。</p>
<p>接下来也给出使用<code>vector</code>和<code>stl</code>内置的实现方法，一些<code>stl</code>使用细节不明白的地方可以先跳过或查询资料，当以后熟练了再回来看。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LowerBound</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">return</span> it == a.<span class="built_in">end</span>() ? <span class="number">-1</span> : it - a.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UpperBound</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br><span class="line">    <span class="keyword">return</span> it == a.<span class="built_in">end</span>() ? <span class="number">-1</span> : it - a.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性表的链式存储">线性表的链式存储</h2>
<h3 id="单链表">单链表</h3>
<p>逻辑上相邻的数据元素在物理上不一定相邻</p>
<table>
<thead>
<tr class="header">
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>⬇头指针</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>存储地址：</td>
<td>1</td>
<td>7</td>
<td>13</td>
<td>19</td>
<td>25</td>
<td>31</td>
<td>37</td>
<td>43</td>
</tr>
<tr class="even">
<td>数据域：</td>
<td>LI</td>
<td>QIAN</td>
<td>SUN</td>
<td>WANG</td>
<td>WU</td>
<td>ZHAO</td>
<td>ZHENG</td>
<td>ZHOU</td>
</tr>
<tr class="odd">
<td>指针域：</td>
<td>43</td>
<td>13</td>
<td>1</td>
<td>NULL</td>
<td>37</td>
<td>7</td>
<td>19</td>
<td>25</td>
</tr>
</tbody>
</table>
<img src="/2025-03-06-05-%E7%BA%BF%E6%80%A7%E8%A1%A8/linked_list.svg" class="" title="链表示例">
<p>基本定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;    <span class="comment">// 值</span></span><br><span class="line">    Node *nex;  <span class="comment">// 指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddHead</span><span class="params">(Node *hp, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数 x 插入头节点为 head 的链表开头——头插法</span></span><br><span class="line">    Node *p = <span class="keyword">new</span> Node;</span><br><span class="line">    p-&gt;val = x;</span><br><span class="line">    p-&gt;nex = hp-&gt;nex;</span><br><span class="line">    hp-&gt;nex = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddTail</span><span class="params">(Node *hp, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数 x 插入头节点为 head 的链表结尾——尾插法</span></span><br><span class="line">    Node *p = <span class="keyword">new</span> Node;</span><br><span class="line">    Node *r;</span><br><span class="line">    <span class="keyword">for</span>(r = hp; r-&gt;nex != <span class="literal">nullptr</span>; r = r-&gt;nex);  <span class="comment">// 找到链表末尾</span></span><br><span class="line">    p-&gt;val = x;</span><br><span class="line">    p-&gt;nex = r-&gt;nex;</span><br><span class="line">    r-&gt;nex = p;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *head = <span class="keyword">new</span> Node;  <span class="comment">// 头节点</span></span><br><span class="line">    head-&gt;nex = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">AddHead</span>(head, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">AddHead</span>(head, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">AddTail</span>(head, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(Node *p = head-&gt;nex; p != <span class="literal">nullptr</span>; p = p-&gt;nex) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本操作</p>
<ul>
<li>单个增加</li>
<li>单个插入</li>
<li>单个缩短</li>
<li>单个删除</li>
<li>批量增加</li>
<li>批量插入</li>
<li>定长缩短</li>
<li>批量删除</li>
<li>特定值存在性判断</li>
<li>元素非重复式插入</li>
<li>无序表非重复合并</li>
<li>有序表合并</li>
</ul>
<p>思考：为什么要有不存数值的“头节点”？</p>
<ul>
<li>尝试分别用有无头节点的方式执行基本操作</li>
<li>考虑有无头节点情况下空表分别如何体现</li>
</ul>
<p>思考：什么时候用顺序表，什么时候用链表？</p>
<ul>
<li>顺序表方便随机存取：需要频繁读取第x个元素的任务</li>
<li>链表方便频繁增删：需要频繁增删部分元素的任务</li>
</ul>
<h3 id="单链表的静态实现">单链表的静态实现</h3>
<p>算法竞赛用固定可控的内存管理更不易出错，链表指针无非表达数据存储的位置，数组下标一样可以实现。</p>
<p><strong>推荐在比赛中用静态数组与下标的方式管理链式结构，尽量避免使用指针</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> nex;    <span class="comment">// 指针改为数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line">Node lst[<span class="number">999</span>];  <span class="comment">// 提前开好足够题目使用的内存作为待用链表节点</span></span><br><span class="line"><span class="type">int</span> tp;         <span class="comment">// 一个模拟内存控制的下标变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟新建一个节点，返回lst中的下标</span></span><br><span class="line">    lst[tp].nex = <span class="number">-1</span>;   <span class="comment">// 用 -1 下标表达“空指针”的含义</span></span><br><span class="line">    tp ++;              <span class="comment">// 让 tp 指向下一个待使用的Node</span></span><br><span class="line">    <span class="keyword">return</span> tp - <span class="number">1</span>;      <span class="comment">// tp刚刚++了，tp-1才是刚分配好的Node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddHead</span><span class="params">(<span class="type">int</span> hp, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数 x 插入头节点下标为 hp 的链表开头——头插法</span></span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">NewNode</span>();</span><br><span class="line">    lst[p].val = x;</span><br><span class="line">    lst[p].nex = lst[hp].nex;</span><br><span class="line">    lst[hp].nex = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddTail</span><span class="params">(<span class="type">int</span> hp, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数 x 插入头节点为 head 的链表结尾——尾插法</span></span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">NewNode</span>(), r;</span><br><span class="line">    <span class="keyword">for</span>(r = hp; lst[r].nex != <span class="number">-1</span>; r = lst[r].nex);  <span class="comment">// 找到链表末尾</span></span><br><span class="line">    lst[p].val = x;</span><br><span class="line">    lst[p].nex = lst[r].nex;</span><br><span class="line">    lst[r].nex = p;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tp = <span class="number">0</span>;     <span class="comment">// 初始化节点分配下标为0</span></span><br><span class="line">    <span class="type">int</span> head = <span class="built_in">NewNode</span>();</span><br><span class="line">    <span class="built_in">AddHead</span>(head, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">AddHead</span>(head, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">AddTail</span>(head, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = lst[head].nex; p != <span class="number">-1</span>; p = lst[p].nex) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, lst[p].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环链表">循环链表</h3>
<p>给出一个单链表中间某个节点的指针，无法找到它之前的节点。</p>
<p>如果把链表首尾相连，让最后一个节点指向头节点，就可以从任何位置出发找到所有节点。</p>
<img src="/2025-03-06-05-%E7%BA%BF%E6%80%A7%E8%A1%A8/linked_list_loop.svg" class="" title="循环链表">
<p>小练习：仅知道尾指针<code>rearA</code>与<code>rearB</code>的情况下合并两个循环链表为一个循环链表</p>
<img src="/2025-03-06-05-%E7%BA%BF%E6%80%A7%E8%A1%A8/linked_list_loop_merge.svg" class="" title="循环链表">
<p>尝试补全代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> nex;</span><br><span class="line">&#125;;</span><br><span class="line">Node lst[<span class="number">9999</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> rearA, <span class="type">int</span> rearB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// lst[rearA]和lst[rearB]分别是两个循环链表最后节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表">双向链表</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> prior;  <span class="comment">// 指向上一个节点</span></span><br><span class="line">    <span class="type">int</span> nex;    <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line">DNode lst[<span class="number">9999</span>];</span><br><span class="line"><span class="type">int</span> tp = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试在 <code>p</code> 节点之前插入元素 <code>x</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DLInsert</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试在删除<code>p</code>节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DLDelete</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考答案如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DLInsert</span>(<span class="type">int</span> p, <span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="type">int</span> np = <span class="built_in">NewNode</span>();</span><br><span class="line">    lst[np].val = x;</span><br><span class="line">    <span class="comment">// 设定新节点 np 的前后下标</span></span><br><span class="line">    lst[np].nex = p;</span><br><span class="line">    lst[np].prior = lst[p].prior;</span><br><span class="line">    <span class="comment">// 更新 p 之前节点的后下标</span></span><br><span class="line">    lst[lst[p].prior].nex = np;</span><br><span class="line">    <span class="comment">// 更新 p 节点的前下标</span></span><br><span class="line">    lst[p].prior = np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DLDelete</span>(<span class="type">int</span> p) &#123;</span><br><span class="line">    <span class="comment">// 更新 p 之前节点的后下标</span></span><br><span class="line">    lst[lst[p].prior].nex = lst[p].nex;</span><br><span class="line">    lst[lst[p].nex].prior = lst[p].prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小练习一元多项式">小练习：一元多项式</h3>
<p>稠密一元多项式：各项指数相差不大</p>
<p><span
class="math inline">\(P(x)=10+5x-4x^{2}+3x^{3}+2x^{4}\)</span></p>
<p>用顺序表表达</p>
<table>
<thead>
<tr class="header">
<th>指数 x</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>系数 p[x]</td>
<td>10</td>
<td>5</td>
<td>-4</td>
<td>3</td>
<td>2</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">999</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);                <span class="comment">// n项</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i])          <span class="comment">// 读取 0~n-1各项系数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稀疏一元多项式：指数差别很大，比如 <span
class="math inline">\(2x^{1352412369}+x^{1000000000}\)</span></p>
<p>用链表表达</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;      <span class="comment">// 系数</span></span><br><span class="line">    <span class="type">int</span> e;      <span class="comment">// 指数</span></span><br><span class="line">    <span class="type">int</span> nex;    <span class="comment">// 链表下一个节点下标</span></span><br><span class="line">&#125;;</span><br><span class="line">Node lst[<span class="number">9999</span>];</span><br><span class="line"><span class="type">int</span> tp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NewNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddTail</span><span class="params">(<span class="type">int</span> hp, <span class="type">int</span> c, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, e;</span><br><span class="line">    tp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> head = <span class="built_in">NewNode</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);                <span class="comment">// n项，但指数不保证连续</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;c, &amp;e);      <span class="comment">// 输入保证 e 从小到大递增</span></span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">NewNode</span>();</span><br><span class="line">        lst[p].c = c;</span><br><span class="line">        lst[p].e = e;</span><br><span class="line">        <span class="built_in">AddTail</span>(head, c, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考：两个这样的多项式相加如何计算和保存结果<br />
提示：因为 e
递增，可以两个游标分别对应两个链表异步对齐前进，新结果插入到新链表中</p>
</blockquote>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>06.字符串基础</title>
    <url>/2025-03-06-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="字符串基础">字符串基础</h1>
<p>字符串生活中最常见的数据类型，任何显示出来可查看的文本内容都是字符串，比如“<code>123456</code>”、“<code>abcdefg!@#$</code>”。</p>
<p>在一个网页上快速地查找某个内容，在一个名单里快速确定某个同学是否存在以及在第几行，都是字符串处理的任务。</p>
<span id="more"></span>
<h2 id="字符数组">字符数组</h2>
<p>字符类型<code>char</code>构成的数组存储的一系列字符可以构成一个字符串，也是<code>C</code>语言管理字符串的基本形式。</p>
<h3 id="基本定义与读写">基本定义与读写</h3>
<p>字符数组通过标准输入<code>scanf</code>的<code>%s</code>占位符来读取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">9</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line"><span class="type">char</span> b[<span class="number">9</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> c[] = <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %s\n&quot;</span>, a, b, c);</span><br></pre></td></tr></table></figure>
<p>之前我们学习过数组的概念，这里数组的变量名 <code>a</code>
是这个数组第一个元素的内存地址，读取一个字符串，就是用<code>%s</code>把字符串以一个内存地址为起始位置连续写入。</p>
<p>如果对上述代码输入“<code>cats</code>”，则<code>a</code>数组的内存存储情况会像这样：</p>
<table>
<thead>
<tr class="header">
<th>相对<code>a</code>的内存偏移</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>存储内容</td>
<td>c</td>
<td>a</td>
<td>t</td>
<td>s</td>
<td>\0</td>
<td>随机</td>
<td>随机</td>
<td>随机</td>
<td>随机</td>
</tr>
</tbody>
</table>
<p>注意到<code>cats</code>之后内存地址保存的是“<code>\0</code>”，它是一个转义符号，由<code>scanf</code>自动添加，表示字符串的结尾，是字符串必须保留的一部分，由此可见，一个长度为
<span class="math inline">\(4\)</span> 的字符串，需要占用的内存量是
<span class="math inline">\(5\)</span> 个
<code>char</code>。<code>\0</code>之后的内存所保存的内容，程序不关心，有的系统在定义数组的时候会将数组内存都初始化为<code>0</code>，但有的不会，这些位置可以是任何值，且原则上不会被读取，直到程序往这些地方写入确定的内容，并把<code>\0</code>推后，这些地址才会有意义。</p>
<p>字符串数组也可以用字符串常量初始化。如果不指定数组大小并用字符串常量初始化，那么字符串数组会根据字符串常量的大小加上<code>\0</code>来开辟内存。</p>
<h3 id="ascii码">ASCII码</h3>
<p>在目前（2024年）的操作系统中，字符类型<code>char</code>实际上存储的是一个有
<span class="math inline">\(8\)</span> 个二进制位的整数，即 <span
class="math inline">\(-128 \sim 127\)</span>
之间的数，我们通常关心的是它在 <span class="math inline">\(0 \sim
127\)</span> 的取值，包括了键盘上的大多符号以及一些不可见的符号。比如
<span class="math inline">\(65\)</span> 就是大写字母 “<code>A</code>”，
<span class="math inline">\(97\)</span> 就是小写字母
“<code>a</code>”，刚才提到的标志字符串末尾的转义字符 “<code>\0</code>”
的ASCII码等于 <span class="math inline">\(0\)</span>。</p>
<p>既然 <code>char</code>
实际上是整数，那么它自然也可以做一些基本的整数运算，而在输出时，取决于
<code>printf</code>
使用的占位符，过程中会根据输出的格式进行类型强制转换，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;97 as int: %d\n97 as char: %c\n&#x27;a&#x27; as int: %d\n&#x27;a&#x27; as char: %c\n&quot;</span>, <span class="number">97</span>, <span class="number">97</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>得到结果如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">97 as int: 97</span><br><span class="line">97 as char: a</span><br><span class="line">&#x27;a&#x27; as int: 97</span><br><span class="line">&#x27;a&#x27; as char: a</span><br></pre></td></tr></table></figure>
<p>作为整数，也同样可以进行加减乘除运算，由于字母表在ASCII码中是连续的，这给我们处理
<span class="math inline">\(26\)</span>
个英文字母带来了些许便利，比如想要按顺序输出 <span
class="math inline">\(26\)</span> 个大写字母，可以这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, <span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据大写字母 “<code>A</code>”是 <span
class="math inline">\(65\)</span>， 小写字母 “<code>a</code>” 是 <span
class="math inline">\(97\)</span>
这个信息，也可以方便地做大小写转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Lower case of %c is %c\n&quot;</span>, a, a + <span class="number">32</span>);</span><br></pre></td></tr></table></figure>
<p>ASCII码表如下</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 15%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td><code>NUT</code></td>
<td>32</td>
<td><code>(空格)</code></td>
<td>64</td>
<td><code>@</code></td>
<td>96</td>
<td><code>`</code></td>
</tr>
<tr class="even">
<td>1</td>
<td><code>SOH</code></td>
<td>33</td>
<td><code>!</code></td>
<td>65</td>
<td><code>A</code></td>
<td>97</td>
<td><code>a</code></td>
</tr>
<tr class="odd">
<td>2</td>
<td><code>STX</code></td>
<td>34</td>
<td><code>"</code></td>
<td>66</td>
<td><code>B</code></td>
<td>98</td>
<td><code>b</code></td>
</tr>
<tr class="even">
<td>3</td>
<td><code>ETX</code></td>
<td>35</td>
<td><code>#</code></td>
<td>67</td>
<td><code>C</code></td>
<td>99</td>
<td><code>c</code></td>
</tr>
<tr class="odd">
<td>4</td>
<td><code>EOT</code></td>
<td>36</td>
<td><code>$</code></td>
<td>68</td>
<td><code>D</code></td>
<td>100</td>
<td><code>d</code></td>
</tr>
<tr class="even">
<td>5</td>
<td><code>ENQ</code></td>
<td>37</td>
<td><code>%</code></td>
<td>69</td>
<td><code>E</code></td>
<td>101</td>
<td><code>e</code></td>
</tr>
<tr class="odd">
<td>6</td>
<td><code>ACK</code></td>
<td>38</td>
<td><code>&amp;</code></td>
<td>70</td>
<td><code>F</code></td>
<td>102</td>
<td><code>f</code></td>
</tr>
<tr class="even">
<td>7</td>
<td><code>BEL</code></td>
<td>39</td>
<td><code>,</code></td>
<td>71</td>
<td><code>G</code></td>
<td>103</td>
<td><code>g</code></td>
</tr>
<tr class="odd">
<td>8</td>
<td><code>BS</code></td>
<td>40</td>
<td><code>(</code></td>
<td>72</td>
<td><code>H</code></td>
<td>104</td>
<td><code>h</code></td>
</tr>
<tr class="even">
<td>9</td>
<td><code>HT</code></td>
<td>41</td>
<td><code>)</code></td>
<td>73</td>
<td><code>I</code></td>
<td>105</td>
<td><code>i</code></td>
</tr>
<tr class="odd">
<td>10</td>
<td><code>LF</code></td>
<td>42</td>
<td><code>*</code></td>
<td>74</td>
<td><code>J</code></td>
<td>106</td>
<td><code>j</code></td>
</tr>
<tr class="even">
<td>11</td>
<td><code>VT</code></td>
<td>43</td>
<td><code>+</code></td>
<td>75</td>
<td><code>K</code></td>
<td>107</td>
<td><code>k</code></td>
</tr>
<tr class="odd">
<td>12</td>
<td><code>FF</code></td>
<td>44</td>
<td><code>,</code></td>
<td>76</td>
<td><code>L</code></td>
<td>108</td>
<td><code>l</code></td>
</tr>
<tr class="even">
<td>13</td>
<td><code>CR</code></td>
<td>45</td>
<td><code>-</code></td>
<td>77</td>
<td><code>M</code></td>
<td>109</td>
<td><code>m</code></td>
</tr>
<tr class="odd">
<td>14</td>
<td><code>SO</code></td>
<td>46</td>
<td><code>.</code></td>
<td>78</td>
<td><code>N</code></td>
<td>110</td>
<td><code>n</code></td>
</tr>
<tr class="even">
<td>15</td>
<td><code>SI</code></td>
<td>47</td>
<td><code>/</code></td>
<td>79</td>
<td><code>O</code></td>
<td>111</td>
<td><code>o</code></td>
</tr>
<tr class="odd">
<td>16</td>
<td><code>DLE</code></td>
<td>48</td>
<td><code>0</code></td>
<td>80</td>
<td><code>P</code></td>
<td>112</td>
<td><code>p</code></td>
</tr>
<tr class="even">
<td>17</td>
<td><code>DCI</code></td>
<td>49</td>
<td><code>1</code></td>
<td>81</td>
<td><code>Q</code></td>
<td>113</td>
<td><code>q</code></td>
</tr>
<tr class="odd">
<td>18</td>
<td><code>DC2</code></td>
<td>50</td>
<td><code>2</code></td>
<td>82</td>
<td><code>R</code></td>
<td>114</td>
<td><code>r</code></td>
</tr>
<tr class="even">
<td>19</td>
<td><code>DC3</code></td>
<td>51</td>
<td><code>3</code></td>
<td>83</td>
<td><code>S</code></td>
<td>115</td>
<td><code>s</code></td>
</tr>
<tr class="odd">
<td>20</td>
<td><code>DC4</code></td>
<td>52</td>
<td><code>4</code></td>
<td>84</td>
<td><code>T</code></td>
<td>116</td>
<td><code>t</code></td>
</tr>
<tr class="even">
<td>21</td>
<td><code>NAK</code></td>
<td>53</td>
<td><code>5</code></td>
<td>85</td>
<td><code>U</code></td>
<td>117</td>
<td><code>u</code></td>
</tr>
<tr class="odd">
<td>22</td>
<td><code>SYN</code></td>
<td>54</td>
<td><code>6</code></td>
<td>86</td>
<td><code>V</code></td>
<td>118</td>
<td><code>v</code></td>
</tr>
<tr class="even">
<td>23</td>
<td><code>TB</code></td>
<td>55</td>
<td><code>7</code></td>
<td>87</td>
<td><code>W</code></td>
<td>119</td>
<td><code>w</code></td>
</tr>
<tr class="odd">
<td>24</td>
<td><code>CAN</code></td>
<td>56</td>
<td><code>8</code></td>
<td>88</td>
<td><code>X</code></td>
<td>120</td>
<td><code>x</code></td>
</tr>
<tr class="even">
<td>25</td>
<td><code>EM</code></td>
<td>57</td>
<td><code>9</code></td>
<td>89</td>
<td><code>Y</code></td>
<td>121</td>
<td><code>y</code></td>
</tr>
<tr class="odd">
<td>26</td>
<td><code>SUB</code></td>
<td>58</td>
<td><code>:</code></td>
<td>90</td>
<td><code>Z</code></td>
<td>122</td>
<td><code>z</code></td>
</tr>
<tr class="even">
<td>27</td>
<td><code>ESC</code></td>
<td>59</td>
<td><code>;</code></td>
<td>91</td>
<td><code>[</code></td>
<td>123</td>
<td><code>&#123;</code></td>
</tr>
<tr class="odd">
<td>28</td>
<td><code>FS</code></td>
<td>60</td>
<td><code>&lt;</code></td>
<td>92</td>
<td><code>\</code></td>
<td>124</td>
<td><code>\|</code></td>
</tr>
<tr class="even">
<td>29</td>
<td><code>GS</code></td>
<td>61</td>
<td><code>=</code></td>
<td>93</td>
<td><code>]</code></td>
<td>125</td>
<td><code>&#125;</code></td>
</tr>
<tr class="odd">
<td>30</td>
<td><code>RS</code></td>
<td>62</td>
<td><code>&gt;</code></td>
<td>94</td>
<td><code>^</code></td>
<td>126</td>
<td><code>~</code></td>
</tr>
<tr class="even">
<td>31</td>
<td><code>US</code></td>
<td>63</td>
<td><code>?</code></td>
<td>95</td>
<td><code>_</code></td>
<td>127</td>
<td><code>DEL</code></td>
</tr>
</tbody>
</table>
<p>特殊字符解释</p>
<table>
<tbody>
<tr class="odd">
<td>NUL空</td>
<td>VT 垂直制表</td>
<td>SYN 空转同步</td>
</tr>
<tr class="even">
<td>STX 正文开始</td>
<td>CR 回车</td>
<td>CAN 作废</td>
</tr>
<tr class="odd">
<td>ETX 正文结束</td>
<td>SO 移位输出</td>
<td>EM 纸尽</td>
</tr>
<tr class="even">
<td>EOY 传输结束</td>
<td>SI 移位输入</td>
<td>SUB 换置</td>
</tr>
<tr class="odd">
<td>ENQ 询问字符</td>
<td>DLE 空格</td>
<td>ESC 换码</td>
</tr>
<tr class="even">
<td>ACK 承认</td>
<td>DC1 设备控制1</td>
<td>FS 文字分隔符</td>
</tr>
<tr class="odd">
<td>BEL 报警</td>
<td>DC2 设备控制2</td>
<td>GS 组分隔符</td>
</tr>
<tr class="even">
<td>BS 退一格</td>
<td>DC3 设备控制3</td>
<td>RS 记录分隔符</td>
</tr>
<tr class="odd">
<td>HT 横向列表</td>
<td>DC4 设备控制4</td>
<td>US 单元分隔符</td>
</tr>
<tr class="even">
<td>LF 换行</td>
<td>NAK 否定</td>
<td>DEL 删除</td>
</tr>
</tbody>
</table>
<h3 id="字符串常量与变量">字符串常量与变量</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="type">char</span> b[<span class="number">10</span>] = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"><span class="type">char</span> c[<span class="number">10</span>] = <span class="string">&quot;%c %s\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(c, a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;!!xyz\n&quot;</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>输出内容为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x xyz</span><br><span class="line">xyz</span><br></pre></td></tr></table></figure>
<p>通过这个示例代码发现，平时我们用 <code>scanf</code> 与
<code>printf</code>
时，第一个用于格式化的参数其实就是一个字符串常量，那么我们也可以用符合格式的变量去替代它，即这里的
<code>c</code>。</p>
<p><strong>特别注意</strong>：
<strong>字符</strong>常量用单引号“<code>'</code>”包裹，<strong>字符串</strong>常量用双引号“<code>"</code>”包裹。</p>
<p>字符串常量也可以做内存地址偏移的操作。我们知道一个数组
<code>char c[10];</code>，变量<code>c</code>本身实际上是这个数组第 <span
class="math inline">\(1\)</span>个元素的内存地址，那么<code>c+1</code>自然就是这个数组的第
<span
class="math inline">\(2\)</span>个元素的内存地址。对于字符串常量<code>"!!xyz\n"</code>，如果做运算<code>"!!xyz\n" + 2</code>，就能得到这个字符串常量的第
<span class="math inline">\(3\)</span> 个元素的内存地址，即
<code>x</code>
对应的地址，当<code>printf("!!xyz\n" + 2);</code>时，<code>printf</code>接收到的就是
<code>"xyz\n"</code> 了。</p>
<h3 id="字符串的常用函数">字符串的常用函数</h3>
<p><code>C</code>语言的<code>string.h</code>头文件提供了丰富的字符串处理函数，掌握一些常用函数会极大提高开发效率。</p>
<p>以下是一些C语言字符串函数的使用实例：</p>
<ol type="1">
<li><p><code>strlen</code>：计算字符串的长度。返回值为字符串的长度，类型为<code>size_t</code>。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>strcpy</code>：复制一个字符串到另一个字符串中。返回值为目标字符串的指针。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">20</span>] = <span class="string">&quot;xxxxxxxxxxx&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">char</span>* ret = <span class="built_in">strcpy</span>(s1, s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ret); <span class="comment">// 输出：&quot;abcdef&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>strcat</code>：字符串拼接。返回值为目标字符串的指针。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">100</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">100</span>] = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1); <span class="comment">// 输出：&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>strcmp</code>：字符串比较。如果两个字符串相等，返回0；如果第一个字符串大于第二个字符串，返回大于0的值，这个值是第一个字符串中第一个不相等的字符的ASCII值减去第二个字符串中对应字符的ASCII值；反之返回小于0的值。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">strcmp</span>(s1, s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret); <span class="comment">// 输出：32</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>strchr</code>：查找字符串中第一次出现第 <span
class="math inline">\(2\)</span>个参数（字符）的位置的指针。如果字符未在字符串中出现则返回<code>NULL</code>。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abcabcabc&quot;</span>;</span><br><span class="line"><span class="type">char</span>* ret = <span class="built_in">strchr</span>(s, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ret); <span class="comment">// 输出：&quot;bcabcabc&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>strstr</code>：检索第 <span
class="math inline">\(2\)</span>个字符串在第 <span
class="math inline">\(1\)</span>个字符串中首次出现的位置的指针，如果子串未在字符串中出现则返回<code>NULL</code>。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;abcabcabc&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;bca&quot;</span>;</span><br><span class="line"><span class="type">char</span>* ret = <span class="built_in">strstr</span>(s1, s2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ret); <span class="comment">// 输出：&quot;bcaabcabc&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>strtok</code>：将一个字符串分割为多个子字符串，返回值为下一个子字符串的指针，如果没有更多的子字符串则返回<code>NULL</code>。如果分隔符在被分割字符串中连续出现，连续的若干个分隔符会被视为
<span class="math inline">\(1\)</span> 个分隔符。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc,def,,ghi&quot;</span>;</span><br><span class="line"><span class="type">char</span>* delim = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p = strtok(s, delim);</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p); <span class="comment">// 输出：&quot;abc&quot;，然后是&quot;def&quot;，最后是&quot;ghi&quot;</span></span><br><span class="line">    p = strtok(<span class="literal">NULL</span>, delim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>strncpy</code>：拷贝源字符串的前<code>num</code>个字符至目标字符串，第一个参数是目标字符串，第二个参数是源字符串。返回值为目标字符串的指针。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">20</span>] = <span class="string">&quot;xxxxxxxxxxx&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="type">char</span>* ret = <span class="built_in">strncpy</span>(s1, s2, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ret); <span class="comment">// 输出：&quot;abcxxxxxxxx&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>strncat</code>：将第二个参数的前<code>n</code>个字符追加到字符串结尾。返回值为目标字符串的指针。</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">100</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">100</span>] = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"><span class="built_in">strncat</span>(s1, s2, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1); <span class="comment">// 输出：&quot;Hello Wo&quot;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>strncmp</code>：指定长度比较。如果两个字符串的前<code>n</code>个字符相等，返回0，对前<code>n</code>个字符的比较规则与
<code>strcmp</code>类似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">strncmp</span>(s1, s2, <span class="number">2</span>);   <span class="comment">// 比较前 2 个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);            <span class="comment">// 输出：32</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="stl的string">STL的string</h2>
<p><code>C++</code>的STL中有一个<code>string</code>容器可以做一些简单的字符串操作，初学者可以把它理解为一个封装了字符串数组的结构体。</p>
<h3 id="定义和初始化">定义和初始化</h3>
<p><code>string</code>需要<code>C++</code>的头文件<code>#include&lt;string&gt;</code>，注意与<code>C</code>语言头文件<code>#include&lt;string.h&gt;</code>区分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">std::string str1;           <span class="comment">// 创建一个空字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">str2</span><span class="params">(<span class="string">&quot;Hello!&quot;</span>)</span></span>; <span class="comment">// 从一个C风格字符串创建</span></span><br><span class="line"><span class="function">std::string <span class="title">str3</span><span class="params">(str2)</span></span>;     <span class="comment">// 从另一个string对象创建</span></span><br><span class="line"><span class="function">std::string <span class="title">str4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">// 创建一个包含10个字符&#x27;a&#x27;的字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="访问和修改字符">访问和修改字符</h3>
<p>使用 <code>operator[]</code> 或 <code>at()</code>
函数来访问或修改字符串中的字符。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch1 = str[<span class="number">0</span>]; <span class="comment">// 访问第一个字符</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;      <span class="comment">// 修改第一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch2 = str.<span class="built_in">at</span>(<span class="number">0</span>);   <span class="comment">// 访问第一个字符</span></span><br><span class="line">str.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="string">&#x27;y&#x27;</span>;        <span class="comment">// 修改第一个字符</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串长度">字符串长度</h3>
<p><code>size()</code> 或 <code>length()</code>
函数可以返回字符串的长度。<code>empty()</code>
函数可以检查字符串是否为空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 size() 或 length() 函数获取字符串长度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Length of str: %lu\n&quot;</span>, str.<span class="built_in">size</span>());     <span class="comment">// 输出：13</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Length of str: %lu\n&quot;</span>, str.<span class="built_in">length</span>());   <span class="comment">// 输出：13</span></span><br><span class="line"><span class="comment">// 使用 empty() 函数检查字符串是否为空</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Is str empty? %s\n&quot;</span>, str.<span class="built_in">empty</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>); <span class="comment">// 输出：No</span></span><br><span class="line">str = <span class="string">&quot;&quot;</span>; <span class="comment">// 将 str 设置为空字符串</span></span><br><span class="line"><span class="comment">// 再次检查字符串是否为空</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Is str empty? %s\n&quot;</span>, str.<span class="built_in">empty</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>); <span class="comment">// 输出：Yes</span></span><br></pre></td></tr></table></figure>
<h3 id="string输入与输出">string输入与输出</h3>
<p><code>C++</code>通常配合<code>STL</code>的<code>cin</code>与<code>cout</code>进行输入与输出，这需要头文件
<code>#include&lt;iostream&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::cin &gt;&gt; str;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你输入的字符串是：&quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>C++</code>虽然兼容<code>C</code>语言的语法，但<code>scanf</code>与<code>printf</code>针对底层字符串数组使用，与<code>string</code>配合时需要做一些处理。在输入时，先将字符串保存在字符数组中，再用字符数组的数据初始化一个<code>string</code>，在输出时，通过<code>string</code>的<code>c_str()</code>成员函数获取底层的字符串数组进行输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(buf)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你输入的字符串是：%s\n&quot;</span>, str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加和删除字符">添加和删除字符</h3>
<p><code>push_back()</code>
函数可以在字符串末尾添加一个字符，<code>pop_back()</code>
函数可以删除字符串末尾的字符。<code>append()</code> 或
<code>operator+=</code> 可以用来连接字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 push_back() 在字符串末尾添加一个字符</span></span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After push_back: %s\n&quot;</span>, str.<span class="built_in">c_str</span>());   <span class="comment">// 输出：Hello!</span></span><br><span class="line"><span class="comment">// 使用 pop_back() 删除字符串末尾的字符</span></span><br><span class="line">str.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After pop_back: %s\n&quot;</span>, str.<span class="built_in">c_str</span>());    <span class="comment">// 输出：Hello</span></span><br><span class="line"><span class="comment">// 使用 append() 连接字符串</span></span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;, World!&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After append: %s\n&quot;</span>, str.<span class="built_in">c_str</span>());      <span class="comment">// 输出：Hello, World!</span></span><br><span class="line"><span class="comment">// 使用 operator+= 连接字符串</span></span><br><span class="line">str += <span class="string">&quot; How are you?&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After operator+=: %s\n&quot;</span>, str.<span class="built_in">c_str</span>());  <span class="comment">// 输出：Hello, World! How are you?</span></span><br></pre></td></tr></table></figure>
<h3 id="子字符串和字符查找">子字符串和字符查找</h3>
<p><code>substr()</code> 函数可以返回一个子字符串。<code>find()</code>
和 <code>rfind()</code> 函数可以用来查找字符或子字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 substr() 返回一个子字符串</span></span><br><span class="line">std::string sub = str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Substr: %s\n&quot;</span>, sub.<span class="built_in">c_str</span>());    <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 find() 查找字符或子字符串</span></span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != std::string::npos) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Find: %lu\n&quot;</span>, pos);         <span class="comment">// 输出：7</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Find: Not found\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 rfind() 查找字符或子字符串</span></span><br><span class="line">pos = str.<span class="built_in">rfind</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != std::string::npos) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Rfind: %lu\n&quot;</span>, pos);        <span class="comment">// 输出：8</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Rfind: Not found\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串比较">字符串比较</h3>
<p>字符串的大小关系默认按ASCII码的编号来比，从两字符串的开头依次比较，第一次遇到不相同字符时，ASCII码小的那个字符串更小。对于<code>string</code>，可以使用
<code>operator==</code>，<code>operator!=</code>，<code>operator&lt;</code>，<code>operator&gt;</code>，<code>operator&lt;=</code>
和 <code>operator&gt;=</code> 来比较两个字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">std::string str3 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str1 == str3) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 == str3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str1 != str2) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 != str2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str1 &lt; str2) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 &lt; str2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str2 &gt; str1) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2 &gt; str1\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些其他操作">一些其他操作</h3>
<ol type="1">
<li><p>插入字符<code>insert()</code></p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;Greetings from &quot;</span>);   <span class="comment">// 在位置0插入子字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str.<span class="built_in">c_str</span>());        <span class="comment">// 输出：Greetings from Hello, World!</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>删除字符<code>erase()</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">5</span>);                <span class="comment">// 删除位置0开始的5个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str.<span class="built_in">c_str</span>());    <span class="comment">// 输出：, World!</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>替换字符<code>replace()</code></p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">5</span>, <span class="string">&quot;Hi&quot;</span>);        <span class="comment">// 替换位置0开始的5个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str.<span class="built_in">c_str</span>());    <span class="comment">// 输出：Hi, World!</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>在实际编程中，还会用到其他函数，可以查看<a
href="https://zh.cppreference.com/w/cpp/string/basic_string">官方文档</a>了解更多。</p>
<h2 id="字符串整行读入">字符串整行读入</h2>
<p>在C/C++中，使用<code>scanf("%s", str)</code>只能读取不带空白字符（如空格“<code></code>”、制表符“<code>\t</code>”）的字符串，但有时候需要一次性读入带空白字符的一整行字符，像这样：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hello, today is sunny!</span><br><span class="line">Yes, its great!</span><br></pre></td></tr></table></figure>
<p>这时最简单粗暴的方法是<code>while((ch = getchar()) != '\n')</code>，逐字符写入数组，但一方面这样做略嫌麻烦，另一方面由于<code>Windows</code>、<code>Linux</code>、<code>Mac</code>等不同系统在换行位置的占位符不尽相同，也会让整行读入的末尾兼容性有限，出现问题。</p>
<ol type="1">
<li><p>已淘汰的旧标准函数<code>gets()</code></p>
<p>依赖头文件
<code>#include&lt;stdio.h&gt;</code>，<code>gets()</code>可以从标准输入中连续读取字符直到出现换行符或文件末尾，读取结束后，末尾的
<code>\n</code> 会被替换为 <code>\0</code>
。由于该函数不检查数组边界，被认为不安全，所以在<code>C11</code>标准中被删除，但在一些比较古老的OJ中仍然只支持旧的编译器，<code>gets()</code>仍可使用。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">gets</span>(buf)) &#123;   <span class="comment">// 持续按行读取直到文件末尾</span></span><br><span class="line">    <span class="comment">// 进行后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>fgets()</code></p>
<p><code>fgets()</code>可以视为<code>gets()</code>的优化版。它多了两个参数，一个是输入流，可以指定为标准输入<code>stdin</code>，也可以指定为文件流，另一个指定最大写入字符数。</p>
<p>需要注意与<code>gets()</code>不同的是，<code>fgets()</code>会将读取到的<code>\n</code>保留在数组中，并在其后添加<code>\0</code>，这样读入的字符串会比我们平时预期的多一个字符，<strong>需要手动处理</strong>。</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="built_in">sizeof</span>(buf), stdin)) &#123;   <span class="comment">// 持续按行读取直到文件末尾</span></span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>;       <span class="comment">// 手动去掉末尾的\n</span></span><br><span class="line">    <span class="comment">// 进行后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>scanf()</code>也有办法</p>
<p>其实 <code>scanf()</code>
也可以整行读入，<code>scanf()</code>有两个比较少用的转换说明符<code>%[]</code>和<code>*</code></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]%*c&quot;</span>, buf);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>%[]</code>的功能与<code>%s</code>类似，但其只匹配<code>[]</code>中包含的字符，如<code>%[0-9]</code>为仅匹配数字，<code>%[a-zA-Z]</code>为仅匹配大小写字母。如果<code>[</code>后紧跟<code>^</code>则意为取补集，如<code>%[^0-9]</code>为匹配除数字以外的所有字符。</li>
<li><code>*</code>为抑制字符，跟在<code>%</code>后可以使当前转换说明符只匹配但不赋值给变量。</li>
</ul>
<p>在上面的代码中，<code>%[^\n]</code>用于将<code>\n</code>之前的所有字符写入str中，<code>%*c</code>用于读取剩下来的<code>\n</code>但不赋给变量。</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]%*c&quot;</span>, buf) != EOF) &#123; <span class="comment">// 持续按行读取直到文件末尾</span></span><br><span class="line">    <span class="comment">// 进行后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>STL</code>的<code>string</code>可以用<code>std::getline()</code></p>
<p>在引入头文件<code>iostream</code>和<code>string</code>后，就可以使用一种省心又省力的行读取办法：</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string st;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(std::cin, st)) &#123;    <span class="comment">// 持续按行读取直到文件末尾</span></span><br><span class="line">    <span class="comment">// 进行后续操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="注意事项">注意事项</h3>
<h4 id="对于c语言的处理方式">对于<code>C</code>语言的处理方式</h4>
<p>在整行读入前，需要先考虑上一行的<code>\n</code>是否残留并将其单独处理掉。</p>
<p>反面教材：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]%*c&quot;</span>, s); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（无输出）</span><br></pre></td></tr></table></figure>
<p>第一条<code>scanf()</code>语句读取两个整数后，留下了行末的<code>\n</code>未处理，被第二条<code>scanf()</code>的读取方式并不会跳过<code>\n</code>，导致<code>s</code>中遇到前一行的<code>\n</code>就停止了。</p>
<p>在极少数情况下，OJ中的数据文件以<code>\r\n</code>作为每行的结尾，而上述各种方法都只会将<code>\r</code>视作普通字符，<code>fgets()</code>读取的字符串会以<code>\r\n</code>结尾，<code>scanf()</code>、<code>gets()</code>则会在结尾处会多出<code>\r</code>，都没有完美地处理这种情况。</p>
<p>不过，在明确OJ中以<code>\r\n</code>作为每行的结尾时，可以对<code>scanf()</code>稍加修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\r]%*c%*c&quot;</span>, buf);  <span class="comment">// 此时读入以\n结尾的内容会出错</span></span><br></pre></td></tr></table></figure>
<p>否则，在不确定OJ是否以<code>\r\n</code>结尾时，建议按<code>\n</code>的情况处理。如果追求兼容性，可以使用<code>getchar()</code>逐字符判断。</p>
<h4
id="对于利用string的处理方式">对于利用<code>string</code>的处理方式</h4>
<p>需要注意的是，一旦决定使用<code>std::cin</code>和<code>std::cout</code>来作为输入输出方式，那就需要考虑解除流同步和流绑定，因为<code>std::cin</code>和<code>std::cout</code>默认会与<code>scanf()</code>和<code>printf()</code>的缓冲区进行同步，以保证可以在代码中同时使用这四种输入输出方法而不出现乱序输入输出的情况，但这会大大拖慢<code>std::cin</code>和<code>std::cout</code>的速度，我们需要在程序开头加入这一段代码来解除同步和绑定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在解除同步和绑定后，<code>std::cin</code>和<code>std::cout</code>就不能与<code>scanf()</code>和<code>printf()</code>同时使用了，但是换来了输入输出速度。</p>
<h3 id="一个封装实践">一个封装实践</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">999</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">gets_trim</span><span class="params">(<span class="type">char</span> buffer[], <span class="type">int</span> bufsize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fgets</span>(buffer, bufsize, stdin)) &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(buffer);</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span> &amp;&amp; buffer[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span> || buffer[len - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">            buffer[-- len] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">gets_trim</span>(buf, <span class="built_in">sizeof</span>(buf));    <span class="comment">// 消除前面的\n</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">gets_trim</span>(buf, <span class="built_in">sizeof</span>(buf))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>07.排序</title>
    <url>/2025-03-10-07-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序">排序</h1>
<p>将无序数据变为有序，不明确指定顺序的情况下默认从小到大排序。</p>
<p>排序需要具体的方案来实现，不同的方案执行效率不同，通常用元素的“比较次数”与“移动次数”作为执行的代价来衡量不同排序算法的效率。</p>
<span id="more"></span>
<p>综合评价一个排序算法有以下三个要素：</p>
<ul>
<li>时间复杂度：元素的比较次数与移动次数与数据规模 <span
class="math inline">\(n\)</span> 关系，通常简化为大写字母 <span
class="math inline">\(O\)</span>与 <span
class="math inline">\(n\)</span>
的多项式最高次幂去掉系数的形式表达，比如 <span
class="math inline">\(O(n^2)\)</span>、<span
class="math inline">\(O(nlog_{2}n)\)</span>等。</li>
<li>空间复杂度：一些排序算法需要利用额外的内存来完成，也用 <span
class="math inline">\(O\)</span>表达式表示，如果只用一两个或十几个<code>int</code>空间，通常称为空间复杂度
<span class="math inline">\(O(1)\)</span>，如果额外内存规模接近 <span
class="math inline">\(n\)</span> 且成正比，通常称为空间复杂度 <span
class="math inline">\(O(n)\)</span>。</li>
<li>稳定性：如果两个元素的关键数据相等，排序前与排序后这两元素的前后顺序总能保持不变，则这样的排序算法是“稳定”的；反之，如果排序后这两元素前后顺序可能变化，不能确保与排序前一致，就称为不稳定的。
举个例子，一个学生的信息用结构体表达： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> age, height, weight;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Student s[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure>
需要按身高排序，那么<code>height</code>就是关键数据，对
<code>s[1000]</code>
排序时，相同<code>height</code>的学生前后位置随意变化不影响排序的正确性，但是排序前与排序后他们的先后位置是否变化这一“稳定性”在有的应用场景是需要的，所以排序算法的稳定性是一个重要属性。</li>
</ul>
<h2 id="从插入排序到希尔排序">从插入排序到希尔排序</h2>
<h3 id="插入排序">插入排序</h3>
<p>插入排序在一个数组中从前往后对每个元素做处理，在“考察”元素
<code>a[i]</code> 时，实际上数组已经被分成两部分， <span
class="math inline">\([0,i)\)</span> 这部分是已经有序的部分（最开始考察
<code>a[0]</code>，它只有一个元素，当然也是有序的），<span
class="math inline">\([i + 1, n)\)</span>
这部分是后续要考察的。在有序的部分找出 <code>a[i]</code> 的 Lower
Bound，将 <code>a[i]</code> 插入到这个位置之前，就让有序的部分增加了
<span class="math inline">\(1\)</span>，直到<span
class="math inline">\([0, n)\)</span>都有序。</p>
<img src="/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_insert_base.svg" class="" title="基本插入排序">
<p>已经学过有序数组中的二分查找，那么找到 <code>a[i]</code>
插入的位置可以用二分查找比<code>for</code>循环一个个找过去更快一些。</p>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：最坏情况每个元素都插入最前面，把已经有序的数据往后挪，<span
class="math inline">\(1+2+\dots +n-1 \approx O(n^2)\)</span></li>
<li>空间复杂度：除了数组本身，额外空间只有一些辅助变量，并没有达到 <span
class="math inline">\(n\)</span> 的级别，是 <span
class="math inline">\(O(1)\)</span></li>
<li>稳定性：对于关键数据相等的元素，后考察的在先考察的后面，插入位置找
Lower Bound，能保证排序后相对关系不变，<strong>稳定</strong></li>
</ul>
<p>实现方式不唯一，查找和插入都可以用线性表章节练习时的方法实现，这里给一种参考：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insertionsort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> now = a[i], j;</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &gt; <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; now; j --) &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];    <span class="comment">// 遇到不大于now的数之前，挨个往后挪一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = now;             <span class="comment">// 找到不大于now的位置，插入到该位置之后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序">希尔排序</h3>
<p>把数据按下标按固定间距分组，比如 <span
class="math inline">\(0,5,10,\dots\)</span>一组，<span
class="math inline">\(1,6,11,\dots\)</span>一组，<span
class="math inline">\(2,7,12,\dots\)</span>一组……各组可以分别做插入排序，然后缩小分组的固定间距再来一次，直到间距为
<span class="math inline">\(1\)</span>时再来一次，完成排序。</p>
<p>这样排序带来效率提升的主要原因是，在普通插入排序中，每个数在插入正确的位置时需要一个一个地跳过在它前面比它大的数。</p>
<p>而希尔排序中通过有跨度的分组排序，可以让数据跳过很多移动步骤。</p>
<p>比如 <span class="math inline">\(5,6,7,3,1\)</span>
中，插入朴素插入排序需要让 <span
class="math inline">\(1\)</span>挨个跳过前面 <span
class="math inline">\(4\)</span> 个数，而用希尔排序，把 <span
class="math inline">\(5,7,1\)</span>分成一组， <span
class="math inline">\(6,3\)</span> 分成一组， <span
class="math inline">\(1\)</span> 只需要跳过 <span
class="math inline">\(5\)</span> 和 <span
class="math inline">\(7\)</span> 两个数就到达的正确位置。</p>
<p><span class="math inline">\(n\)</span> 个数希尔排序具体步骤是：</p>
<ol type="1">
<li>以 <span class="math inline">\(\lfloor n/2 \lfloor\)</span>
为间距分组，分别进行插入排序 比如 <span
class="math inline">\(3,5,2,4,6,1,7,8\)</span> ，第一次分组就是 <span
class="math inline">\(3,6\)</span> 一组（ <span
class="math inline">\(3\)</span> 的下标是 <span
class="math inline">\([0]\)</span>， <span
class="math inline">\(6\)</span> 的下标是 <span
class="math inline">\([4]\)</span>，间距为 <span
class="math inline">\(4\)</span>）， <span
class="math inline">\(5,1\)</span> 一组， <span
class="math inline">\(2,7\)</span> 一组， <span class="math inline">\(4,
8\)</span> 一组</li>
<li>以 <span class="math inline">\(\lfloor n/4 \lfloor\)</span>
为间距分组，分别进行插入排序</li>
<li>不断缩小分组间距，直到以 <span class="math inline">\(1\)</span>
为间距分组，此时只有一个组，包含所有数，进行最后一次插入排序</li>
</ol>
<p>假设带有间距的插入排序
<code>InsertShort(int a[], int n, int start, int gap)</code>
（<code>start</code>表示第几组，<code>gap</code>表示间距）已经实现，在希尔排序中调用它，希尔排序参考如下：</p>
<blockquote>
<p>思考：分组个数与 <code>gap</code> 是什么关系？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>; start &lt; gap; start ++) &#123;</span><br><span class="line">            <span class="built_in">InsertSort</span>(a, n, start, gap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：希尔排序具体能省略多少移动，与数据分布和gap有关，经验来说复杂度在
<span class="math inline">\(O(n^{1.25}) \sim
O(1.6n^{1.25})\)</span></li>
<li>空间复杂度：除了数组本身，额外空间只有一些辅助变量， <span
class="math inline">\(O(1)\)</span></li>
<li>稳定性：分组分别插入排序的时候，某个组的数可能跳过了其它组与它相等的数，从而无法保证稳定，是
<strong>不稳定</strong> 排序</li>
</ul>
<h2 id="从冒泡排序到快速排序">从冒泡排序到快速排序</h2>
<h3 id="冒泡排序">冒泡排序</h3>
<p>从头到尾挨个比较相邻的两个元素，如果前一个比后一个大，就交换两个的位置。</p>
<p>在这个过程中，最大的那个数肯定会被持续交换到结尾。</p>
<p>那么再来一轮，从头到尾挨个比较（不过最后那个位置已经是最大的数，就不用管它了），第二大的数肯定会交换到倒数第二个位置。</p>
<p>如此进行，就会将第三大、第四大的数一轮又一轮地推到后面，最后数组就有序了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++) &#123;          <span class="comment">// 进行 n-1 轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j ++) &#123;  <span class="comment">// 每多一轮，就可以少管末尾一个数</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;              <span class="comment">// 判断相邻两数是否要交换</span></span><br><span class="line">                std::<span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：两个循环，第二个循环（挨个比较）是个递减的等差数列，
<span class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：除了数组本身，额外空间只有一些辅助变量， <span
class="math inline">\(O(1)\)</span></li>
<li>稳定性：相等的数不交换，能确保稳定</li>
</ul>
<h3 id="快速排序">快速排序</h3>
<p>也是基于交换的排序，但是比冒泡排序能够进行更高效的交换，基本思想：</p>
<p>取一个元素为中心，所有比它小的元素放它前面，比它大的放它后面。前后两部分分别递归地做相同的事。</p>
<img src="/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_quick.gif" class="" title="快速排序">
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// left、right左闭右开，low、high闭区间</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right - <span class="number">1</span>) <span class="keyword">return</span>;   <span class="comment">// 递归终点，只有一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> low = left;         <span class="comment">// low 游标从待排序最左元素下标开始</span></span><br><span class="line">    <span class="type">int</span> high = right - <span class="number">1</span>;   <span class="comment">// high 游标从待排序最右元素下标开始</span></span><br><span class="line">    <span class="type">int</span> center = a[low];    <span class="comment">// 选最左元素作为中心，a[low]存到临时变量center中，此时 low 位置空了出来</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 从右边开始挨个往左看，不小于 center 就保持不动，否则停下</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt;= center) high --;</span><br><span class="line">        <span class="comment">// 遇到了一个小于 center 的元素 a[high]，放到 low 指向的位置，此时 high 位置空了出来</span></span><br><span class="line">        a[low] = a[high];</span><br><span class="line">        <span class="comment">// 从左边开始挨个往右看，不大于 center 就保持不动，否则停下</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= center) low ++;</span><br><span class="line">        <span class="comment">// 遇到一个大于 center 的元素 a[low]，放到 low 指向的位置，此时 low 位置空了出来</span></span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// while循环结束，low 与 high 相遇，该位置空了出来，把刚才拿出的 center 放回来</span></span><br><span class="line">    a[low] = center;</span><br><span class="line">    <span class="built_in">QuickSort</span>(a, left, low);        <span class="comment">// 递归处理左半边，区间 [left, low)</span></span><br><span class="line">    <span class="built_in">QuickSort</span>(a, low + <span class="number">1</span>, right);   <span class="comment">// 递归处理右半边，区间 [low + 1, right)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：此处不作详细分析，在理想情况下（或平均情况下） <span
class="math inline">\(O(nlogn)\)</span></li>
<li>空间复杂度：递归存储开销， <span
class="math inline">\(O(logn)\)</span></li>
<li>稳定性：用于划分的中心数字有一定随机性，无法保证稳定性，<strong>不稳定</strong></li>
</ul>
<p>最坏情况：选择划分数可能每次都在一端，退化为 <span
class="math inline">\(n^2\)</span>，可以每次在 <span
class="math inline">\(low, high, \lfloor (low + high) / 2
\rfloor\)</span>三者取中间数降低最坏情况概率。</p>
<h2 id="从选择排序到堆排序">从选择排序到堆排序</h2>
<h3 id="选择排序">选择排序</h3>
<ul>
<li>在所有数中找出最小的数，与第一个位置的数交换</li>
<li>在剩下的数里选最小的数，与第二个位置的数交换</li>
<li>重复以上操作，直到不再剩下数</li>
</ul>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：每次剩下的数是个等差数列， <span
class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：无额外开销， <span
class="math inline">\(O(n)\)</span></li>
<li>稳定性：交换操作可能破坏部分数的前后关系，<strong>不稳定</strong></li>
</ul>
<p>一种优化——树形选择排序</p>
<img src="/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_selection_tree.png" class="" title="树形选择排序">
<p>像世界杯这样的锦标赛方式捉对pk来选出最小的数，已选出的数拿走后把锦标赛的这一步该数改为无穷大，重复这个赛区的“比赛”能得到新的最小的数。</p>
<h3 id="堆排序">堆排序</h3>
<p>用一个二叉堆的数据结构在原数组空间中维护最小数，它可以在 <span
class="math inline">\(O(nlogn)\)</span> 的一次初始化之后，每次在 <span
class="math inline">\(O(logn)\)</span>
时间内维护堆结构（让各子堆的堆顶都是堆内的最小值）。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> s, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> nex = s &lt;&lt; <span class="number">1</span>; nex &lt;= e; nex &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nex + <span class="number">1</span> &lt;= e &amp;&amp; a[nex + <span class="number">1</span>] &lt; a[nex]) nex ++;</span><br><span class="line">        <span class="keyword">if</span>(a[s] &lt;= a[nex]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[s], a[nex]);</span><br><span class="line">        s = nex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n &gt;&gt; <span class="number">1</span>; i; i --) <span class="built_in">HeapAdjust</span>(a, i, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i --) &#123;</span><br><span class="line">        <span class="built_in">Swap</span>(a[i], a[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(a, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></li>
<li>空间复杂度：无额外开销， <span
class="math inline">\(O(1)\)</span></li>
<li>稳定性：<strong>不稳定</strong></li>
</ul>
<p>堆是一个很有意义的数据结构，未来会了解优先队列，有很多任务需要在一堆动态插入的数据中找最小，堆可以在
<span
class="math inline">\(O(logn)\)</span>时间内维护堆的性质的这一特性将非常有用，经典算法
Dijkstra、Prim等都会用到基于堆实现的优先级队列。</p>
<h2 id="归并排序">归并排序</h2>
<p>在学过顺序表的归并操作之后，归并排序就不难理解了。</p>
<ul>
<li>从左到右每 <span class="math inline">\(2\)</span> 个数归并一次</li>
<li>从左到右每 <span class="math inline">\(4\)</span> 个数的前 <span
class="math inline">\(2\)</span> 个数与后 <span
class="math inline">\(2\)</span> 个数归并一次</li>
<li>从左到右每 <span class="math inline">\(8\)</span> 个数的前 <span
class="math inline">\(4\)</span> 个数与后 <span
class="math inline">\(4\)</span> 个数归并一次</li>
<li>直到所有的数归并到了一起，全部有序</li>
</ul>
<p>不过实现归并排序用递归的方式会更加方便，参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> mergeTemp[<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">char</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [left, right) 是待排序的区间</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right - <span class="number">1</span>) <span class="keyword">return</span>;   <span class="comment">// 递归终点，只有1个数</span></span><br><span class="line">    <span class="type">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;    <span class="comment">// 取中点，划分为左右两半</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(a, left, mid);        <span class="comment">// 递归地对左半边归并排序</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(a, mid, right);       <span class="comment">// 递归地对右半边归并排序</span></span><br><span class="line">    <span class="comment">// 以上两个递归执行完后，左右两半边分别有序，接下来把两半边归并到一起</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i = k = left, j = mid; i &lt; mid &amp;&amp; j &lt; right; )</span><br><span class="line">    mergeTemp[k ++] = a[i] &lt;= a[j] ? a[i ++] : a[j ++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid) mergeTemp[k ++] = a[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; right) mergeTemp[k ++] = a[j ++];</span><br><span class="line">    <span class="comment">// 完成了[left, right)的排序，但用到了临时数组，把它拷贝回原数组这个区间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(a + left, mergeTemp + left, <span class="built_in">sizeof</span>(a[<span class="number">0</span>]) * (right - left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></li>
<li>空间复杂度：用到一个临时数组， <span
class="math inline">\(O(n)\)</span></li>
<li>稳定性：归并过程可以控制相等元素的先后关系，<strong>稳定</strong></li>
</ul>
<h2 id="非基于相互比较的排序">非基于相互比较的排序</h2>
<h3 id="基数排序">基数排序</h3>
<p>在对整数排序时，把各个十进制位分开考虑</p>
<ul>
<li>先将“个位”是 <span class="math inline">\(0 \sim 9\)</span>
的数放到对应的槽中，然后从 <span class="math inline">\(0 \sim 9\)</span>
的槽有序取出，所有数现在就按个位排好序了；</li>
<li>再将“十位”是 <span class="math inline">\(0 \sim 9\)</span>
的数放到对应的槽中，然后从 <span class="math inline">\(0 \sim 9\)</span>
的槽有序取出，所有数现在就按十位排好序了，且对于十位相同，个位不同的那些数，没有破坏之前个位排好的先后关系；</li>
<li>再将“百位”……</li>
<li>直到各个位都排完</li>
</ul>
<img src="/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_base.gif" class="" title="基数排序">
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1100</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; l[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSortIth</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> dec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        l[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        l[a[i] / dec % <span class="number">10</span>].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxa = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        maxa = maxa &gt; a[i] ? maxa : a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, dec = <span class="number">1</span>; maxa; i ++, maxa /= <span class="number">10</span>, dec *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">RadixSortIth</span>(a, n, dec);</span><br><span class="line">        <span class="built_in">MoveBack</span>(a, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计数排序">计数排序</h3>
<p>适用于一定范围不大的整数排序，初始化一个统计各个数出现次数的数组，遍历待排序数组，统计每个数的个数。</p>
<p>遍历计数的数组，把原数组的数从小到大按重复个数一一列出来，完成排序。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountingSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大数</span></span><br><span class="line">    <span class="type">int</span> maxa = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        maxa = maxa &gt; a[i] ? maxa : a[i];</span><br><span class="line">    <span class="comment">// 统计每个数的个数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(maxa + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        count[a[i]]++;</span><br><span class="line">    <span class="comment">// 按个数统计，从小到大列出每个数</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxa; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; count[i]; j ++)</span><br><span class="line">            a[index ++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="桶排序">桶排序</h3>
<p>把数值的区间分成若干个子区间，设置一些“桶”，把对应区间的数放进桶里。</p>
<p>对每个桶里的数用其它算法排序，再将各个桶的数取出按顺序放在一起。</p>
<h2 id="stl-sort-的基本使用">STL： sort 的基本使用</h2>
<p><code>C++</code>的 STL 提供了 sort
函数，它的前两个参数是待排序数组的开头和末尾的迭代器，默认升序排序。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>第三个参数可选，可以传入一个自己定义的比较两元素的函数，用于自定义排序方案，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br></pre></td></tr></table></figure>
<p>这个代码通过 <code>cmp</code> 就实现了降序排序</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>08.栈与队列</title>
    <url>/2025-03-10-08-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈与队列">栈与队列</h1>
<p>栈与队列是两种重要的线性数据结构，分别遵循后进先出与先进先出的操作原则，广泛应用于程序设计与算法问题的解决。</p>
<span id="more"></span>
<h2 id="栈">栈</h2>
<ul>
<li>食堂的餐盘：洗-&gt;放-&gt;取</li>
<li>浏览器的后退按钮：页面0-&gt;页面1 -&gt; 页面2 -&gt; 页面3 -&gt; 后退
-&gt; 后退，你在页面几？</li>
<li>文本编辑器的撤销（ctrl+z）、退格（&lt;--）输入：“abcdef”，按两下“&lt;--”键，剩下的是什么</li>
</ul>
<p>栈就像一个放盘子的容器，你只能从最上面放盘子或者取盘子，先放进去的盘子会被压在下面，要等上面的盘子都取走了才能取到，这种数据结构的特点就是先进后出，就像叠盘子和取盘子的过程一样。</p>
<h3 id="例小鱼的数字游戏">例：小鱼的数字游戏</h3>
<p>输入一串数字，以一个<code>0</code>结尾，倒过来输出</p>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3 65 23 5 34 1 30 0</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">30 1 34 5 23 65 3</span><br></pre></td></tr></table></figure>
<p>你当然可以输入到数组里，然后循环反过来输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">111</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 统计输入的个数</span></span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">0</span>; ; n ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[n]);</span><br><span class="line">        <span class="keyword">if</span>(a[n] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span> + (i == n - <span class="number">1</span>), a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实你已经发现了栈的一种实现方式，那就是用数组模拟它。更符合栈的定义一些，这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stk</span> &#123;</span><br><span class="line">    <span class="type">int</span> stk[<span class="number">111</span>];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="built_in">Stk</span>() &#123;top = <span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> top == <span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> stk[top];&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;top --;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;stk[++top] = x;&#125;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> top + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stk stk = <span class="built_in">Stk</span>();</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) &amp;&amp; x != <span class="number">0</span>) &#123;</span><br><span class="line">        stk.<span class="built_in">Push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; !stk.<span class="built_in">Empty</span>(); stk.<span class="built_in">Pop</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, stk.<span class="built_in">Top</span>());</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="built_in">Size</span>() &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在熟悉栈的工作方式后，可以用 C++ STL 中的栈容器来简化代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span> <span class="comment">// C++里的头文件</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) &amp;&amp; x) &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; !stk.<span class="built_in">empty</span>(); stk.<span class="built_in">pop</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, stk.<span class="built_in">top</span>());</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例表达式括号匹配">例：表达式括号匹配</h3>
<p>假设一个表达式有英文字母（小写）、运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）和左右小（圆）括号构成，以
<code>@</code>
作为表达式的结束符。请编写一个程序检查表达式中的左右圆括号是否匹配，若匹配，则输出
<code>YES</code>；否则输出 <code>NO</code>。</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(25+x)*(a*(a+b+b)@</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure>
<p>括号的层次就像栈，每遇到一个左括号，就“深”了一层，每遇到一个右括号，就“浅”了一层，那么左括号和右括号就想入栈和出栈一样，模拟这个操作，某个时候出栈比入栈多，或最后出栈比入栈少，就都是不正确的括号匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="type">char</span> s[<span class="number">550</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="type">bool</span> no_flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; s[i]; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">                no_flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!no_flag) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈是一类数据结构，同时也是一种思想，心中有栈，码中无栈，也可以解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> s[<span class="number">550</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="type">bool</span> no_flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> l_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; s[i]; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            l_cnt ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">                no_flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l_cnt --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!no_flag) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l_cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知识点：既然括号的深度与栈有对应关系，那么一个数学表达式的计算顺序也可以用栈来表达，甚至包括加减乘除的优先级，这就是“后缀表达式”，拆解一个数学表达式，根据运算顺序转为一个栈，就能条理清晰的按顺序计算，得到表达式的值。</p>
</blockquote>
<img src="/2025-03-10-08-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/calc_with_stack.gif" class="" title="表达式求值">
<h2 id="队列">队列</h2>
<p>队列就像生活中的排队，先到的人排在前面，遵循 “先进先出” 的规则。</p>
<img src="/2025-03-10-08-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/queue.svg" class="" title="队列">
<p>为更灵活计算某些问题，也可以设计一种两边都能入队与出队的<strong>双端队列</strong></p>
<img src="/2025-03-10-08-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/dequeue.svg" class="" title="双端队列">
<h3 id="例约瑟夫问题">例：约瑟夫问题</h3>
<p>n 个人围成一圈，从第一个人开始报数，每报第 <span
class="math inline">\(m\)</span> 个人出圈，输出依次出圈的编号。</p>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">10 3</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3 6 9 2 7 1 8 5 10 4</span><br></pre></td></tr></table></figure>
<p>此题有多种解法，用队列模拟是其中一种，如果一个队列出队后立刻排到队尾，就构成了一个圈。</p>
<p>队列可以用数组模拟，但队列和栈不同，不断地一端进另一端出，会很快到达数组的尽头，所以在代码组织上将数组的头尾接起来</p>
<blockquote>
<p>知识点：<strong>循环队列</strong>，让队头队尾到达数组末尾后，回到数组的开头，让数组首尾接为一个圈。为了避免错误地覆盖数据，需利用队首队尾的位置关系，合理判断队伍是空的还是满的。在竞赛中，可以简化这一点，直接把数组开得够大即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">111</span>];</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = DSIZE - <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> DSIZE = <span class="number">110</span>;  <span class="comment">// 队列容量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        a[rear = (rear + <span class="number">1</span>) % DSIZE] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        front = (front + <span class="number">1</span>) % DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % DSIZE == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">Queue q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        q.<span class="built_in">Push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; !q.<span class="built_in">Empty</span>(); i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % m != <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">Push</span>(q.<span class="built_in">Front</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q.<span class="built_in">Front</span>());</span><br><span class="line">            <span class="keyword">if</span>(i != n * m) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">Pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 C++ STL 的方法可自行尝试</p>
<h2 id="优先级队列">优先级队列</h2>
<p>有的场景中，出队的时候不是按到达顺序，而是有一个固定的优先规则，外在使用上和队列一样，但内在逻辑中通过特定规则优先出队，完成一些特殊的任务。</p>
<blockquote>
<p>知识点：优先队列中，按某种规则优先的高效机制是由<strong>堆</strong>这种数据结构来实现的，之后我们会学习。C++
STL 封装了优先队列，可以直接使用。</p>
</blockquote>
<h3 id="例外星窗口服务">例：外星窗口服务</h3>
<p>某外星窗口优先服务年长者，顾客陆续来到大厅等待，窗口每次叫号都是大厅中年龄最小的顾客，窗口服务的客户将离开大厅.</p>
<p>第一行 <span class="math inline">\(1\leq n\leq 100000\)</span>
，表示按顺序有 <span class="math inline">\(n\)</span>
个情况，情况有两类：</p>
<ul>
<li><code>1 x</code> 表示到来了一位年龄为 <span class="math inline">\(10
\leq x \leq 10^9\)</span> 的顾客；</li>
<li><code>2</code> 表示窗口叫了一次号，数据保证叫号时大厅有顾客.</li>
</ul>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">14</span><br><span class="line">1 81</span><br><span class="line">2</span><br><span class="line">1 17</span><br><span class="line">1 77</span><br><span class="line">2</span><br><span class="line">1 101</span><br><span class="line">1 66</span><br><span class="line">1 120</span><br><span class="line">1 68</span><br><span class="line">1 120</span><br><span class="line">1 89</span><br><span class="line">1 87</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">81</span><br><span class="line">17</span><br><span class="line">66</span><br><span class="line">68</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, op, ag;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="comment">// priority_queue默认大者优先，利用 std::greater&lt;int&gt; 实现小者优先</span></span><br><span class="line">    std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(n --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ag);</span><br><span class="line">            q.<span class="built_in">push</span>(ag);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">top</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>09.二叉树与哈夫曼编码</title>
    <url>/2025-03-12-09-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="二叉树与哈夫曼编码">二叉树与哈夫曼编码</h1>
<p>二叉树作为一种基础的数据结构，其独特的递归定义和多样化的类型，如满二叉树、完全二叉树等，为解决诸如查找、排序及编码等问题提供了强大的支持，而哈夫曼编码通过构建最优二叉树实现了数据的高效压缩。</p>
<span id="more"></span>
<h2 id="树">树</h2>
<p>递归式定义：一个根节点带0到多个子节点，每个子节点可以是一棵子树的根，子树也符合树的定义。</p>
<img src="/2025-03-12-09-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/tree.svg" class="" title="树的递归式定义">
<p>名词表：</p>
<ul>
<li><p>根：没有前驱</p></li>
<li><p>叶：没有后继</p></li>
<li><p>森林：多棵不相交的树</p></li>
<li><p>有序树：子树从左到右有序</p></li>
<li><p>无序树：一个根的不同子树可互换位置</p></li>
<li><p>父节点：直接前驱</p></li>
<li><p>子节点：直接后继</p></li>
<li><p>兄弟节点：同一个父节点的子节点</p></li>
<li><p>堂兄弟：两个节点的父节点不同且位于同一层</p></li>
<li><p>祖先：该节点到根节点路径上的所有节点</p></li>
<li><p>子孙：该节点子树中的任意节点</p></li>
<li><p>节点的度：一个节点的子节点数量</p></li>
<li><p>节点的层次：根节点到该节点的层数</p></li>
<li><p>终端节点：度为0的节点，即叶子</p></li>
<li><p>分支节点：度不为0的节点</p></li>
<li><p>树的度：所有节点的度的最大值</p></li>
<li><p>树的深度：最大的层数</p></li>
<li><p>满二叉树：每层都充满了，1层有1个点，2层有3个点，3层有7个点，找找规律~</p>
<ul>
<li><img src="/2025-03-12-09-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/binary_full.svg" class="" title="满二叉树"></li>
</ul></li>
<li><p>完全二叉树：除了最后面一层外全满，最后一层的点也聚集在“左边”，确定点的个数就完全可以确定完全二叉树的形态</p>
<ul>
<li><img src="/2025-03-12-09-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/binary_complete.svg" class="" title="完全二叉树"></li>
</ul></li>
<li><p>满二叉树与完全二叉树特性：如果从 1 开始一行一行地编号，对编号
<span class="math inline">\(i\)</span> 的节点，父节点编号 <span
class="math inline">\(i/2\)</span> ，左子节点 <span
class="math inline">\(i*2\)</span> ，右子节点 <span
class="math inline">\(i*2+1\)</span></p></li>
</ul>
<h2 id="二叉树">二叉树</h2>
<ul>
<li>所有节点度不大于2的树</li>
<li>有序树，即子树有左右之分</li>
</ul>
<p>也即二叉树是度为2的有序树的专有名词。</p>
<p>度为 2 的树，普通树与二叉树的典型区别：</p>
<ul>
<li>3个节点的二叉树有 5 种形态</li>
<li>3个节点的度为 2 的普通树有 2 种形态</li>
</ul>
<p>自行尝试画出它们</p>
<h3 id="遍历二叉树">遍历二叉树</h3>
<img src="/2025-03-12-09-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/binary_traversing.svg" class="" title="二叉树遍历">
<p>访问顺序： 先序 <strong style="color:red;">D</strong>
<strong style="color:blue;">L</strong>
<strong style="color:green;">R</strong>、中序
<strong style="color:blue;">L</strong>
<strong style="color:red">D</strong>
<strong style="color:green;">R</strong>、后序
<strong style="color:blue">L</strong>
<strong style="color:green;">R</strong>
<strong style="color:red">D</strong></p>
<p>上图二叉树的三个访问顺序的输出结果是</p>
<ul>
<li>先序遍历：A B D E C <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pre</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对数据做一个预定义的任务</span></span><br><span class="line">    <span class="comment">// 就是访问了这个数据</span></span><br><span class="line">    <span class="comment">// 比如printf(&quot;%d\n&quot;, data);</span></span><br><span class="line">    <span class="built_in">DoSomething</span>(tr[now].data);</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    <span class="keyword">if</span>(tr[now].left != fakeNull)</span><br><span class="line">    <span class="built_in">Pre</span>(tr[now].left);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    <span class="keyword">if</span>(tr[now].right != fakeNull)</span><br><span class="line">    <span class="built_in">Pre</span>(tr[now].right);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
<li>中序遍历：D B E A C <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">In</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    <span class="keyword">if</span>(tr[now].left != fakeNull)</span><br><span class="line">    <span class="built_in">In</span>(tr[now].left);</span><br><span class="line">    <span class="comment">// 访问当前节点数据</span></span><br><span class="line">    <span class="built_in">DoSomething</span>(tr[now].data);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    <span class="keyword">if</span>(tr[now].right != fakeNull)</span><br><span class="line">    <span class="built_in">In</span>(tr[now].right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>后序遍历：D E B C A <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Post</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问左子树</span></span><br><span class="line">    <span class="keyword">if</span>(tr[now].left != fakeNull)</span><br><span class="line">    <span class="built_in">Post</span>(tr[now].left);</span><br><span class="line">    <span class="comment">// 访问右子树</span></span><br><span class="line">    <span class="keyword">if</span>(tr[now].right != fakeNull)</span><br><span class="line">    <span class="built_in">Post</span>(tr[now].right);</span><br><span class="line">    <span class="comment">// 访问当前节点数据</span></span><br><span class="line">    <span class="built_in">DoSomething</span>(tr[now].data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3
id="例知道中序和后序遍历还原二叉树结构">例：知道中序和后序遍历，还原二叉树结构</h3>
<p>已知一棵二叉树的中序序列和后序序列分别是BDCEAFHG 和
DECBHGFA，请画出这棵二叉树</p>
<ol type="1">
<li>由后序遍历特征，根节点必在后序序列尾部（A）由</li>
<li>中序遍历特征，根节点必在其中间，而且其左部必全部是左子树子孙（BDCE），其右部必全部是右子树子孙（FHG）</li>
<li>根据后序中的DECB子树可确定B为A的左孩子，根据HGF子串可确定F为A的右孩子；以此类推，从而可以递归完成建树。</li>
</ol>
<img src="/2025-03-12-09-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/binary_restore.svg" class="" title="二叉树三序还原">
<h3 id="二叉搜索树">二叉搜索树</h3>
<p>如果递归式定义并构建一个左子树所有节点值都比根节点值小，所有右子树节点值都比根大，就可以很快地做一些查找工作，比二分查找的优势在于，二叉树可以不断地动态添加数据，并在查找时保持二分查找的效率。</p>
<h2 id="哈夫曼树与编码">哈夫曼树与编码</h2>
<p>当有树上的一系列查找工作，经过树上路径的总次数受数据比例和树的结构影响，如何在知道结点访问比例的情况下，优化树的结构？</p>
<img src="/2025-03-12-09-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/huffman_base.svg" class="" title="编码的改进">
<p>哈夫曼树是一种根据字符出现频率构建的二叉树，出现频率高的字符编码短（靠近树根），频率低的编码长（远离树根），通过这种最短前缀编码方式实现数据的高效压缩。</p>
<p>初始化：每个结点作为独立的树（只有根结点的树）</p>
<ol type="1">
<li>取出权重最小的两棵树</li>
<li>新建一个根节点，左右子树分别为这两棵树，根节点权重为两棵树权重和</li>
<li>把新建的树放回</li>
<li>重复1~3，直到成为一棵树</li>
</ol>
<p>tip
：如何找权重最小的两棵树？规模小就暴力找，规模大可以用<strong>堆</strong>或者<code>priority_queue</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Node ln = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>(); <span class="comment">// q是priority_queue</span></span><br><span class="line">    Node rn = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">    tr[tp].<span class="built_in">Init</span>();</span><br><span class="line">    tr[tp].data = ln.data + rn.data;</span><br><span class="line">    tr[tp].address = tp;</span><br><span class="line">    tr[tp].l = ln.address;</span><br><span class="line">    tr[tp].r = rn.address;</span><br><span class="line">    tr[ln.address].parent = tr[rn.address].parent = tp;</span><br><span class="line">    q.<span class="built_in">push</span>(tr[tp ++]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在远程通讯中，要将待传字符转换成二进制的字符串，怎样编码才能使它们组成的报文在网络中传得最快？</p>
<p>例：对<code>ABACCDA</code>编码，等长编码假设如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A    00</span><br><span class="line">B    01</span><br><span class="line">C    10</span><br><span class="line">D    11</span><br></pre></td></tr></table></figure>
<p>编码结果是<code>000110010101100</code></p>
<p>如果不等长编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A    0</span><br><span class="line">B    00</span><br><span class="line">C    1</span><br><span class="line">D    01</span><br></pre></td></tr></table></figure>
<p>就可以是 <code>000011010</code></p>
<p>但是这样有问题，遇到<code>00</code>的时候，是一个<code>B</code>还是两个<code>A</code>呢？所以在设计不等长的编码时，需要让<strong>任一字符的编码都不是另一个字符的编码的前缀</strong>，这就是”前缀编码”，利用二叉树设计的哈夫曼编码就是最优前缀码。</p>
<img src="/2025-03-12-09-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/huffman_best_prefix.svg" class="" title="哈夫曼编码基本原理">
<p>编解码方式参考：</p>
<ol type="1">
<li>以字符出现频率为权值，构建赫夫曼树</li>
<li>编码：从字符对应的叶结点出发走到根结点，结点需保存parent信息
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Encoding</span><span class="params">(<span class="type">char</span> st[], <span class="type">char</span> res[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> resLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">strlen</span>(st) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="comment">// iLetter 为要编码的字符对应的结点编号</span></span><br><span class="line">        <span class="type">int</span> iLetter = <span class="built_in">GetCharNode</span>(st[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = iLetter; tr[j].parent != <span class="number">-1</span>; j = tr[j].parent)</span><br><span class="line">        res[resLen ++] = (j == tr[tr[j].parent].nex[<span class="number">1</span>]) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从叶结点“上”去得到的编码是逆序的</span></span><br><span class="line">    <span class="comment">// 所以反向扫明文，得到结果再整体翻转一下</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(res, res + resLen);</span><br><span class="line">    res[resLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> resLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>解码：从根节点出发通过编码找到叶子结点 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Decoding</span><span class="params">(<span class="type">char</span> code[], <span class="type">char</span> res[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> resLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = tp - <span class="number">1</span>; code[i]; i ++) &#123;</span><br><span class="line">        <span class="comment">// nex[0] 表示 left，nex[1] 表示 right</span></span><br><span class="line">        <span class="keyword">if</span>(tr[j].nex[code[i] - <span class="string">&#x27;0&#x27;</span>] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        j = tr[j].nex[code[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(tr[j].nex[<span class="number">0</span>] == <span class="number">-1</span> &amp;&amp; tr[j].nex[<span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 左右指针都空（-1），到了叶节点</span></span><br><span class="line">            res[resLen ++] = val[tr[j].ith];</span><br><span class="line">            j = tp - <span class="number">1</span>; <span class="comment">// 回到根节点解码紧贴着的下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>10.哈希与字典树</title>
    <url>/2025-03-12-10-%E5%93%88%E5%B8%8C%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h1 id="哈希与字典树">哈希与字典树</h1>
<p>哈希（Hash）也叫散列，记录存储位置与关键字之间存在对应关系 <span
class="math inline">\(Loc(i)=H(key_{i})\)</span>，从而在查找数据时可以接近
<span class="math inline">\(O(1)\)</span>
的效率直接找到位置，而不需要顺序摸排或二分查找。</p>
<span id="more"></span>
<img src="/2025-03-12-10-%E5%93%88%E5%B8%8C%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91/hash_base.gif" class="" title="哈希基本原理">
<p>哈希函数自由度很高，能完成数据范围到哈希表范围的映射就可以，映射之后有概率产生冲突，通过一定手段解决冲突即可。</p>
<p>工程应用中，MD4、SHA-1、SHA-256、SHA-512 等都是哈希算法。</p>
<h3 id="链表法处理哈希冲突">链表法处理哈希冲突</h3>
<p>哈希表每个位置对应一条链表，所有散列值相同的元素都放到相同位置对应的链表中</p>
<img src="/2025-03-12-10-%E5%93%88%E5%B8%8C%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91/hash_link.gif" class="" title="哈希基本原理">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; hl[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ith = <span class="number">0</span>, hsNum = x % maxn;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator jt;</span><br><span class="line">    <span class="keyword">for</span>(jt = hl[hsNum].<span class="built_in">begin</span>(); jt != hl[hsNum].<span class="built_in">end</span>(); jt ++, ith ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*jt == x) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jt == hl[hsNum].<span class="built_in">end</span>() ? (hl[hsNum].<span class="built_in">push_front</span>(x), <span class="number">-1</span>) : ith + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stl-的-map-与-unorderd_map">STL 的 map 与
<code>unorderd_map</code></h3>
<p>C++ 的 STL 利用红黑树封装了 <span
class="math inline">\(O(logn)\)</span> 的 <code>map</code>
映射，以及一套哈希方案封装的接近<span
class="math inline">\(O(1)\)</span>的 <code>unordered_map</code>
映射，用起来很方便。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&quot;bob&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">mp[<span class="string">&quot;alice&quot;</span>] = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>不同版本的<code>C++</code>，<code>unordered_map</code>内部实现不尽相同，一些题目可能会专门Hack
<code>unordered_map</code> 导致其退化不再是 <span
class="math inline">\(O(1)\)</span>，所以比赛中如果理论复杂度用<code>map</code>没问题的话，还是推荐用<code>map</code>。</p>
<h2 id="字典树">字典树</h2>
<p>字典树是针对“串”类数据结构的哈希方案，比如对小写英文字符串做哈希，可以构建一个“26叉树”，将任意单词从左到右在树上进行分支查找，完成匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">int</span> nex[<span class="number">26</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Node trie[maxn];</span><br><span class="line"><span class="type">int</span> tp;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> now, <span class="type">char</span> *b)</span> </span>&#123;</span><br><span class="line">    trie[now].cnt ++;</span><br><span class="line">    <span class="keyword">if</span>(!*b) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!trie[now].nex[*b - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">    trie[now].nex[*b - <span class="string">&#x27;a&#x27;</span>] = tp ++;</span><br><span class="line">    <span class="built_in">Insert</span>(trie[now].nex[*b - <span class="string">&#x27;a&#x27;</span>], b + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search</span><span class="params">(<span class="type">int</span> now, <span class="type">char</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 统计以输入字符串为前缀的单次个数</span></span><br><span class="line">    <span class="comment">// 对于其他任务（比如统计多少个单次是输入字符串的前缀）</span></span><br><span class="line">    <span class="comment">// 改变cnt的意义并维护对应值</span></span><br><span class="line">    <span class="type">int</span> nex = trie[now].nex[*b - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!*b) <span class="keyword">return</span> trie[now].cnt;</span><br><span class="line">    <span class="keyword">if</span>(!nex) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Search</span>(nex, b + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思考题">思考题</h3>
<ol type="1">
<li>给n个单词，和1个长单词，求有多少个单词是这个长单词的前缀 —— 用 n
个单词建字典树，节点统计单词个数，长单词去匹配，路径上个数求和</li>
<li>给n个单词，和1个短单词，求这个短单词是多少个单词的前缀 —— 用 n
个单词建字典树，节点统计单词个数，短单词匹配成功的节点个数为答案</li>
<li>给两种语言单词对照表，输入任意单词，输出对照另一个语言的单词</li>
</ol>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>11.图结构与基本搜索</title>
    <url>/2025-03-12-11-%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="图结构与基本搜索">图结构与基本搜索</h1>
<p>本章介绍图的基本概念、存储方式以及两种基本图搜索算法——深度优先搜索（DFS）和广度优先搜索（BFS），涵盖图的定义、分类、存储结构及其在代码中的实现，并提供DFS和BFS的典型模板代码。</p>
<span id="more"></span>
<h2 id="图">图</h2>
<p>由顶点（节点）和边组成的一种非线性数据结构，用于表示对象之间的关系，顶点代表对象，边代表对象之间的连接或关系。</p>
<p>有向图与无向图</p>
<img src="/2025-03-12-11-%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/graph_dire.svg" class="" title="有向图与无向图">
<p>图的稀疏与稠密</p>
<img src="/2025-03-12-11-%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/graph_sparse.svg" class="" title="图的稀疏与稠密">
<p>概念大全：</p>
<ul>
<li>图：由顶点（V）与连接顶点的边（E）构成</li>
<li>无向图：每条边没有方向的定义</li>
<li>有向图：每条边有方向，例如表达路的话，一条边就表达一条单向车道</li>
<li>完全图：任意两个顶点之间都有边（对于有向图则两个方向的边都有）</li>
<li>稀疏图：边较少的图</li>
<li>稠密图：边较多的图</li>
<li>顶点的度：与该点关联的边的个数，如果是有向图则分“出度”和“入度”</li>
<li>路径：连续的边构成的顶点序列</li>
<li>路径长度：路径的边长度之和（如果没长度可以是边数量之和）</li>
<li>回路（环）：第一个顶点和最后一个顶点相同的路径</li>
<li>简单路径：除起点和终点外，其余顶点皆不相同</li>
<li>简单回路：起点终点相同，其他顶点皆不相同</li>
<li>连通图：图中任意两个顶点之间都能找到一个路径</li>
<li>子图：如果图B的顶点和边都是图A的顶点和边的子集，则B是A的子图</li>
<li>连通分量（强连通分量）：图B是图A的子图且图B是连通图（即A的连通子图），A中任意不在B中的顶点加入B后，B不再连通，这样的B是A的连通分量</li>
<li>极小连通子图：图B是图A的连通子图，如果B任意删除一条边后都不再连通，则B是A的极小连通子图</li>
<li>生成树：包含图 G 的所有顶点的极小连通子图，是图G的生成树</li>
<li>生成森林：非连通图的各个连通分量的生成树的集合</li>
<li>最小生成树：边有边权（或长度或其他量），边权之和最小的生成树</li>
</ul>
<h2 id="图的存储方式">图的存储方式</h2>
<p>在代码中存这个图：</p>
<img src="/2025-03-12-11-%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/graph_save_graph.svg" class="" title="存储一个图">
<h3 id="顺序存储邻接矩阵">顺序存储（邻接矩阵）</h3>
<img src="/2025-03-12-11-%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/graph_save_mat.svg" class="" title="邻接矩阵存法">
<p>用一个二维数组存储点与点的关系</p>
<ul>
<li><code>n</code> 个顶点， <code>e</code> 条边</li>
<li>对于无边权的图，<code>g[i][j] == 1</code>表示顶点 <code>i</code>
与顶点 <code>j</code> 有边，否则无边</li>
<li>对于有边权的图，可以额外用 <code>w[i][j]</code> 表示边的权值</li>
<li>无向图则 <code>g[i][j] == g[j][i]</code></li>
<li>适合<strong style="color:red;">稠密图</strong></li>
</ul>
<h3
id="链式存储竞赛通常用链式前向星">链式存储，竞赛通常用链式前向星</h3>
<ul>
<li><code>n</code> 个顶点，<code>e</code>条边</li>
<li>每一个顶点， 都用一个链表表示与其相连的边</li>
<li>适合<strong style="color:red;">稀疏图</strong></li>
<li>对于无向图，则两个方向各建一条有向边</li>
</ul>
<blockquote>
<p>知识点：在面对一道图问题时，一定要先分析图的稠密程度，再决定用邻接矩阵还是链式前向星。
Tip：大多问题都可以用链式前向星，在一些显著稠密、卡常数的问题中，考虑用邻接矩阵，邻接矩阵代码也相对好写一些。</p>
</blockquote>
<p>链式前向星模板参考</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxN = <span class="number">1100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxM = <span class="number">110000</span>;</span><br><span class="line"><span class="type">int</span> first[maxN];    <span class="comment">// 每个顶点发出的边的边链表头结点，该数组可初始化为 -1 表示每个顶点都还没有边</span></span><br><span class="line"><span class="type">int</span> nex[maxM];      <span class="comment">// 同个顶点发出的边的边结点 next 域</span></span><br><span class="line"><span class="type">int</span> u[maxM];        <span class="comment">// 边的发出顶点</span></span><br><span class="line"><span class="type">int</span> v[maxM];        <span class="comment">// 边的收入顶点</span></span><br><span class="line"><span class="type">int</span> w[maxM];        <span class="comment">// 边的权值</span></span><br><span class="line"><span class="type">int</span> tp;             <span class="comment">// 全局“内存分配”“指针”，就是模拟分配内存时，tp从0开始逐个增加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如 first[1]，表示顶点 V1 发出的第一条边的“指针”，这里就是数组编号</span></span><br><span class="line"><span class="comment">// nex[first[1]] 表示顶点 V1 发出的边的链表的第二个结点编号</span></span><br><span class="line"><span class="comment">// nex[nex[first[1]]] 表示顶点 V1 发出的边的链表的第三个结点编号 ...</span></span><br><span class="line"><span class="comment">// u[first[1]] 顶点 V1</span></span><br><span class="line"><span class="comment">// v[first[1]] 顶点 V1 发出的第一条边的另一端的顶点编号，比如 v[first[1]] == 3 就表示 V1 连着 V3</span></span><br><span class="line"><span class="comment">// w[first[1]] 顶点 V1 发出的第一条边的权值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 建图：表示顶点 s 向顶点 e 发出了一条权重为 weight 的有向边</span></span><br><span class="line">    <span class="comment">// 程序开始时 tp 初始为 0</span></span><br><span class="line">    nex[tp] = first[s]; <span class="comment">// 类似链表头插法</span></span><br><span class="line">    first[s] = tp;</span><br><span class="line">    u[tp] = s;</span><br><span class="line">    v[tp] = e;</span><br><span class="line">    w[tp] = weight;</span><br><span class="line">    tp ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DbEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果表示无向图，那简单，两个方向都建一条有向边就好</span></span><br><span class="line">    <span class="built_in">AddEdge</span>(s, e, weight);</span><br><span class="line">    <span class="built_in">AddEdge</span>(e, s, weight);</span><br><span class="line">    <span class="comment">// 结合 tp 的属性，你会发现，可以很容易找到两个顶点之间成对的双向边</span></span><br><span class="line">    <span class="comment">// 比如 i 是 s 发向 e 的边的编号，那么 i^1 （异或操作） 就是 e 发向 s 的边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[maxN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以深度优先搜索为例遍历全图，感受前向星的使用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = first[now]; i != <span class="number">-1</span>; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 类似链表访问过程，i = first[now] 从头结点获得第一条边的指针</span></span><br><span class="line">        <span class="comment">// i = nex[i] 即链表指针域往后遍历</span></span><br><span class="line">        <span class="comment">// i != -1 即判断是否到链表末尾</span></span><br><span class="line">        <span class="comment">// u[i]、v[i]、w[i] 都是链表结点的数据域，当然你可以把 nex、u、v、w 封装在 struct 里</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[v[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[v[i]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="棋盘类图问题">棋盘类图问题</h3>
<p>迷宫、下棋等问题，节点即格点或格子，与其相关的是上下左右四个方向，或者加上斜向共8个方向，用邻接矩阵或链式前向星建图就太麻烦了，可以直接用<code>xy</code>坐标来表达节点，增减<code>xy</code>来找相邻节点。</p>
<img src="/2025-03-12-11-%E5%9B%BE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%90%9C%E7%B4%A2/graph_board.png" class="" title="棋盘类问题">
<h2 id="基本的搜索">基本的搜索</h2>
<h3 id="深度优先搜索deep-first-search-dfs">深度优先搜索（Deep First
Search, DFS）</h3>
<p>深度优先搜索，用栈（递归的形式）</p>
<p>一条路走到底，往回一步，再一条路走到底，往回一步...一般用于求全部解、求一些很“深”的解</p>
<ol type="1">
<li>访问起始点v;</li>
<li>若v的第1个邻接点没访问过，深度遍历此邻接点；</li>
<li>若当前邻接点已访问过，再找v的第2个邻接点重新遍历；</li>
<li>如果所有邻接点都已访问，则返回上一个访问的顶点。</li>
</ol>
<p>在网格上DFS典型模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> graph[maxn][maxn];</span><br><span class="line"><span class="type">bool</span> visited[maxn][maxn];</span><br><span class="line"><span class="type">int</span> endX, endY;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == endX &amp;&amp; y == endY) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nextX = x + dx[i], nextY = y + dy[i];</span><br><span class="line">        <span class="comment">// 把 graph[0][各列] 和 graph[各行][0] 设为不能走的哨兵，让实际数据从 1 开始，就不用额外判断坐标范围了</span></span><br><span class="line">        <span class="keyword">if</span> (graph[nextX][nextY] &amp;&amp; !visited[nextX][nextY]) &#123;</span><br><span class="line">            <span class="comment">// 这里 graph[i][j] 为 1 表示能走，为 0 表示不能走</span></span><br><span class="line">            visited[nextX][nextY] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">DFS</span>(nextX, nextY)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在图上DFS典型模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn;</span><br><span class="line"><span class="type">int</span> g[maxn][maxn];  <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// now: 当前顶点编号</span></span><br><span class="line">    <span class="comment">// n: 顶点个数</span></span><br><span class="line">    <span class="keyword">if</span> (vis[now]) <span class="keyword">return</span>;</span><br><span class="line">    vis[now] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[now][i])  <span class="comment">// now 与 i 之间有边</span></span><br><span class="line">            <span class="built_in">DFS</span>(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索breath-first-search-bfs">广度优先搜索（Breath First
Search, BFS）</h3>
<p>广度优先搜索是一种分层的搜索过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况，因此，广度优先搜索不是一个递归的过程，其算法也不是递归的，就近访问，一圈圈外扩一般用于求最短的路、最近的解。</p>
<ol type="1">
<li>在访问了起始点v之后，将 v 的尚未访问的邻接点放入访问队列；</li>
<li>在队列中出队尚未访问的顶点，进行访问</li>
<li>直到所有顶点都被访问</li>
</ol>
<p>在网格上BFS典型模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x_, <span class="type">int</span> y_) &#123;</span><br><span class="line">        x = x_;</span><br><span class="line">        y = y_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> startX, <span class="type">int</span> startY)</span> </span>&#123;</span><br><span class="line">    std::queue&lt;Node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(startX, startY));</span><br><span class="line">    visited[startX][startY] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (now.x == endX &amp;&amp; now.y == endY) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nextX = now.x + dx[i], nextY = now.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (graph[nextX][nextY] &amp;&amp; !visited[nextX][nextY]) &#123;</span><br><span class="line">                visited[nextX][nextY] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(nextX, nextY));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在图上BFS典型模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn;</span><br><span class="line"><span class="type">int</span> g[maxn][maxn];  <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    vis[start] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[now][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>12.模拟与高精度</title>
    <url>/2025-03-18-12-%E6%A8%A1%E6%8B%9F%E4%B8%8E%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="模拟与高精度">模拟与高精度</h1>
<p>通过编程模拟生活中的活动、现象，是解决各种问题的基础。很多问题并不需要特定的算法去解决，往往有效利用各种数据类型，根据问题的背景建模为数据的表达，按部就班地操作，就可以得到答案。</p>
<p>超出 long long (<span class="math inline">\(2^64\)</span>)
范围的数字的加减乘除就是一类典型的模拟，称为高精度问题。</p>
<span id="more"></span>
<h2 id="基本的模拟">基本的模拟</h2>
<h3 id="例机器人的指令">例：机器人的指令</h3>
<p>数轴原点有一个机器人。该机器人将执行一系列指令，你的任务是预测所有指令执行完毕之后它的位置。</p>
<ul>
<li>LEFT：往左移动一个单位</li>
<li>RIGHT: 往右移动一个单位</li>
<li>SAME AS i: 和第i 条执行相同的动作。输入保证i
是一个正整数，且不超过之前执行指令数</li>
</ul>
<p>输入第一行为数据组数<span class="math inline">\(T (T \leq
100)\)</span>。每组数据第一行为整数<span class="math inline">\(n (1\leq
n\leq
100)\)</span>，即指令条数。以下每行一条指令。指令按照输入顺序编号为<code>1~n</code>。</p>
<p>对于每组数据，输出机器人的最终位置。每处理完一组数据，机器人应复位到数轴原点。</p>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">LEFT</span><br><span class="line">RIGHT</span><br><span class="line">SAME AS 2</span><br><span class="line">5</span><br><span class="line">LEFT</span><br><span class="line">SAME AS 1</span><br><span class="line">SAME AS 2</span><br><span class="line">SAME AS 1</span><br><span class="line">SAME AS 4</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">-5</span><br></pre></td></tr></table></figure>
<p>记录操作不一定要记单词，能区分它们就行，然后按照要求移动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> op[<span class="number">111</span>], buf[<span class="number">111</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n, x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        x = <span class="number">0</span>;  <span class="comment">// 多组测试数据，每次都要初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;L&#x27;</span>) op[i] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span>) op[i] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">                <span class="type">int</span> ith;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ith);</span><br><span class="line">                op[i] = op[ith - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            x += op[i] == <span class="string">&#x27;L&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度">高精度</h2>
<h3 id="大整数加法">大整数加法</h3>
<p>模拟小学学习的竖式，两个数组表示两个加数，另一个数组表示相加之和，数组每一项代表一位，下标<code>0</code>对应个位，<code>1</code>对应十位……</p>
<p>通常以字符串形式输入，然后处理为数字。</p>
<blockquote>
<p>知识点：字符的ASCII码（char存储）本身也是数字，只不过char是8位二进制，只能表示<code>-128~127</code>，只要在此范围内，把它当数字去计算是可以的。但要注意，<code>'1'</code>
的编码是<code>49</code>，要想让字符<code>'1'</code>成为数字<code>'1'</code>，可以由<code>'1' - '0'</code>
计算偏移量。</p>
</blockquote>
<p>以下代码仅供参考，具体实现可以有不同风格，选择自己易理解易记忆的方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">511</span>], b[<span class="number">511</span>], c[<span class="number">511</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a, b);</span><br><span class="line">    <span class="type">int</span> alen = <span class="built_in">strlen</span>(a), blen = <span class="built_in">strlen</span>(b), clen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 读入的时候 [0] 存的高位，翻转过来，让[0]存个位，方便a和b对齐</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(a, a + alen);</span><br><span class="line">    std::<span class="built_in">reverse</span>(b, b + blen);</span><br><span class="line">    <span class="keyword">for</span>(clen = <span class="number">0</span>; clen &lt; alen || clen &lt; blen; clen ++) &#123;</span><br><span class="line">        <span class="comment">// 字符ASCII码处理为数字</span></span><br><span class="line">        c[clen] = (clen &lt; alen ? a[clen] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>) + (clen &lt; blen ? b[clen] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(clen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            c[clen] += c[clen - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">            c[clen - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c[clen - <span class="number">1</span>] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        c[clen - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">        c[clen ++] ++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = clen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[i]); <span class="comment">// 这里c存的是“数字”`0,1,2`，而不是字符`&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;`，所以用%d输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大整数乘法">大整数乘法</h3>
<p>比加法稍复杂一点，仍然是小学竖式的模拟。可以简化处理的是，可以把进位放在各位相乘之后再统一处理，每个位就只需要处理一次进位了。</p>
<p>以下代码仅供参考，具体实现可以有不同风格，选择自己易理解易记忆的方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">2111</span>], b[<span class="number">2111</span>];</span><br><span class="line"><span class="comment">// 进位累加过程中可能 char 的128存不下，存结果用int</span></span><br><span class="line"><span class="comment">// 两数相乘结果的位数不小于两数位数之和，数组开大一倍</span></span><br><span class="line"><span class="type">int</span> c[<span class="number">4111</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a, b);</span><br><span class="line">    <span class="type">int</span> alen = <span class="built_in">strlen</span>(a), blen = <span class="built_in">strlen</span>(b), clen = <span class="number">0</span>;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a, a + alen);</span><br><span class="line">    std::<span class="built_in">reverse</span>(b, b + blen);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));    <span class="comment">// 初始化 c 数组，确保全为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; alen; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; blen; j ++) &#123;</span><br><span class="line">            <span class="comment">// 比如 80 * 900，其 8（下标1） * 9（下标2） = 72 应该落在 72000（下标3）上</span></span><br><span class="line">            <span class="comment">// 进位可结束之后再统一处理</span></span><br><span class="line">            c[i + j] += (a[i] - <span class="string">&#x27;0&#x27;</span>) * (b[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; clen &lt; alen + blen + <span class="number">5</span>; clen ++) &#123;</span><br><span class="line">        c[clen + <span class="number">1</span>] += c[clen] / <span class="number">10</span>;</span><br><span class="line">        c[clen] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉高位前导 0，且即使c是0也至少有 1 位数</span></span><br><span class="line">    <span class="keyword">for</span>(; clen &gt; <span class="number">1</span> &amp;&amp; c[clen - <span class="number">1</span>] == <span class="number">0</span>; clen --);    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = clen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>13.暴力枚举</title>
    <url>/2025-03-19-13-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="暴力枚举">暴力枚举</h1>
<blockquote>
<p>只要复杂度没问题，暴力又如何？</p>
</blockquote>
<p>以合理的方式，不重复、不遗漏地枚举一个问题所有可能的答案，找到正确的或最优的那个。</p>
<span id="more"></span>
<h2 id="基本的枚举">基本的枚举</h2>
<p>暴力需要艺术，不是盲目地暴力，而要通过观察分析问题的特点，有选择地枚举。</p>
<h3 id="例除法">例：除法</h3>
<p><code>abcdefghij</code>是<code>0~9</code>的一个排列，给出 <span
class="math inline">\(2\leq n \leq 79\)</span>，输出所有 <span
class="math inline">\(abcde / fghij = n\)</span> 的情况</p>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">62</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">79546 / 01283 = 62</span><br><span class="line">94736 / 01528 = 62</span><br></pre></td></tr></table></figure>
<p>直观的暴力是枚举<code>0~9</code>的所有排列，这是 <span
class="math inline">\(10!=362880\)</span>
种情况，或许能通过此题，但数据范围再扩大呢（比如用16进制，甚至更高）？而且枚举排列的代码量也不少。</p>
<p>如果只枚举
<code>fghij</code>，复杂度就会极大降低，甚至不用枚举排列，只需要枚举五位数，判断各位是否不同，然后用
<span class="math inline">\(n * fghij\)</span> 得到 <span
class="math inline">\(abcde\)</span>，再判断一次各位是否不同就可以了。</p>
<h3 id="例统计方形">例：统计方形</h3>
<p>给出 <span class="math inline">\(n\leq 5000, m\leq 5000\)</span>，求
<span class="math inline">\(n \times m\)</span>
的方格棋盘正方形、不含正方形的长方形 分别有多少个。</p>
<p>直观的暴力是枚举所有左上角和右下角，但这过于暴力了， <span
class="math inline">\(O(n^{2}m^{2})\)</span> 的复杂度也很恐怖。</p>
<p>而如果想用纯数学方法算出来也可以，就比较烧脑。</p>
<p>可以充分利用计算机的优势，在可接受复杂度内枚举，并一定程度结合计算，达到思维量和程序复杂性的平衡。</p>
<p>于是可以这样，枚举右下角，计算以枚举的格子为右下角的正方形个数，和含正方形在内的矩形总个数（这比只算矩形要容易些），进而再计算不含正方形的矩形个数。</p>
<p>估算一下数量可知，总数应该超过 <code>int</code> 了，得用
<code>long long</code> 统计</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sq = <span class="number">0</span>, all = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            sq += std::<span class="built_in">min</span>(i, j) + <span class="number">1</span>;   <span class="comment">// 以(i,j) 为右下角的正方形个数</span></span><br><span class="line">            all += (i + <span class="number">1</span>) * (j + <span class="number">1</span>);   <span class="comment">// 以(i,j) 为右下角的含正方形矩形个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, sq, all - sq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本的回溯">基本的回溯</h2>
<p>回溯的本质是搜索，只不过不是在直观的图上搜索，而是在答案所在的空间中，以某种模式去搜索，比如一堆数字的全排列，一堆物件的各种组合（子集）等等。</p>
<p>不重复不遗漏的搜索过程，构成一棵搜索树，所以某种意义上说，回溯是树上的搜索，通常以深度优先搜索形式实现。</p>
<h2 id="枚举排列">枚举排列</h2>
<p>枚举排列就是在 <span class="math inline">\(n\)</span> 个位置放 <span
class="math inline">\(n\)</span> 个对象，变换他们的顺序，把 <span
class="math inline">\(n!\)</span> 种顺序都枚举出来。</p>
<p>定义排列的字典序：第一个不相同的较小元素所在的排列字典序更小，例如1,2,3的字典序小于1,3,2，按字典序输出排列</p>
<p>思路：尝试第一个数的所有可能，然后第二个……一棵搜索树：</p>
<img src="/2025-03-19-13-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/permutation_tree.svg" class="" title="排列搜索树">
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;     <span class="comment">// cur 指 &quot;current&quot;, 当前在确定第 cur 个位置是谁</span></span><br><span class="line">    <span class="keyword">if</span>(cur == n) &#123;                              <span class="comment">// 递归终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)             <span class="comment">// 输出一个排列</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span> + !i, record[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;                                 <span class="comment">// 注意return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;               <span class="comment">// 枚举每个元素</span></span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;                    <span class="comment">// 已放元素排除</span></span><br><span class="line">        vis[i] = <span class="literal">true</span>; record[cur] = a[i];      <span class="comment">// 标记已放本次排列第cur个为a[i]</span></span><br><span class="line">        <span class="built_in">DFS</span>(cur + <span class="number">1</span>);                           <span class="comment">// 递归放第cur+1个</span></span><br><span class="line">        vis[i] = <span class="literal">false</span>;                         <span class="comment">// 回溯取消标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例可重排列">例：可重排列</h3>
<p>如果有重复元素怎么办：<span
class="math inline">\({2,1,1,4}\)</span></p>
<p>按字典序生成排列为（先从左到右、后从上到下）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 2 4；1 1 4 2；1 2 1 4；1 2 4 1；1 4 1 2；1 4 2 1</span><br><span class="line">2 1 1 4；2 1 4 1；2 4 1 1；4 1 1 2；4 1 2 1；4 2 1 1</span><br></pre></td></tr></table></figure></p>
<p>思路：数据排序后处理重复，统计每种数的数量<code>cnt</code>，用<code>cnt</code>“还剩下的可用个数”代替<code>vis</code>所表达的“是否放过”。</p>
<h2 id="枚举子集">枚举子集</h2>
<p>给定 <span class="math inline">\(n\)</span>
元素集合，按字典序输出所有子集</p>
<p>思路：子集即每个元素取与不取（是否算在递归终点时得到的子集里），可通过二进制方式构造</p>
<img src="/2025-03-19-13-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/subset_tree.svg" class="" title="子集搜索树">
<p>枚举排列中的<code>record</code>记录第<code>cur</code>个位置放哪个数，那么在枚举子集中，可以用<code>chose</code>记录第<code>cur</code>个元素取还是没取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="number">-1</span>) &#123;                             <span class="comment">// 递归终点,所有元素都已确定</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, flg = <span class="number">1</span>; i &lt; n; i ++)&#123;   <span class="comment">// 输出子集</span></span><br><span class="line">            <span class="keyword">if</span>(!chose[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span> + flg, a[i]); flg = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;                                 <span class="comment">// 注意return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由n-1~0逆序以便按字典序枚举子集</span></span><br><span class="line">    chose[cur] = <span class="literal">false</span>; <span class="built_in">DFS</span>(cur - <span class="number">1</span>);           <span class="comment">// 不取a[cur]后确定第cur-1个</span></span><br><span class="line">    chose[cur] = <span class="literal">true</span>; <span class="built_in">DFS</span>(cur - <span class="number">1</span>);            <span class="comment">// 取a[cur]后确定第cur-1个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指数增长很快，通常需要生成子集的问题不会太大，<code>int</code>的二进制位存得下
<code>chose</code>
所表达的信息，从而可以通过枚举连续的整数（二进制位）来枚举子集：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, flg = <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span> + flg, a[j]);</span><br><span class="line">            flg = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知识点：位运算，<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,<code>|</code>,<code>&amp;</code>,<code>^</code>
是几个针对整数型变量的二进制位进行操作的运算，<code>1&lt;&lt;m</code>指把<code>1</code>的二进制位向“左”移<code>m</code>位。<br />
<code>int</code>的<code>1</code> 的二进制位是
<code>0000000000000000000001</code>（<span
class="math inline">\(31\)</span>个<code>0</code>，<span
class="math inline">\(1\)</span>个<code>1</code>，共<span
class="math inline">\(32\)</span>位），左移<code>2</code>位的话，就变成<code>0000000000000000000100</code>，对应表达的数字是
<code>4</code>。<br />
<code>(i &gt;&gt; j) &amp; 1</code> 就是把 <code>i</code> 右移
<code>j</code> 位之后，再与 <code>0000000000000000000001</code>
每个二进制位分别做一下“与”操作，<code>(i &gt;&gt; j) &amp; 1</code>
就会过滤掉前<code>31</code>个位（无论<code>0</code>还是<code>1</code>，“与”一下<code>0</code>都会变成<code>0</code>），只看最低的位“与”<code>1</code>之后的结果，用来判断
<code>i</code>的第<code>j</code>个位是否是<code>j</code>。</p>
</blockquote>
<h3 id="例枚举r子集">例：枚举<span
class="math inline">\(r\)</span>子集</h3>
<p>枚举特定大小的子集，在枚举过程中只输出“取<span
class="math inline">\(r\)</span>”个的情况即可。</p>
<h2 id="基本回溯">基本回溯</h2>
<h3 id="例n皇后">例：n皇后</h3>
<p>规定棋子可以攻击同一行、同一列、同一斜线的棋子 求在 <span
class="math inline">\(n\times n\)</span> 的棋盘上放置 <span
class="math inline">\(n\)</span> 个棋子，互相攻击不到的方法</p>
<p><span class="math inline">\(4\)</span> 皇后示例：</p>
<img src="/2025-03-19-13-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/nqueen.svg" class="" title="n皇后示例">
<p>以<span class="math inline">\(8\)</span>皇后为例分析问题规模</p>
<ul>
<li>枚举每个格子放与不放？<span
class="math inline">\(2^{64}\)</span>太离谱</li>
<li><span class="math inline">\(64\)</span> 个格子取 <span
class="math inline">\(8\)</span> 个？<span
class="math inline">\(C_{64}^{8}\)</span>也很离谱</li>
<li>结合约束条件，可极大简化要枚举的内容：每行选 <span
class="math inline">\(1\)</span>
列，行行不重复，各行选的列编号拿出来放一起，就是<span
class="math inline">\(1\sim 8\)</span>的排列！</li>
</ul>
<p>进一步优化，对于每个格子，它属于：</p>
<ul>
<li><span class="math inline">\(n\)</span>列中的<span
class="math inline">\(1\)</span>列</li>
<li><span class="math inline">\(2n−1\)</span>个正斜线的<span
class="math inline">\(1\)</span>个</li>
<li><span class="math inline">\(2n−1\)</span>个反斜线的<span
class="math inline">\(1\)</span>个</li>
</ul>
<img src="/2025-03-19-13-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/nqueen_solve.svg" class="" title="n皇后示例">
<p>枚举排列时，可增加两组斜线占领标记，减少状态枚举。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">14</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="type">bool</span> rcdx[maxn], rcdlr[maxn &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], rcdrl[maxn &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n) ans[n] ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(rcdx[i] || rcdlr[i - cur + n - <span class="number">1</span>] || rcdrl[i + cur]) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        rcdx[i] = <span class="literal">true</span>;</span><br><span class="line">        rcdlr[i - cur + n - <span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">// 左上-右下 对角线标记</span></span><br><span class="line">        rcdrl[i + cur] = <span class="literal">true</span>;          <span class="comment">// 右上-坐下 对角线标记</span></span><br><span class="line">        <span class="built_in">DFS</span>(cur + <span class="number">1</span>);</span><br><span class="line">        rcdx[i] = <span class="literal">false</span>;</span><br><span class="line">        rcdlr[i - cur + n - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        rcdrl[i + cur] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">memset</span>(rcdx, <span class="number">0</span>, <span class="built_in">sizeof</span>(rcdx));</span><br><span class="line">    <span class="built_in">memset</span>(rcdlr, <span class="number">0</span>, <span class="built_in">sizeof</span>(rcdlr));</span><br><span class="line">    <span class="built_in">memset</span>(rcdrl, <span class="number">0</span>, <span class="built_in">sizeof</span>(rcdrl));</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[n] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例着色问题">例：着色问题</h3>
<p>给定<span class="math inline">\(n\)</span>个顶点的无向连通图 <span
class="math inline">\(G\)</span> 和 <span
class="math inline">\(m\)</span>
种不同颜色，每个顶点涂一种颜色，要求每条边的两个顶点颜色不同，求方案个数。</p>
<p>6个点3种颜色示例：</p>
<img src="/2025-03-19-13-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/color_example.svg" class="" title="6个点3种颜色示例">
<p>回顾枚举子集：每个点取与不取，取值是<code>0</code>或<code>1</code>，把这个思路扩展一下，每个点颜色有<code>0</code>、<code>1</code>、<code>2</code>
三种选择，其实和枚举子集是同一套思路。</p>
<img src="/2025-03-19-13-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/color_tree.svg" class="" title="3种颜色搜索树">
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">111</span>;</span><br><span class="line"><span class="type">int</span> n, m, q, u, v, color[maxn], ans;</span><br><span class="line"><span class="type">bool</span> g[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Judge</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> ci)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断cur是否能涂ci色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        <span class="keyword">if</span>(color[j] == ci &amp;&amp; g[cur][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n + <span class="number">1</span>) &#123;</span><br><span class="line">        ans ++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">Judge</span>(cur, i)) <span class="keyword">continue</span>;</span><br><span class="line">        color[cur] = i; <span class="comment">// cur节点尝试i颜色</span></span><br><span class="line">        <span class="built_in">DFS</span>(cur + <span class="number">1</span>);</span><br><span class="line">        color[cur] = <span class="number">0</span>; <span class="comment">// 回溯，取消颜色标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="built_in">sizeof</span>(color));</span><br><span class="line">        <span class="keyword">while</span>(q --) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            g[u][v] = g[v][u] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        color[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// 对称问题对节点1只计算一种颜色即可</span></span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans * m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>14.基本递推</title>
    <url>/2025-03-26-14-%E5%9F%BA%E6%9C%AC%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<h1 id="基本递推">基本递推</h1>
<p>递推是编程中最常用的技能，规模较大的问题可以由规模较小的问题计算得到，从规模较小的问题开始，按一定的顺序推导更大问题的解的过程。</p>
<span id="more"></span>
<h3 id="例斐波那契数列">例：斐波那契数列</h3>
<p><span class="math inline">\(f_{1}=1, f_{2}=1,
f_{n}=f_{n-1}+f_{n-2}\)</span>.</p>
<p>求数列的第 <span class="math inline">\(n\)</span> 项.</p>
<p>当这类问题存在多次提问时，可以用一个数组把序列的表提前算好，俗称“打表”.</p>
<blockquote>
<p>知识点：有的问题（或函数，或数列）随着自变量的增大，增长非常快，这样稍大一些的时候，<code>long long</code>
都存不下。出题人为了考察这类问题，会要求输出答案对一个较大的质数取模的结果，这个结果正确，就认为答案正确。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列前 1000 项，每项都是对 10^9+7 取模的结果</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">1111</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">        f[i] = (f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 不断询问的第“n”项</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123; <span class="comment">// EOF是scanf读到输入文件末尾时的返回值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例传染">例：传染</h3>
<p>数量不限个健康动物，一个生病动物每轮会传染 <span
class="math inline">\(x\)</span> 个健康动物， 求 <span
class="math inline">\(n\)</span> 轮后染病动物总数。</p>
<p>输入 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(n\)</span></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">10 2</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">121</span><br></pre></td></tr></table></figure>
<p>每轮结束时，染病动物总数应当是传染的数量加上已染病的数量，形成递推关系。</p>
<p>如果涉及多次查询，就开数组大表，否则用一个变量递推就行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;          <span class="comment">// 最开始的一个，指数级增长要注意查看题目数据范围</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;n);            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        ans = ans * x + ans;    <span class="comment">// 传染的加上已有的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见注意点小结">常见注意点小结</h2>
<ul>
<li>注意递推问题的增长规模与数据范围，选择性使用
<code>long long</code></li>
<li>题目答案要求对特定数取模，要注意不仅仅是结果取模，要避免计算过程中超类型范围
<ul>
<li>递推式多项累加，要分析中间结果是否会超<code>long long</code>，如果会，则要随时取模：
<code>f[n] = ((f[n - 1] + f[n - 2]) % mod + f[n - 3]) % mod</code></li>
<li>递推式带有乘法，虽然取模数不超 <code>int</code> ，但乘法计算超：
用“1LL”去乘中间结果临时转 <code>long long</code>：
<code>f[n] = 1LL * f[n-1] * f[n - 2] % mod</code>;</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>15.复杂度理论与分治</title>
    <url>/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h1 id="复杂度理论与分治">复杂度理论与分治</h1>
<p>本章探讨了算法分析的核心概念，通过求解最大连续和问题展示了不同算法设计策略的效率差异，并引入了复杂性理论、分治法以及它们在优化算法时间复杂度上的应用。从简单的枚举方法到高效的动态规划与分治策略，逐步揭示了解决问题时算法选择的重要性及其对计算资源消耗的深远影响。</p>
<span id="more"></span>
<h2 id="感知复杂度">感知复杂度</h2>
<p>给一个数字序列，求解一段连续的数字最大的和</p>
<p>输入：序列长度<span class="math inline">\(n\)</span>，序列<span
class="math inline">\(\{A_1, A_2, \ldots, A_n\}\)</span>，<span
class="math inline">\(A_i\)</span> 为任意整数</p>
<p>输出：找到<span class="math inline">\(1 \leq i \leq j \leq
n\)</span>，使得<span class="math inline">\(A_i + A_{i+1} + \ldots +
A_{j-1} + A_j\)</span>和最大</p>
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C_%E9%A2%98%E7%9B%AE.svg" class="" title="最大连续和">
<p>方法1：枚举所有的连续序列，找和最大的序列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> best = A[<span class="number">1</span>];                        <span class="comment">// 初始化答案</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)            <span class="comment">// 枚举起点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j ++) &#123;      <span class="comment">// 枚举终点</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= j; k ++)    <span class="comment">// 序列求和</span></span><br><span class="line">            sum += A[k];</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; best) best = sum;      <span class="comment">// 更新答案</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对任意输入个数<span class="math inline">\(n\)</span>，加法（
<code>sum += A[k];</code> ）的执行次数<span
class="math inline">\(T(n)\)</span>是多少？</p>
<ul>
<li>第一层for循环 <span class="math inline">\(\sum_{i=1}^n
\ldots\)</span></li>
<li>第二层for循环<span class="math inline">\(\sum_{j=i}^n
\ldots\)</span></li>
<li>第三层for循环<span class="math inline">\(\sum_{k=i}^j 1 = j - i +
1\)</span></li>
</ul>
<p><span class="math inline">\(T(n) = \sum_{i=1}^n \sum_{j=i}^n (j - i +
1) = \frac{n(n+1)(n+2)}{6}\)</span></p>
<p>我们取个比较大的<span
class="math inline">\(n=10,000\)</span>，此时<span
class="math inline">\(T(n)=166,716,670,000\)</span>。</p>
<p>方法2：先计算前缀和，前<span
class="math inline">\(j\)</span>个数的和减去前<span
class="math inline">\(i-1\)</span>个数的和可以方便地得到<span
class="math inline">\(i~j\)</span>这一连续序列的和<span
class="math inline">\(A_i + A_{i+1} + \ldots + A_j\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pre[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) pre[i] = pre[i - <span class="number">1</span>] + A[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j ++)</span><br><span class="line">        best = <span class="built_in">max</span>(best, pre[j] - pre[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法<span class="math inline">\(T(n) = n + \sum_{i=1}^n (n - i + 1)
= n + \frac{n(n+1)}{2}\)</span></p>
<p><span class="math inline">\(n=10,000\)</span>时<span
class="math inline">\(T(n)=50,015,000\)</span></p>
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C_%E5%89%8D%E7%BC%80%E5%92%8C.svg" class="" title="前缀和">
<p>方法3：递归地划分问题为左右两半，看左半边的解（最大连续和）大，还是右半边的解大，还是从中间往左右延申的一段连续和大。</p>
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C_%E5%88%86%E6%B2%BB.svg" class="" title="分治">
<p>此方法<span class="math inline">\(T(n) = 2T(n/2) +
n\)</span>，中间往左右延申最坏情况就是走到头</p>
<p><span class="math inline">\(n=10,000\)</span>时<span
class="math inline">\(T(n) \approx n\log n \approx 130,000\)</span></p>
<p>方法4：考虑这样一个情况，当连续地累加时，只要和不为负，前面累加的值肯定对后面继续累加有贡献，反之若累加到某个位置为负，则可以抛弃前面的累加值。</p>
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C_DP.svg" class="" title="DP">
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C_DP_example.svg" class="" title="DP示例">
<p>此方法<span class="math inline">\(T(n) =
n\)</span>，只需要从前往后每个数考虑一次</p>
<p><span class="math inline">\(n=10,000\)</span>时<span
class="math inline">\(T(n)=10,000\)</span></p>
<p>算法不同，处理同一个问题的基础运算次数可能有非常大的差距</p>
<h2 id="复杂性理论">复杂性理论</h2>
<p>算法更关心随着<span class="math inline">\(n\)</span>无限增长，<span
class="math inline">\(T(n)\)</span>的增长速度——<strong style="color:red;">渐进效率</strong></p>
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/%E6%B8%90%E8%BF%9B%E6%95%88%E7%8E%87.svg" class="" title="渐进效率">
<p>通常称渐进效率的高低为“阶”的高低，阶更高的函数增长率更高。</p>
<p>表达渐进效率有 5 个符号：</p>
<ul>
<li>大写<span class="math inline">\(O\)</span>，<span
class="math inline">\(f(n) = O(g(n))\)</span>，表示<span
class="math inline">\(f(n)\)</span>的阶不大于<span
class="math inline">\(g(n)\)</span>的阶；</li>
<li>大写<span class="math inline">\(\Omega\)</span>，<span
class="math inline">\(f(n) = \Omega(g(n))\)</span>，表示<span
class="math inline">\(f(n)\)</span>的阶不小于<span
class="math inline">\(g(n)\)</span>的阶；</li>
<li>小写<span class="math inline">\(o\)</span>，<span
class="math inline">\(f(n) = o(g(n))\)</span>，表示<span
class="math inline">\(f(n)\)</span>的阶严格小于<span
class="math inline">\(g(n)\)</span>的阶；</li>
<li>小写<span class="math inline">\(\omega\)</span>，<span
class="math inline">\(f(n) = \omega(g(n))\)</span>，表示<span
class="math inline">\(f(n)\)</span>的阶严格大于<span
class="math inline">\(g(n)\)</span>的阶；</li>
<li>大写<span class="math inline">\(\Theta\)</span>，<span
class="math inline">\(f(n) = \Theta(g(n))\)</span>，表示<span
class="math inline">\(f(n)\)</span>的阶与<span
class="math inline">\(g(n)\)</span>的阶相同。</li>
</ul>
<p>最常用的是大<span
class="math inline">\(O\)</span>表示，注意<strong>不大于</strong>这个描述，即
<span class="math inline">\(n=O(n^2)\)</span>、<span
class="math inline">\(n^2+n=O(n^2)\)</span> 这类表述都是正确的，大 <span
class="math inline">\(O\)</span>
关心的是一个算法复杂度的“上界”，至于是不是严格等于这个上界就不那么重要了，这样更方便评估一个算法的效率是否“可用”。</p>
<p>算法复杂度<span
class="math inline">\(T(n)\)</span>是关于输入规模<span
class="math inline">\(n\)</span>的函数，如果这个函数包含多项，比如 <span
class="math inline">\(5^{n}+2n^{2}+3n\dots\)</span>，大<span
class="math inline">\(O\)</span>表示法只保留阶最高的项，且不关心常数系数，这个例子的大<span
class="math inline">\(O\)</span>表示应该简化为 <span
class="math inline">\(O(5^{n})\)</span></p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>算法启动后需要的额外空间。</p>
<p>通常先指定一个常数级别的基本单位，比如 <code>int</code>（4个字节）
大小的内存、长度为<code>10</code>的<code>char</code>等等，根据具体的算法指定一个合乎逻辑的基本单位，统计基本单位的使用数量，得到一个关于输入规模
<span class="math inline">\(n\)</span> 的函数。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<p>算法基本运算执行的次数，基本运算是一个或一组有限时间内结束的、算法中执行频率最高的运算，比如加法、乘法、比较、常数级别的矩阵乘法等等。</p>
<h2 id="分治">分治</h2>
<p>递归地调用自身解决紧密相关的若干子问题，步骤如下：</p>
<ol type="1">
<li>分解原问题为若干互不相交的子问题<br />
这些子问题是原问题规模较小的实例，与原问题属性相同</li>
<li>解决这些子问题，递归进行<br />
如果子问题规模足够小则直接求解</li>
<li>合并这些子问题的解为原问题的解<br />
递归的各子问题解决完后回到上一层进行合并</li>
</ol>
<p>以归并排序为例</p>
<ol type="1">
<li>分解：待排序的<span
class="math inline">\(n\)</span>个元素序列分解为两个<span
class="math inline">\(n/2\)</span>个元素的序列</li>
<li>解决：递归地对两个子序列执行归并排序，长度为1则直接返回</li>
<li>合并：“回升”阶段将两个已排序的子序列合并为一个已排序的结果</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r - <span class="number">1</span>) <span class="keyword">return</span>;     <span class="comment">// 【解决】最小规模</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(a, l, mid);      <span class="comment">// 【分解】并【解决】</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(a, mid, r);      <span class="comment">// 【分解】并【解决】</span></span><br><span class="line">    <span class="comment">// 【合并】阶段开始</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid, tp = l;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid &amp;&amp; j &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j] &lt; a[i]) tmp[tp ++] = a[j ++];</span><br><span class="line">        <span class="keyword">else</span> tmp[tp ++] = a[i ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid) tmp[tp ++] = a[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; r) tmp[tp ++] = a[j ++];</span><br><span class="line">    <span class="built_in">memcpy</span>(a + l, tmp + l, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (r - l));</span><br><span class="line">    <span class="comment">// 【合并】阶段结束，【解决】了当前子问题[l,r)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治的时间复杂度分析">分治的时间复杂度分析</h3>
<p>归并排序要解决 <span class="math inline">\(2\)</span> 个 <span
class="math inline">\(n/2\)</span> 规模的子问题，把 <span
class="math inline">\(2\)</span> 个子问题的结果合并为一个有序数组有
<span class="math inline">\(O(n)\)</span> 的代价，复杂度函数表示为</p>
<p><span class="math inline">\(T(n) = 2T( n/2 ) + O(n)\)</span></p>
<p>这种原始问题（规模为<span
class="math inline">\(n\)</span>）的复杂度<span
class="math inline">\(T(n)\)</span>由拆分的若干个（<span
class="math inline">\(a\)</span>个）、相同方法解决的子问题（<span
class="math inline">\(n\)</span>减小的某个规模）复杂度函数<span
class="math inline">\(T(n/b)\)</span>和合并子问题的复杂度<span
class="math inline">\(f(n)\)</span>组成的式子称为递归式，求得由 <span
class="math inline">\(n\)</span> 的公式直接表达 <span
class="math inline">\(T(n)\)</span>
的结果的过程称为解递归式，递归式的解就是这个分治算法的时间复杂度。典型形式为：</p>
<p>多个相同规模子问题：<span
class="math inline">\(T(n)=aT(n/b)+f(n)\)</span>，
多个不同规模子问题：<span
class="math inline">\(T(n)=T(n/b)+T(n/c)+\dots+f(n)\)</span></p>
<p>最直观的方法是通过<strong>递归树</strong>求解：</p>
<p>每个结点表示单一子问题合并工作的代价（<span
class="math inline">\(f(n)\)</span>），树中每层代价求和，所有层的代价求和</p>
<p>对于<span class="math inline">\(T(n) = 2T(n/2) + n\)</span>，</p>
<p>此处我们仍假设<span class="math inline">\(n\)</span>是2的幂</p>
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/%E9%80%92%E5%BD%92%E6%A0%91_%E6%9E%84%E9%80%A0.svg" class="" title="递归树构造">
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/%E9%80%92%E5%BD%92%E6%A0%91_%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6.svg" class="" title="用递归树计算复杂度">
<h3 id="例线性平均情况第k小">例：线性（平均情况）第k小</h3>
<p><span class="math inline">\(n\)</span>个未排序的数，选择其中第<span
class="math inline">\(k\)</span>小的数。<strong>线性</strong>算法指算法复杂度
<span class="math inline">\(T(n)\)</span> 是关于 <span
class="math inline">\(n\)</span> 的一次函数。</p>
<p>假设数据规模不允许基数排序等特殊排序方法，则快速排序、归并排序等方式需要
<span class="math inline">\(nlogn\)</span>，不满足线性。</p>
<p>设数组为<span
class="math inline">\(S\)</span>，以“快速排序”的思想进行划分</p>
<ol type="1">
<li>分解：选一个数<span
class="math inline">\(m^{*}\)</span>，按大小划分为<span
class="math inline">\(S_1\)</span>和<span
class="math inline">\(S_2\)</span>（<span
class="math inline">\(m^{*}\)</span>在两集合之间），即数组所有比 <span
class="math inline">\(m^{*}\)</span> 小的放它左边，比 <span
class="math inline">\(m^{*}\)</span> 大的放它右边。</li>
<li>解决：
<ul>
<li>若<span class="math inline">\(k \leq |S_1|\)</span>，则在<span
class="math inline">\(S_1\)</span>中找第<span
class="math inline">\(k\)</span>小</li>
<li>若<span class="math inline">\(k &gt; |S_1| + 1\)</span>，则在<span
class="math inline">\(S_2\)</span>中找第<span class="math inline">\(k -
|S_1|\)</span>小</li>
<li>若<span class="math inline">\(k = |S_1| + 1\)</span>，则第<span
class="math inline">\(k\)</span>小为<span
class="math inline">\(m^{*}\)</span></li>
</ul></li>
<li>合并：第<span class="math inline">\(k\)</span>小的数只会存在于<span
class="math inline">\(S_1\)</span>、<span
class="math inline">\(S_2\)</span>、<span
class="math inline">\(m^{*}\)</span>其中一个，在这一边递归找</li>
</ol>
<p>分析：平均情况下，子问题规模（左半边或右半边）<span
class="math inline">\(n/2\)</span>，因为只会在一边找，所以只需要解决
<span class="math inline">\(1\)</span>
个子问题，合并子问题的工作集中在划分这件事上，即“比 <span
class="math inline">\(m^{*}\)</span> 小的放它左边，比 <span
class="math inline">\(m^{*}\)</span> 大的放它右边”，这个操作是 <span
class="math inline">\(O(n)\)</span> 的，所以递归式为：</p>
<p><span class="math inline">\(T(n)=T(n/2)+n\)</span></p>
<p>解递归式得 <span class="math inline">\(T(n)=O(n)\)</span>
，在平均情况下是线性的。</p>
<p>为什么要说“平均情况”呢？因为选<span
class="math inline">\(m^{*}\)</span>划分的时候，有可能大多数都分到了一侧，这种不均衡会导致<span
class="math inline">\(T(n)\)</span>不再是线性的，但选择<span
class="math inline">\(m^{*}\)</span>的随机性很高，可以认为较大概率不会很偏，或从统计角度讲，多次执行的平均运算量是线性的。</p>
<p>其实这个问题有一个理论上更强大的解法，在<strong>最坏情况下</strong>也是<span
class="math inline">\(O(n)\)</span>的，可以在熟练掌握分治后进一步了解。</p>
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e8</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetK</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right - <span class="number">1</span>) <span class="keyword">return</span> a[left];</span><br><span class="line">    <span class="type">int</span> low = left, high = right - <span class="number">1</span>, center = a[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt;= center) high --;</span><br><span class="line">        a[low] = a[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= center) low ++;</span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = center;</span><br><span class="line">    <span class="keyword">if</span>(low - left &gt;= k) <span class="keyword">return</span> <span class="built_in">GetK</span>(left, low, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(low - left + <span class="number">1</span> == k) <span class="keyword">return</span> a[low];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">GetK</span>(low + <span class="number">1</span>, right, k - (low - left) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">0</span>] = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">            a[i] = <span class="number">1LL</span> * a[i - <span class="number">1</span>] * m % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">GetK</span>(<span class="number">0</span>, n, k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例平面最近点对">例：平面最近点对</h3>
<p>平面有<span class="math inline">\(n\)</span>个点，位置以<span
class="math inline">\((x,
y)\)</span>坐标表示，求最近的两个点及其距离。</p>
<p>设两个子问题最优解距离为<span class="math inline">\(d\)</span></p>
<p>每个小矩形内至多1个点</p>
<ul>
<li>考虑小矩形内两点最远距离（即对角线<span
class="math inline">\(r\)</span>）</li>
<li><span
class="math inline">\(r=\sqrt{(d/2)^2+(2d/3)^2}=5d/6&lt;d\)</span>，</li>
<li>如有多个点则与子问题最优解矛盾</li>
</ul>
<p>合并时，左侧任一点<span
class="math inline">\(P\)</span>在右侧至多考虑6个点</p>
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9.svg" class="" title="平面最近点对">
<p><span class="math inline">\(T(n)=2T(n/2)+O(n \log n)\)</span>，<span
class="math inline">\(T(n)=O(n \log^2 n)\)</span></p>
<p>虽然左边每个点考查右边 <span class="math inline">\(6\)</span>
个点应当是 <span class="math inline">\(O(n)\)</span>
的，但是要快速找到这 <span class="math inline">\(6\)</span>
个点，就不得不排序，所以合并子问题的工作量稍大了些。</p>
<p>但可以进一步优化，尝试一次排序，在分治的时候同时划分排序信息，避免每次都排序，自行尝试。</p>
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;     <span class="comment">// 定义一个极大值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, idx;              <span class="comment">// 坐标及序号</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point &amp;b)&#123;<span class="keyword">return</span> x &lt; b.x;&#125; <span class="comment">// 重载“&lt;”用于排序</span></span><br><span class="line">&#125;;</span><br><span class="line">Point p[maxn], csh[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sqr</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x * x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dis</span><span class="params">(Point &amp;a, Point &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Sqr</span>(a.x - b.x) + <span class="built_in">Sqr</span>(a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, ansa, ansb, ansdis;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Update</span><span class="params">(Point &amp;a, Point &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于答案要输出点对编号，而不仅仅是距离，用此函数更新答案</span></span><br><span class="line">    <span class="type">int</span> na = a.idx, nb = b.idx, dis = <span class="built_in">Dis</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span>(na &gt; nb) std::<span class="built_in">swap</span>(na, nb);</span><br><span class="line">    <span class="keyword">if</span>(ansdis == <span class="number">-1</span> || dis &lt; ansdis || dis == ansdis &amp;&amp; (na &lt; ansa || na == ansa &amp;&amp; nb &lt; ansb))</span><br><span class="line">        ansa = na, ansb = nb, ansdis = dis;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l, j = mid, k = l;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid &amp;&amp; j &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i].y &lt; p[j].y) csh[k ++] = p[i ++];</span><br><span class="line">        <span class="keyword">else</span> csh[k ++] = p[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid) csh[k ++] = p[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; r) csh[k ++] = p[j ++];</span><br><span class="line">    <span class="built_in">memcpy</span>(p + l, csh + l, <span class="built_in">sizeof</span>(Point) * (r - l));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JudgeNearby</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r, Point &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意到本算法采用了一个 trick：回溯的同时对 y 坐标做归并排序</span></span><br><span class="line">    <span class="comment">// 说明处理 [l, r) 区间时，[l, mid)和[mid, r)两个子问题已经 y 坐标有序</span></span><br><span class="line">    <span class="comment">// 提取两个子问题到中间点的 x 距离不超过子问题最优解的那些点 pl[] 和 pr[]</span></span><br><span class="line">    <span class="comment">// 只需左右“异步前进”，就能很容易定位左边 pl[] 每个点在右边上下距离不超过当前最优解的那些点</span></span><br><span class="line">    std::vector&lt;Point&gt; pl, pr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt; mid; i ++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Sqr</span>(c.x - p[i].x) &lt;= ansdis) pl.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = mid; i &lt; r; i ++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Sqr</span>(c.x - p[i].x) &lt;= ansdis) pr.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pl.<span class="built_in">size</span>(); i ++) &#123;    <span class="comment">// 对于左侧 pl[] 的每个点</span></span><br><span class="line">        <span class="comment">// 找到右侧 pr[] 的点中距离 pl[i] 小于目前最优解的序号下界 j</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; pr.<span class="built_in">size</span>() &amp;&amp; pl[i].y &gt; pr[j].y &amp;&amp; <span class="built_in">Sqr</span>(pl[i].y - pr[j].y) &gt; ansdis) j ++;</span><br><span class="line">        <span class="comment">// 从 j 开始枚举 pr[] 中的点，直到 y 坐标距离超过当前最优解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt; pr.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">Sqr</span>(pl[i].y - pr[k].y) &lt;= ansdis; k ++)</span><br><span class="line">            <span class="built_in">Update</span>(pl[i], pr[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MinDis</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span> inf;          <span class="comment">// 递归终点：子问题中没有点，返回极大距离</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Point midp = p[mid];</span><br><span class="line">    <span class="built_in">MinDis</span>(l, mid);                     <span class="comment">// 处理子问题最近点对</span></span><br><span class="line">    <span class="built_in">MinDis</span>(mid, r);                     <span class="comment">// 处理子问题最近点对</span></span><br><span class="line">    <span class="built_in">JudgeNearby</span>(l, mid, r, midp);       <span class="comment">// 两侧子问题取相近点求距离更新答案</span></span><br><span class="line">    <span class="built_in">Merge</span>(l, r, mid);                   <span class="comment">// 对 y 坐标进行归并排序的 Merge 操作</span></span><br><span class="line">    <span class="keyword">return</span> ansdis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        ansa = ansb = ansdis = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">            p[i].idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">sort</span>(p, p + n);    <span class="comment">// 按重载的“&lt;”，以x从小到大排序</span></span><br><span class="line">        <span class="built_in">MinDis</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ansa, ansb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治优化策略">分治优化策略</h2>
<p><strong>用一部分子问题的解表达另一部分子问题，减少计算子问题的个数</strong></p>
<h3 id="例快速幂">例：快速幂</h3>
<p><span class="math inline">\(a\)</span>为给定实数，<span
class="math inline">\(n\)</span>为自然数，求<span
class="math inline">\(a^n\)</span></p>
<ol type="1">
<li>分解：两份<span class="math inline">\(n/2\)</span>个<span
class="math inline">\(a\)</span>相乘</li>
<li>解决：对于奇数个的子问题，剩下的1个保留，乘在最终结果上</li>
<li>合并：两个子问题的解相乘</li>
</ol>
<p>但两个子问题结果相同，不必递归计算两遍</p>
<p><span class="math inline">\(T(n) = T(n/2) + \Theta(1)\)</span>，<span
class="math inline">\(T(n) = O(\log n)\)</span></p>
<p>奇数个数会有“零头”，这个零头令开一个变量“屯”起来。</p>
<p>问题比较简单，可以“自底向上”地合并，不需要递归了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PowMod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1LL</span> * a * a % mod)</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ret = <span class="number">1LL</span> * ret * a % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例快速幂计算斐波那契数列第-n-项">例：快速幂计算斐波那契数列第
<span class="math inline">\(n\)</span> 项</h3>
<p>设<span class="math inline">\(f_0=0\)</span>, <span
class="math inline">\(f_1=1\)</span>, <span
class="math inline">\(f_n=f_{n-1}+f_{n-2}\)</span>，放入2×2的矩阵，发现：</p>
<p><span class="math display">\[
\left(\begin{array}{cc}
f_{n+1} &amp; f_n \\
f_n &amp; f_{n-1}
\end{array}\right)
\times
\left(\begin{array}{cc}
1 &amp; 1 \\
1 &amp; 0
\end{array}\right)
=
\left(\begin{array}{cc}
f_{n+1} + f_n &amp; f_{n+1} \\
f_n + f_{n-1} &amp; f_n
\end{array}\right)
=
\left(\begin{array}{cc}
f_{n+2} &amp; f_{n+1} \\
f_{n+1} &amp; f_n
\end{array}\right)
\]</span></p>
<p>即矩阵每一项都变成了斐波那契数列对应位置的下一项。</p>
<p>从而，</p>
<p><span class="math display">\[
\left(\begin{array}{cc}
f_{n+1} &amp; f_n \\
f_n &amp; f_{n-1}
\end{array}\right)
=
\left(\begin{array}{cc}
1 &amp; 1 \\
1 &amp; 0
\end{array}\right)^n
\]</span></p>
<p>把矩阵类比实数，同样可以用快速幂方法求斐波那契数列第<span
class="math inline">\(n\)</span>项</p>
<p><span class="math inline">\(T(n) = O(\log n)\)</span></p>
<h3 id="例strassen矩阵乘法">例：Strassen矩阵乘法</h3>
<p>求<span class="math inline">\(n\)</span>阶矩阵<span
class="math inline">\(A\)</span>与<span
class="math inline">\(B\)</span>相乘的结果<span
class="math inline">\(AB\)</span>，其中假设<span
class="math inline">\(n=2^k\)</span></p>
<p>直接相乘方法：<span class="math inline">\(T(n)=O(n^3)\)</span></p>
<p>直接分治： 分解： <span class="math display">\[
\left[\begin{array}{cc}
A_{11} &amp; A_{12}\\
A_{21} &amp; A_{22}
\end{array}\right]
\left[\begin{array}{cc}
B_{11} &amp; B_{12}\\
B_{21} &amp; B_{22}
\end{array}\right]
=
\left[\begin{array}{cc}
C_{11} &amp; C_{12}\\
C_{21} &amp; C_{22}
\end{array}\right]
\]</span></p>
<p>求解：递归按矩阵乘规则求各子矩阵相乘结果</p>
<p>合并： <span
class="math display">\[C_{11}=A_{11}B_{11}+A_{12}B_{21}，C_{12}=A_{11}B_{12}+A_{12}B_{22}，\]</span>
<span
class="math display">\[C_{21}=A_{21}B_{11}+A_{22}B_{21}，C_{22}=A_{21}B_{12}+A_{22}B_{22}.\]</span></p>
<p><span
class="math inline">\(T(n)=8T(n/2)+O(n^2)，T(n)=O(n^3)\)</span>——这样不行</p>
<p>子问题定义：两个<span
class="math inline">\(n/2\)</span>规模的子矩阵相乘</p>
<p>优化合并：将<span
class="math inline">\(A_{11}B_{11}\)</span>等8个子问题通过相互表示优化为7个</p>
<p>设<span class="math inline">\(M_1 \sim M_7\)</span>为7个子问题</p>
<p><span class="math display">\[M_1 = A_{11}(B_{12} - B_{22})\]</span>
<span class="math display">\[M_2 = (A_{11} + A_{12})B_{22}\]</span>
<span class="math display">\[M_3 = (A_{21} + A_{22})B_{11}\]</span>
<span class="math display">\[M_4 = A_{22}(B_{21} - B_{11})\]</span>
<span class="math display">\[M_5 = (A_{11} + A_{22})(B_{11} +
B_{22})\]</span> <span class="math display">\[M_6 = (A_{12} -
A_{22})(B_{21} + B_{22})\]</span> <span class="math display">\[M_7 =
(A_{11} - A_{21})(B_{11} + B_{12})\]</span></p>
<p><span class="math display">\[C_{11} = M_5 + M_4 - M_2 + M_6,\]</span>
<span class="math display">\[C_{12} = M_1 + M_2,\]</span> <span
class="math display">\[C_{21} = M_3 + M_4,\]</span> <span
class="math display">\[C_{22} = M_5 + M_1 - M_3 - M_7.\]</span></p>
<p>即Strassen矩阵乘法用7个子问题完成了<span
class="math inline">\(C\)</span>矩阵的计算</p>
<p><span class="math display">\[T(n) = 7T(n/2) + O(n^2)，T(n) =
O(n^{\log 7}) \approx O(n^{2.81})\]</span></p>
<p>Coppersmith-Winograd算法为<span
class="math inline">\(O(n^{2.3727})\)</span></p>
<h3 id="例快速傅里叶变换">例：快速傅里叶变换</h3>
<p>使用FFT解决多项式乘法问题</p>
<p>设两个多项式<span class="math inline">\(F(x)\)</span>和<span
class="math inline">\(G(x)\)</span>如下：</p>
<p><span class="math display">\[
F(x) = a_0 + a_1x + a_2x^2 + \ldots
\]</span></p>
<p><span class="math display">\[
G(x) = b_0 + b_1x + b_2x^2 + \ldots
\]</span></p>
<p>它们的乘积可以表示为：</p>
<p><span class="math display">\[
F(x)G(x) = \sum_{i=0} \sum_{j=0}^{i} a_j b_{i-j} x^i
\]</span></p>
<p>应用到大整数乘法</p>
<p>如果把<span
class="math inline">\(x\)</span>换成10，就解决了大整数乘法问题。例如：</p>
<p><span class="math display">\[
314159 = 9 + 5 \times 10 + 1 \times 10^2 + 4 \times 10^3 + 1 \times 10^4
+ 3 \times 10^5
\]</span></p>
<p>对多项式 <span class="math inline">\(y = a_0 + a_1x + a_2x^2 + \ldots
+ a_{n-1}x^{n-1}\)</span> 做一个反向思考：</p>
<p>A同学有多项式，知道所有系数<span class="math inline">\(a_0, a_1,
\ldots, a_{n-1}\)</span>（都是已知常数）</p>
<p>B同学只知道多项式的形式，但不知道多项式具体是什么</p>
<p>A同学向多项式代入<span class="math inline">\(n\)</span>个不同的<span
class="math inline">\(x_i\)</span>，算出<span
class="math inline">\(n\)</span>个不同的<span
class="math inline">\(y_i\)</span></p>
<p>得到<span class="math inline">\((x_1, y_1), (x_2, y_2), \ldots, (x_n,
y_n)\)</span>，可以视作“点”</p>
<p>思考：B同学拿到<span class="math inline">\(n\)</span>“对”<span
class="math inline">\((x_i, y_i)\)</span>，他能否反向算出<span
class="math inline">\(a_0, a_1, \ldots, a_{n-1}\)</span>的值？</p>
<p><span class="math inline">\(a_0, a_1, \ldots a_{n-1}\)</span>与<span
class="math inline">\((x_1,y_1),(x_2,y_2),\ldots(x_n,y_n)\)</span>都唯一确定一个多项式</p>
<p>系数表示法： <span class="math inline">\(a_0,a_1,\ldots
a_{n-1}\)</span></p>
<p>点值表示法： <span
class="math inline">\((x_1,y_1),(x_2,y_2),\ldots(x_n,y_n)\)</span></p>
<p>系数表示法的多项式乘法是 <span class="math display">\[
F(x)G(x)=\sum_{i=0} \sum_{j=0}^i a_j b_{i-j} x^i
\]</span></p>
<p>思考：点值表示法的多项式乘法如何进行？</p>
<p>对每个特定 <span class="math inline">\(x\)</span>
，两个点表示法的多项式相乘，就是 <span class="math inline">\(y\)</span>
的值相乘。<span
class="math inline">\(F(x)G(x)\)</span>的点值表示法是<span
class="math inline">\((x_1, (y_{a1} * y_{b1})), (x_2, (y_{a2} *
y_{b2})), \ldots\)</span></p>
<p>如何利用点值表示法加速多项式乘法？直接代入<span
class="math inline">\(n\)</span>个不同的<span
class="math inline">\(x\)</span>并不能实质降低复杂度，仍然要<span
class="math inline">\(O(n^2)\)</span>得到所有点值：</p>
<ul>
<li><span class="math inline">\(x_1\)</span> 代入<span
class="math inline">\(F(x)=a_0+a_1 x+\ldots a_{n-1}
x^{n-1}\)</span>得到<span class="math inline">\(y_1\)</span>需要<span
class="math inline">\(O(n)\)</span>时间</li>
<li><span class="math inline">\(n\)</span>个不同的<span
class="math inline">\(x_i\)</span>分别代入，总共就要<span
class="math inline">\(O(n^2)\)</span>的时间</li>
</ul>
<p>设计特殊的<span class="math inline">\(n\)</span>个不同的<span
class="math inline">\(x\)</span>，加速每个点的计算。</p>
<p>复数域下，<span class="math inline">\(x^n=1\)</span>的<span
class="math inline">\(x\)</span>是<span
class="math inline">\(n\)</span>次单位根 <span
class="math display">\[x_k=e^{i 2k\pi/n}, \quad k=0,1,2,\ldots
n-1\]</span></p>
<p>用它作为<span class="math inline">\(n\)</span>个不同的<span
class="math inline">\(x\)</span>，相当于等分了圆周角 <span
class="math display">\[x_k=e^{i 2k\pi/n}=e^{i 2\pi/n
k}=\omega_n^k\]</span></p>
<p>欧拉公式<span class="math inline">\(e^{i2k\pi}=\cos 2k\pi + i \sin
2k\pi = 1\)</span></p>
<p><span class="math inline">\(e^{i2k\pi}\)</span>开<span
class="math inline">\(n\)</span>次根<span class="math inline">\(e^{i
2k\pi/n}\)</span>就是一个解</p>
<img src="/2025-03-27-15-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E6%B2%BB/FFT.svg" class="" title="FFT">
<p><span class="math inline">\(F(x) = F(\omega_n) = a_0 + a_1 \omega_n +
\ldots + a_{n-1} \omega_n^{n-1}\)</span></p>
<p>奇偶系数分开定义新多项式</p>
<p><span class="math display">\[A(\omega_n) = a_0 + a_2 \omega_n^1 + a_4
\omega_n^2 + \ldots + a_{n-2} \omega_n^{n/2-1}\]</span> <span
class="math display">\[B(\omega_n) = a_1 + a_3 \omega_n^1 + a_5
\omega_n^2 + \ldots + a_{n-1} \omega_n^{n/2-1}\]</span> <span
class="math display">\[F(\omega_n) = A(\omega_n^2) + \omega_n
B(\omega_n^2)\]</span></p>
<p><span class="math inline">\(F(\omega_n) = A(\omega_n^2) + \omega_n
B(\omega_n^2)\)</span>，分别代入<span
class="math inline">\(\omega_n^k\)</span>和<span
class="math inline">\(\omega_n^{k+n/2}\)</span></p>
<p><span class="math inline">\(F(\omega_n^k) = A(\omega_n^{2k}) +
\omega_n^k B(\omega_n^{2k})\)</span> <span class="math inline">\(=
A(\omega_{n/2}^k) + \omega_n^k B(\omega_{n/2}^k)\)</span></p>
<p><span class="math inline">\(F(\omega_n^{k+n/2}) = A(\omega_n^{2k+n})
+ \omega_n^{k+n/2} B(\omega_n^{2k+n})\)</span> <span
class="math inline">\(= A(\omega_{n/2}^k) - \omega_n^k
B(\omega_{n/2}^k)\)</span></p>
<p><span class="math inline">\(F(\omega_n^k) = A(\omega_{n/2}^k) +
\omega_n^k B(\omega_{n/2}^k)\)</span></p>
<p><span class="math inline">\(F(\omega_n^{k+n/2}) = A(\omega_{n/2}^k) -
\omega_n^k B(\omega_{n/2}^k)\)</span></p>
<p>分治！</p>
<p>解决“多项式代入求值”的子问题<span
class="math inline">\(A(\omega_{(n/2)}^k)\)</span>和<span
class="math inline">\(B(\omega_{(n/2)}^k)\)</span> 就能求出<span
class="math inline">\((x_k, y_k)\)</span>，<span
class="math inline">\((x_{(k+n/2)}, y_{(k+n/2)})\)</span>两个点</p>
<p><span class="math inline">\(A(\omega_{n/2}^k)\)</span>和<span
class="math inline">\(B(\omega_{n/2}^k)\)</span>的规模（多项式系数个数）都是原问题的一半</p>
<h4 id="fft反变换">FFT反变换</h4>
<p>前面讨论了如何将多项式从系数表示法转换为点值表示法，现在需要解决如何从点值表示法转换回系数表示法，这个过程称为FFT反变换(IFFT)。</p>
<p>对于点值表示法<span
class="math inline">\((x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)\)</span>，需要求解方程组（<span
class="math inline">\(a_{i}\)</span>是未知数）：</p>
<p><span class="math display">\[
\begin{cases}
a_0 + a_1x_1 + a_2x_1^2 + \ldots + a_{n-1}x_1^{n-1} = y_1 \\
a_0 + a_1x_2 + a_2x_2^2 + \ldots + a_{n-1}x_2^{n-1} = y_2 \\
\vdots \\
a_0 + a_1x_n + a_2x_n^2 + \ldots + a_{n-1}x_n^{n-1} = y_n
\end{cases}
\]</span></p>
<p>这个方程组可以写成矩阵形式：</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; x_1 &amp; x_1^2 &amp; \ldots &amp; x_1^{n-1} \\
1 &amp; x_2 &amp; x_2^2 &amp; \ldots &amp; x_2^{n-1} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; x_n &amp; x_n^2 &amp; \ldots &amp; x_n^{n-1}
\end{bmatrix}
\begin{bmatrix}
a_0 \\
a_1 \\
\vdots \\
a_{n-1}
\end{bmatrix}
=
\begin{bmatrix}
y_1 \\
y_2 \\
\vdots \\
y_n
\end{bmatrix}
\]</span></p>
<p>当<span class="math inline">\(x_k =
\omega_n^k\)</span>时，这个矩阵是范德蒙德矩阵，其逆矩阵有特殊性质。实际上，
IFFT 的矩阵就是 FFT 得到的矩阵的共轭转置除以<span
class="math inline">\(n\)</span>。</p>
<p>因此， IFFT 的计算过程与FFT非常相似，只需要： 1. 将输入序列取共轭 2.
执行FFT 3. 将结果取共轭并除以<span class="math inline">\(n\)</span></p>
<p>所以在FFT代码中改动一小部分逻辑就能完成 IFFT。</p>
<h4 id="蝴蝶变换">蝴蝶变换</h4>
<p><span class="math display">\[A(\omega_n) = a_0 + a_2 \omega_n^1 + a_4
\omega_n^2 + \ldots + a_{n-2} \omega_n^{n/2-1}\]</span> <span
class="math display">\[B(\omega_n) = a_1 + a_3 \omega_n^1 + a_5
\omega_n^2 + \ldots + a_{n-1} \omega_n^{n/2-1}\]</span></p>
<p>观察系数序号与原始多项式的关系，在继续分治过程中，序号变化：</p>
<ul>
<li>初始序号：0, 1, 2, 3, 4, 5, 6, 7</li>
<li>第一次分组：0, 2, 4, 6 | 1, 3, 5, 7</li>
<li>第二次分组：0, 4 | 2, 6 | 1, 5 | 3, 7</li>
</ul>
<p>能否直接得到递归终点的序号序列<br />
0,4 | 2,6 | 1,5 |3,7 的二进制：<br />
000, 100, 010, 110, 001, 101, 011, 111<br />
所有二进制反向：<br />
000, 001, 010, 011, 100, 101, 110, 111</p>
<p>蝴蝶变换代码参考</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BitRevChange</span><span class="params">(Complex y[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// len 需要补齐到 2^k</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">rev</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) rev[i] |= len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) std::<span class="built_in">swap</span>(y[i], y[rev[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大整数乘法参考代码">大整数乘法参考代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释文字由AI阅读代码后生成，仅供参考</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);             <span class="comment">// 圆周率，用于计算单位根</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;                <span class="comment">// 浮点数精度误差</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">4e6</span> + <span class="number">10</span>;              <span class="comment">// 最大数组长度，需要是2的幂次</span></span><br><span class="line"><span class="keyword">typedef</span> std::complex&lt;<span class="type">double</span>&gt; Complex;   <span class="comment">// 复数类型，用于FFT计算</span></span><br><span class="line"><span class="type">char</span> a[maxn], b[maxn];                  <span class="comment">// 输入的两个大整数字符串</span></span><br><span class="line">Complex xa[maxn], xb[maxn];             <span class="comment">// 转换为复数数组，用于FFT计算</span></span><br><span class="line"><span class="type">int</span> lena, lenb, len2;                   <span class="comment">// 两个数的长度和FFT计算长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 蝴蝶变换：将系数按照二进制反转重新排列</span></span><br><span class="line"><span class="comment">// 例如：000,001,010,011,100,101,110,111 -&gt; 000,100,010,110,001,101,011,111</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BitRevChange</span><span class="params">(Complex y[], <span class="type">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">rev</span><span class="params">(len, <span class="number">0</span>)</span></span>;        <span class="comment">// 存储每个位置的反转序号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        rev[i] = rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>;       <span class="comment">// 利用递推关系计算反转序号</span></span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) rev[i] |= len &gt;&gt; <span class="number">1</span>;   <span class="comment">// 处理最低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) </span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) std::<span class="built_in">swap</span>(y[i], y[rev[i]]);  <span class="comment">// 只交换一次，避免重复</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FFT主函数：将多项式从系数表示转换为点值表示</span></span><br><span class="line"><span class="comment">// on=1表示FFT，on=-1表示IFFT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(Complex y[], <span class="type">int</span> len, <span class="type">int</span> on=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">BitRevChange</span>(y, len);               <span class="comment">// 先进行蝴蝶变换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> h = <span class="number">2</span>; h &lt;= len; h &lt;&lt;= <span class="number">1</span>)   <span class="comment">// h是当前处理的子问题规模</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算单位根：w_n = e^(2πi/n)</span></span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(cos(<span class="number">2</span> * pi / h), on * sin(<span class="number">2</span> * pi / h))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j += h)  <span class="comment">// 处理每个子问题</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;             <span class="comment">// 单位根的幂次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt; j + h / <span class="number">2</span>; k ++)</span><br><span class="line">            &#123;</span><br><span class="line">                Complex u = y[k];        <span class="comment">// 子问题A的结果</span></span><br><span class="line">                Complex t = w * y[k + h / <span class="number">2</span>];  <span class="comment">// 子问题B的结果</span></span><br><span class="line">                y[k] = u + t;            <span class="comment">// 合并结果：A + w*B</span></span><br><span class="line">                y[k + h / <span class="number">2</span>] = u - t;    <span class="comment">// 合并结果：A - w*B</span></span><br><span class="line">                w = w * wn;              <span class="comment">// 更新单位根的幂次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(on != <span class="number">-1</span>) <span class="keyword">return</span>;                 <span class="comment">// FFT不需要除以n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) y[i].<span class="built_in">real</span>(y[i].<span class="built_in">real</span>() / len);  <span class="comment">// IFFT需要除以n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a, b) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        lena = <span class="built_in">strlen</span>(a); lenb = <span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="comment">// 将字符串转换为复数数组，注意要倒序存储</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; a[i]; i ++) xa[i] = a[lena - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; b[i]; i ++) xb[i] = b[lenb - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算FFT需要的长度，必须是2的幂次</span></span><br><span class="line">        <span class="keyword">for</span>(len2 = <span class="number">1</span>; len2 &lt; lena + lenb; len2 &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 补零到len2长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = lena; i &lt; len2; i ++) xa[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = lenb; i &lt; len2; i ++) xb[i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对两个数进行FFT变换</span></span><br><span class="line">        <span class="built_in">FFT</span>(xa, len2); <span class="built_in">FFT</span>(xb, len2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在点值表示下直接相乘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len2; i ++) xa[i] *= xb[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行IFFT变换，得到乘积的系数表示</span></span><br><span class="line">        <span class="built_in">FFT</span>(xa, len2, <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理进位，将结果转换回字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len2; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = (<span class="type">int</span>)(xa[i].<span class="built_in">real</span>() + <span class="number">0.5</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 四舍五入并取模</span></span><br><span class="line">            xa[i + <span class="number">1</span>].<span class="built_in">real</span>(xa[i + <span class="number">1</span>].<span class="built_in">real</span>() + (<span class="type">int</span>)(xa[i].<span class="built_in">real</span>() + <span class="number">0.5</span>) / <span class="number">10</span>);  <span class="comment">// 处理进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去除前导零</span></span><br><span class="line">        <span class="keyword">for</span>(lena = len2 - <span class="number">1</span>; a[lena] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; lena &gt; <span class="number">0</span>; lena --);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span>(; lena &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a[lena]); lena --);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>16.前缀和、差分</title>
    <url>/2025-04-02-16-%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h1 id="前缀和差分">前缀和、差分</h1>
<p>前缀和与差分作为互补技术，分别通过预处理和逆运算高效处理数组的区间查询与批量修改问题。</p>
<span id="more"></span>
<h2 id="前缀和">前缀和</h2>
<h3 id="例区间和">例：区间和</h3>
<p>给定 <span class="math inline">\(n\)</span> 个正整数组成的数列 <span
class="math inline">\(a_1,a_2,\cdots,a_n\)</span> 和 <span
class="math inline">\(m\)</span> 个区间 <span
class="math inline">\([l_i,r_i]\)</span>，分别求这 <span
class="math inline">\(m\)</span> 个区间的区间和。</p>
<p>对于所有测试数据，<span class="math inline">\(n,m\leq
10^5\)</span>，<span class="math inline">\(a_i\leq 10^4\)</span></p>
<p>这个问题涉及多次询问，每次都加一遍效率很低。</p>
<p>前缀和是一种简单而强大的预处理技术。它通过预先计算数组中从第一个元素到每个位置的元素之和，使得我们能够在O(1)的时间内求出任意区间的和。</p>
<p>对于一个数组 <span
class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，我们定义前缀和数组
<span class="math inline">\(s_i\)</span> 为:</p>
<p><span class="math inline">\(s_i = \sum_{j=1}^i a_j\)</span></p>
<p>也就是说：</p>
<ul>
<li><span class="math inline">\(s_1 = a_1\)</span></li>
<li><span class="math inline">\(s_2 = a_1 + a_2\)</span></li>
<li><span class="math inline">\(s_3 = a_1 + a_2 + a_3\)</span></li>
<li>...以此类推</li>
</ul>
<p>有了前缀和数组后，要求区间 <span class="math inline">\([l,r]\)</span>
的和，只需要用 <span class="math inline">\(s_r - s_{l-1}\)</span>
即可。这是因为:</p>
<ul>
<li><span class="math inline">\(s_r\)</span> 包含了 <span
class="math inline">\(a_1\)</span> 到 <span
class="math inline">\(a_r\)</span> 的所有元素之和</li>
<li><span class="math inline">\(s_{l-1}\)</span> 包含了 <span
class="math inline">\(a_1\)</span> 到 <span
class="math inline">\(a_{l-1}\)</span> 的所有元素之和</li>
<li>两者相减就得到了 <span class="math inline">\(a_l\)</span> 到 <span
class="math inline">\(a_r\)</span> 的和</li>
</ul>
<p>这样，我们只需要O(n)的时间预处理出前缀和数组，就可以在O(1)的时间内回答任意区间和的询问。对于有大量询问的情况，这种方法比每次都重新计算区间和要高效得多。</p>
<p>例如对于数组 [1,2,3,4,5]:</p>
<ul>
<li>前缀和数组为 [1,3,6,10,15]</li>
<li>要求区间[2,4]的和，只需计算 s[4] - s[1] = 10 - 1 = 9</li>
</ul>
<p>用递推的方式<span
class="math inline">\(O(n)\)</span>就可以得到一个数组的前缀和数组，设数组为<code>a[maxn]</code>，前缀和数组为<code>pre[maxn]</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pre[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 假设数组数据从下标 1 开始，用 0 作为“哨兵”</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    pre[i] = pre[i - <span class="number">1</span>] + a[i];  <span class="comment">// 递推计算前缀和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对任意<span
class="math inline">\([i,j]\)</span>（闭区间为例）区间和，<code>pre[j] - pre[i - 1]</code>
可以得到</p>
<h3 id="例最大加权矩形">例：最大加权矩形</h3>
<p>给定一个 <span class="math inline">\(n\times n\)</span>
的矩阵，矩阵中的每个元素都是整数，范围在 <span
class="math inline">\([−127,127]\)</span>
之间。求矩阵中所有可能的矩形中，元素和最大的那个矩形的和。</p>
<p>例如对于矩阵： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 –2 –7  0 </span><br><span class="line"> 9  2 –6  2</span><br><span class="line">-4  1 –4  1 </span><br><span class="line">-1  8  0 –2</span><br></pre></td></tr></table></figure></p>
<p>左下角的 <span class="math inline">\(3\times 2\)</span> 矩形：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9  2</span><br><span class="line">-4  1</span><br><span class="line">-1  8</span><br></pre></td></tr></table></figure>
<p>和为 15。</p>
<p>先考虑最直观的思路，枚举所有矩形的“左上点”和“右下点”，就算提前计算了所有点的“左上方”的和，至少也是
<span class="math inline">\(O(n^4)\)</span> 的复杂度了。</p>
<p>在复杂度理论中已了解过最大连续和的<span
class="math inline">\(O(n)\)</span>解法，假设最大矩形是 左上点<span
class="math inline">\((r_{1},c_{1})\)</span>，右下点 <span
class="math inline">\((r_{2},c_{2})\)</span>之间的矩形，如果把矩阵其它行都去掉，只保留<span
class="math inline">\([r_{1},r_{2}]\)</span>
这些行，把每一列的和看作一个整体，就能得到一个 <span
class="math inline">\(n\)</span>
元素序列，这个序列的最大连续和，就是<span
class="math inline">\((r_{1},c_{1}),
(r_{2},c_{2})\)</span>这个矩形的和。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">##@@@@#### ┐</span><br><span class="line">##@@@@####  &gt; 这些行的每一列的和看作一个元素（一列#相加），求最大连续和（@那些列）</span><br><span class="line">##@@@@#### ┘</span><br><span class="line">..........</span><br></pre></td></tr></table></figure>
<p>对于任意行起点<span class="math inline">\(r_{1}\)</span>、行终点<span
class="math inline">\(r_{2}\)</span>，只要能快速得到这些行的各列之和，就能<span
class="math inline">\(O(n)\)</span>求它的最大连续和。</p>
<p>预处理每一列的前缀和（<span
class="math inline">\(O(n^2)\)</span>），这一列的任意起点到终点的和就能立刻得到，枚举行起点（<span
class="math inline">\(O(n)\)</span>）和行终点（<span
class="math inline">\(O(n)\)</span>）以及计算这些行的最大连续和（<span
class="math inline">\(O(n)\)</span>），取最大就是最大矩形了，这个方案的复杂度是<span
class="math inline">\(n^2+n^3=O(n^3)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">211</span>;</span><br><span class="line"><span class="comment">// 预处理每一列的前缀和</span></span><br><span class="line"><span class="type">int</span> n, a[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">            a[i][j] += i == <span class="number">0</span> ? <span class="number">0</span> :a[i - <span class="number">1</span>][j]; <span class="comment">// 原地保存列方向前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r1 = <span class="number">0</span>; r1 &lt; n; r1 ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r2 = r1; r2 &lt; n; r2 ++) &#123;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">                pre += a[r2][i] - (r1 == <span class="number">0</span> ? <span class="number">0</span> : a[r1 - <span class="number">1</span>][i]); <span class="comment">// 列方向[r1,r2]这一段的和作为一个元素</span></span><br><span class="line">                ans = std::<span class="built_in">max</span>(ans, pre);</span><br><span class="line">                <span class="keyword">if</span>(pre &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pre = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="差分">差分</h2>
<p>差分是前缀和的逆运算。对于一个数组 <span
class="math inline">\(a\)</span>，它的差分数组 <span
class="math inline">\(b\)</span> 定义为：</p>
<ul>
<li><span class="math inline">\(b_1 = a_1\)</span></li>
<li><span class="math inline">\(b_i = a_i - a_{i-1}\)</span> <span
class="math inline">\((i&gt;1)\)</span></li>
</ul>
<p>容易发现，原数组的任意一个元素都可以通过差分数组的前缀和还原：</p>
<p><span class="math inline">\(a_i = \sum\limits_{j=1}^i
b_j\)</span></p>
<p>差分的一个重要性质是：如果要对原数组的一个区间 <span
class="math inline">\([l,r]\)</span> 同时加上一个数 <span
class="math inline">\(x\)</span>，只需要：</p>
<ul>
<li>令 <span class="math inline">\(b_l\)</span> 加上 <span
class="math inline">\(x\)</span>：因为<span
class="math inline">\(a_{l}\)</span>加了<span
class="math inline">\(x\)</span>而<span
class="math inline">\(a_{l-1}\)</span>没加，<span
class="math inline">\(b_{l}=a_{l}-a_{l-1}\)</span>所以加<span
class="math inline">\(x\)</span>；</li>
<li><span class="math inline">\(b_{l+1}\sim b_{r}\)</span>
不变，因为<span class="math inline">\(a_{l}\sim a_{r}\)</span> 都加了
<span class="math inline">\(x\)</span>，它们相邻的差不变；</li>
<li>令 <span class="math inline">\(b_{r+1}\)</span> 减去 <span
class="math inline">\(x\)</span> （如果 <span
class="math inline">\(r+1\)</span> 存在的话），因为<span
class="math inline">\(a_{r+1}\)</span>没有加<span
class="math inline">\(x\)</span></li>
<li>后面的不变</li>
</ul>
<p>也即<strong>原数在一个区间同时加一个数，差分数组只需要改变区间首尾两个数</strong>。</p>
<h3 id="例区间变化">例：区间变化</h3>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(a\)</span>，有 <span
class="math inline">\(p\)</span> 次操作，每次操作给定三个数 <span
class="math inline">\(x\)</span>、<span
class="math inline">\(y\)</span>、<span
class="math inline">\(z\)</span>，表示将数组 <span
class="math inline">\(a\)</span> 中从第 <span
class="math inline">\(x\)</span> 个到第 <span
class="math inline">\(y\)</span> 个元素（包括这两个位置）都加上 <span
class="math inline">\(z\)</span>。最后求整个数组中的最小值。</p>
<p>模拟这个过程复杂度会很高，如果能把区间修改问题转换为单点修改问题，就会快很多。</p>
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, p, a[maxn], l, r, x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line">        <span class="comment">// 原地计算差分，for循环逆序是避免要用的值被先覆盖</span></span><br><span class="line">        a[i] -= a[i - <span class="number">1</span>];   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">        a[l] += x;</span><br><span class="line">        <span class="keyword">if</span>(r + <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">            a[r + <span class="number">1</span>] -= x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例二维区间修改">例：二维区间修改</h3>
<p>给定一个 <span class="math inline">\(n\times n\)</span> 的网格，有
<span class="math inline">\(m\)</span>
次操作，每次操作给定四个数，表示将左上角为 <span
class="math inline">\((r_1,c_1)\)</span>，右下角为 <span
class="math inline">\((r_2,c_2)\)</span> 的矩形区域内的每个格子都加
<span
class="math inline">\(1\)</span>。最后输出每个格子被加了多少次。</p>
<p>数据范围 <span class="math inline">\(n,m \leq 1000\)</span></p>
<p>根据题目给的数据范围，这道题可以想简单点，对于每个 左上 <span
class="math inline">\((r_1,c_1)\)</span>、右下 <span
class="math inline">\((r_2,c_2)\)</span> 的矩形，都可以看作 <span
class="math inline">\(r_{1}\sim r_{2}\)</span>
这些行分别进行一次区间增长，分别用差分来单点更新：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0  0  0  0  0  0</span><br><span class="line">0 +1  0  0  0 -1</span><br><span class="line">0 +1  0  0  0 -1</span><br><span class="line">0 +1  0  0  0 -1</span><br><span class="line">0 +1  0  0  0 -1</span><br><span class="line">0  0  0  0  0  0</span><br></pre></td></tr></table></figure>
<p>复杂度分析：初始化计算每一行差分数组，<span
class="math inline">\(O(n^2)\)</span>，<span
class="math inline">\(m\)</span> 个操作、每个操作最坏对 <span
class="math inline">\(n\)</span> 行的差分数组做 <span
class="math inline">\(O(1)\)</span> 操作，总复杂度 <span
class="math inline">\(n^{2}+mn=O(mn)\)</span>，<span
class="math inline">\(n,m \leq 1000\)</span>，复杂度可接受。</p>
<p>更多思考：一些同学可能想到两次差分，把多行多次差分数组更新变成首尾两次：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0  0  0  0  0  0</span><br><span class="line">0 +1  0  0  0 -1</span><br><span class="line">0  0  0  0  0  0</span><br><span class="line">0  0  0  0  0  0</span><br><span class="line">0  0  0  0  0  0</span><br><span class="line">0 -1  0  0  0 +1</span><br></pre></td></tr></table></figure>
<p>而这道题<span class="math inline">\(m\)</span>和<span
class="math inline">\(n\)</span>范围一致，即使把 <span
class="math inline">\(O(mn)\)</span> 优化到 <span
class="math inline">\(O(m)\)</span>，初始差分表也有个 <span
class="math inline">\(O(n^2)\)</span> 在，<span
class="math inline">\(n^{2}+m=O(n^2)\)</span>
，复杂度没有本质提升。不过如果 <span class="math inline">\(m\)</span> 比
<span class="math inline">\(n\)</span>
大很多，那么这个优化还是有意义的，可以尝试。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>17.贪心</title>
    <url>/2025-04-02-17-%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h1 id="贪心">贪心</h1>
<p>贪心算法是一种在每一步选择中都采取当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法策略。</p>
<span id="more"></span>
<h2 id="重在证明">重在证明</h2>
<p>局部最优就能得到全局最优，这是一件很美好的事情，使决策变得简单易执行。</p>
<p>当然不是所有问题都能这样得到最优解，所以一个问题是否可以用贪心方式解决，就需要先证明贪心策略的正确性。</p>
<p>否定一个贪心策略很容易，找到一个反面例子。</p>
<p>所以尝试贪心方法的大体思路就是：</p>
<ol type="1">
<li>想一些拍脑门就有的局部最优策略</li>
<li>尝试举反例否定它们</li>
<li>对暂时找不到反例的思路，尝试证明正确性</li>
</ol>
<p>比较典型的证明方法：</p>
<ul>
<li>反证法：作否定假设，则有更优解，进而推出矛盾</li>
<li>归纳法：证<span class="math inline">\(n=1\)</span>成立，假设<span
class="math inline">\(n\)</span>成立，推<span
class="math inline">\(n+1\)</span>成立</li>
<li>交换论证：交换贪心方案的两个元素，答案不会变得更好，或假设任意最优解，能通过等价交换得到贪心的方案</li>
</ul>
<h2 id="背包类问题">背包类问题</h2>
<h3 id="例最优装载">例：最优装载</h3>
<p><span class="math inline">\(n\)</span> 个物体，第 <span
class="math inline">\(i\)</span> 个物体重量<span
class="math inline">\(w_i\)</span>，求总重量不超过<span
class="math inline">\(C\)</span>的最多物体个数</p>
<p>交换论证： 假设存在最优解<span class="math inline">\(w_{s_1} \leq
w_{s_2} \leq \ldots \leq w_{s_k}\)</span>，不是轻者优先 则存在<span
class="math inline">\(w_i \leq w_{s_k}\)</span>，用<span
class="math inline">\(w_i\)</span>替换<span
class="math inline">\(w_{s_k}\)</span>仍然不会超过容量，且个数不变
不断执行该替换，总能得到轻者优先的方案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, tc = C;</span><br><span class="line">std::<span class="built_in">sort</span>(w, w + n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; tc &gt;= w[i]; tc -= w[i ++], ans ++);</span><br></pre></td></tr></table></figure>
<h3 id="例分数背包">例：分数背包</h3>
<p>有<span class="math inline">\(n\)</span>个物品，每个物品<span
class="math inline">\(i \in [1,n]\)</span>的重量<span
class="math inline">\(w_i\)</span>，价值<span
class="math inline">\(v_i\)</span>（分别只有1个）
有一个背包可装总重不超过<span class="math inline">\(b\)</span>的物品
求背包能装物品的最大总价值
物品可进行任意精度的分割（可以理解为金沙、液体等）</p>
<p>分数背包 贪心策略：“性价比”<span
class="math inline">\(\frac{v_i}{w_i}\)</span> 排序，高者优先</p>
<p>对0-1背包 不适用</p>
<p>举反例：</p>
<p><span class="math inline">\(W=\{3,4,5,2\}\)</span>，<span
class="math inline">\(V=\{7,9,9,2\}\)</span>，<span
class="math inline">\(C=6\)</span></p>
<p><span class="math inline">\(\frac{7}{3} &gt; \frac{9}{4} &gt;
\frac{9}{5} &gt; \frac{2}{2}\)</span></p>
<p>贪心解<span class="math inline">\(3+2=5&lt;6\)</span>，<span
class="math inline">\(7+2=9\)</span></p>
<p>最优解<span class="math inline">\(4+2=6\)</span>，<span
class="math inline">\(9+2=11&gt;9\)</span></p>
<h2 id="区间类问题">区间类问题</h2>
<h3 id="例活动选择">例：活动选择</h3>
<p>给出<span class="math inline">\(n\)</span>项活动的起止时间<span
class="math inline">\([s_i,f_i](i=1,2,\ldots,n)\)</span>，最多选出多少个活动时间互不重叠(<span
class="math inline">\(s_i \geq f_j\)</span> 或 <span
class="math inline">\(f_i \leq s_j\)</span>) 例：</p>
<table>
<thead>
<tr class="header">
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(s_{i}\)</span></td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>4</td>
<td>6</td>
<td>8</td>
<td>2</td>
</tr>
<tr class="even">
<td><span class="math inline">\(f_{i}\)</span></td>
<td>4</td>
<td>5</td>
<td>7</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>13</td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(\{1,3,6\}\)</span>是最优解之一</p>
<p>思考：</p>
<ul>
<li>策略1：开始时间早的优先</li>
<li>策略2：占用时间少的优先</li>
<li>策略3：结束早的优先</li>
</ul>
<p>反例：</p>
<p>策略1：<img src="/2025-04-02-17-%E8%B4%AA%E5%BF%83/%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9_%E7%AD%96%E7%95%A51%E5%8F%8D%E4%BE%8B.svg" class="" title="开始时间早的优先反例"><br />
策略2：<img src="/2025-04-02-17-%E8%B4%AA%E5%BF%83/%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9_%E7%AD%96%E7%95%A52%E5%8F%8D%E4%BE%8B.svg" class="" title="占用时间少的优先反例"></p>
<p>证明策略3结束早的优先能得到最优解——安排最多的活动</p>
<p>假设活动已按结束时间排序，<span class="math inline">\(f_1 \leq f_2
\leq \ldots \leq f_n\)</span></p>
<p>归纳基础：存在最优解包含可选活动里结束最早的活动。考虑多解情况，换种说法就是选最早结束的活动，不会导致得不到最优解。</p>
<p>交换论证，如果存在最优解不包含活动1，活动1一定可以代替该最优解中结束时间最早的那个活动，仍然是最优解</p>
<img src="/2025-04-02-17-%E8%B4%AA%E5%BF%83/%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9_%E7%AD%96%E7%95%A53%E5%BD%92%E7%BA%B3%E5%9F%BA%E7%A1%80.svg" class="" title="存在最优解包含可选活动里结束最早的活动">
<p>归纳论证：按此策略选了 <span class="math inline">\(k\)</span>
个活动后，剩下的可选活动里选第 <span class="math inline">\(k+1\)</span>
个活动时，选结束最早的那个，不会导致得不到最优解。</p>
<img src="/2025-04-02-17-%E8%B4%AA%E5%BF%83/%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9_%E7%AD%96%E7%95%A53%E5%BD%92%E7%BA%B3%E8%AE%BA%E8%AF%81.svg" class="" title="归纳论证">
<p>图中 <span class="math inline">\(S&#39;\)</span> 是选了 <span
class="math inline">\(k\)</span>
个活动后，剩下的不冲突的可选活动，如果把 <span
class="math inline">\(S&#39;\)</span>
看作一个独立的活动选择问题，这个问题的最优解是 <span
class="math inline">\(B\)</span> 集合，则可以用反证法证明 <span
class="math inline">\(B\)</span> 集合和前面的 <span
class="math inline">\(k\)</span>
个活动合起来，是原来整个问题的最优解。</p>
<blockquote>
<p>为了防止新手绕晕，关于这个需要反证的论断可以先跳过，读完证明后再返回来看：<span
class="math inline">\(S&#39;\)</span> 的最优解 <span
class="math inline">\(B\)</span>，<span class="math inline">\(B \cup
\{i_1,i_2,\ldots,i_k\}\)</span>
是全局最优解，反证法证明它，可以做一个否定的假设——<span
class="math inline">\(S&#39;\)</span> 的最优解 <span
class="math inline">\(B\)</span>，<span class="math inline">\(B \cup
\{i_1,i_2,\ldots,i_k\}\)</span>
<strong>不</strong>是全局最优解，那必然存在 <span
class="math inline">\(S&#39;\)</span> 的另一个子集 <span
class="math inline">\(B*\)</span>，<span class="math inline">\(B* \cup
\{i_1,i_2,\ldots,i_k\}\)</span>是全局最优解（总得有个最优解吧），那<span
class="math inline">\(\{i_1,i_2,\ldots,i_k\}\)</span>都不变，只能是
<span class="math inline">\(B*\)</span> 比 <span
class="math inline">\(B\)</span> 元素多。既然 <span
class="math inline">\(B*\)</span> 也是 <span
class="math inline">\(S&#39;\)</span> 的子集，又比 <span
class="math inline">\(B\)</span> 元素多，那为啥 <span
class="math inline">\(B*\)</span> 不是 <span
class="math inline">\(S&#39;\)</span>
最优解呢，这就得到矛盾了，于是推翻反证法的否定假设，原命题成立。</p>
</blockquote>
<ul>
<li>既然<span
class="math inline">\(B\)</span>是整个问题最优解的一部分，那么第<span
class="math inline">\(k+1\)</span>个活动可以包含在<span
class="math inline">\(B\)</span>中（考虑多解问题，这里用“可以”来表述，仍然表达的是“不会导致得不到最优解”这个含义）</li>
<li>而 <span class="math inline">\(B\)</span> 又同时是 <span
class="math inline">\(S&#39;\)</span>
这个独立问题的最优解，根据归纳基础——存在最优解包含可选活动里结束最早的活动</li>
<li>那么第<span class="math inline">\(k+1\)</span>个活动就可以是<span
class="math inline">\(S&#39;\)</span>结束最早的活动</li>
</ul>
<p>到这里，就说明了，不断选剩下的可选活动里结束最早的活动，能够一步步走向最优解（因为每一步都不会导致得不到最优解）。</p>
<h3 id="例最小延迟调度">例：最小延迟调度</h3>
<p>给出 <span class="math inline">\(n\)</span> 个任务的执行时长 <span
class="math inline">\(t_i\)</span> 与预期截止时间 <span
class="math inline">\(d_i\)</span> <span
class="math inline">\((i=1,2,…,n)\)</span>，求一个调度方案，使超时最严重的任务的超时时长最小。</p>
<p>例：<span class="math inline">\(T=\{5,8,4,10,3\}\)</span>，<span
class="math inline">\(D=\{10,12,15,11,20\}\)</span></p>
<p>调度1：顺序安排 延迟：<span
class="math inline">\(0,1,2,16,10\)</span> 最大延迟：<span
class="math inline">\(16\)</span></p>
<p>调度2：截止时间安排 延迟：<span
class="math inline">\(0,4,11,12,10\)</span> 最大延迟：<span
class="math inline">\(12\)</span></p>
<img src="/2025-04-02-17-%E8%B4%AA%E5%BF%83/%E6%9C%80%E5%B0%8F%E5%BB%B6%E8%BF%9F%E8%B0%83%E5%BA%A6_%E6%A0%B7%E4%BE%8B%E8%B0%83%E5%BA%A6.svg" class="" title="最小延迟调度_样例调度">
<ul>
<li>策略1：按照 <span class="math inline">\(t_i\)</span>
从小到大安排</li>
<li>策略2：按照 <span class="math inline">\(d_i - t_i\)</span>
从小到大安排</li>
<li>策略3：按照 <span class="math inline">\(d_i\)</span>
从小到大安排</li>
</ul>
<p>反例：</p>
<ul>
<li>策略1: <span class="math inline">\(t_1=1, d_1=100, t_2=10,
d_2=10\)</span></li>
<li>策略2:：<span class="math inline">\(t_1=1, d_1=2, t_2=10,
d_2=10\)</span></li>
</ul>
<p>交换论证证明策略3：按照 <span class="math inline">\(d_i\)</span>
从小到大安排</p>
<p>如果有相邻的<span
class="math inline">\(2\)</span>个任务，前一个比后一个 <span
class="math inline">\(d_i\)</span>
大，交换这两个任务，不会让延迟增加。</p>
<style>.bfzbvysllpcz{width: 400px;}</style>
<img src="/2025-04-02-17-%E8%B4%AA%E5%BF%83/%E6%9C%80%E5%B0%8F%E5%BB%B6%E8%BF%9F%E8%B0%83%E5%BA%A6_%E7%AD%96%E7%95%A53%E4%BA%A4%E6%8D%A2%E8%AE%BA%E8%AF%81.svg" class="bfzbvysllpcz" title="策略3交换论证">
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>18.二分答案</title>
    <url>/2025-04-02-18-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/</url>
    <content><![CDATA[<h1 id="二分答案">二分答案</h1>
<p>在线性表章节已了解二分查找的基本原理，当一个问题的答案具有单调性时——即随着答案的增大或减小，判定条件的结果也呈现单调变化，比如答案越大条件越容易满足，或者答案越小条件越容易满足，可以通过二分查找，在过程中根据判定条件是否满足来调整二分的方向逼近解的过程。</p>
<span id="more"></span>
<h3 id="例一元三次方程求解">例：一元三次方程求解</h3>
<p>给定一个一元三次方程 <span class="math inline">\(ax^3 + bx^2 + cx + d
= 0\)</span>，其中系数 <span class="math inline">\(a, b, c, d\)</span>
均为实数，并已知该方程有三个不同的实根，这些根的范围在 <span
class="math inline">\(-100\)</span> 至 <span
class="math inline">\(100\)</span> 之间，且任意两根间的差的绝对值 <span
class="math inline">\(\geq
1\)</span>。请按从小到大的顺序在同一行输出这三个实根（精确到小数点后两位，并留有空格）。</p>
<p>输入：4个实数</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1 -5 -4 20</span><br></pre></td></tr></table></figure>
<p>输出：3个保留2位小数的实根</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-2.00 2.00 5.00</span><br></pre></td></tr></table></figure>
<p>题目给的关键条件是数据确保根的距离大于 <span
class="math inline">\(1\)</span>，也即相邻两个整数的左闭右开区间中至多 1
个解。如果某个这样的区间有解，则必然两端的 <span
class="math inline">\(f(x)\)</span> 不可能在 <span
class="math inline">\(x\)</span> 轴的同一侧，即 <span
class="math inline">\(f(x_{1})*f(x_{2}) \leq 0\)</span>。</p>
<p>思路：枚举每个长度为 1 的区间，判断两端是否不在 <span
class="math inline">\(x\)</span>
轴同侧，如果不在同侧，说明区间内有解，二分 <span
class="math inline">\(x\)</span> 的值，直到它的函数值为 0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c, <span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * x * x * x + b * x * x + c * x + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在[-100,100]范围内，相邻整数区间最多一个解</span></span><br><span class="line">    <span class="comment">// 遍历每个整数区间，用二分法找解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">-100</span>; i &lt;= <span class="number">100</span>; i ++) &#123;</span><br><span class="line">        <span class="type">double</span> l = i, r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 区间两端异号说明有解</span></span><br><span class="line">        <span class="type">double</span> fl = <span class="built_in">f</span>(l, a, b, c, d), fr = <span class="built_in">f</span>(r, a, b, c, d);</span><br><span class="line">        <span class="keyword">if</span>(-eps &lt; fl &amp;&amp; fl &lt; eps) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, l); <span class="comment">// 左端点是解</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(-eps &lt; fr &amp;&amp; fr &lt; eps) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;           <span class="comment">// 右端点是解，考虑左闭右开区间，忽略</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fl * fr &lt; eps) &#123;</span><br><span class="line">            <span class="comment">// l 和 r 之间存在解，二分找解</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j ++) &#123;</span><br><span class="line">                <span class="type">double</span> mid = (l + r) * <span class="number">0.5</span>;</span><br><span class="line">                <span class="type">double</span> fm = <span class="built_in">f</span>(mid, a, b, c, d);</span><br><span class="line">                <span class="keyword">if</span>(fm * fl &lt; eps) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知识点： 浮点精度冗余 <code>eps</code>。
浮点类型在计算机底层也是由有限位的二进制<code>01</code>表达的，就必然有精度限制，不能无限精确地表达任何数字，如果发生乘除法，这种精度会进一步丢失，当判断两个浮点数是否相等、一个浮点数大于0还是小于0的时候，用一个极小的浮点数作为精度冗余，比如对浮点数
<code>fl</code>， <code>if(fl == 0)</code>
就是不安全的，它在丧失一定精度后，可能是
<code>0.0000312141</code>，也可能是<code>-0.0000012131</code>，
<code>eps</code>
是我们对特定问题期望的一个“可接受”精度，<code>const double eps=1e-7</code>
就表示在 <code>10^&#123;-7&#125;</code>（<code>0.0000001</code>）
范围内的误差都认为相等，<code>1e-7</code>
是算法题比较常用的一个精度，视具体问题，也有时会用
<code>1e-6</code>或<code>1e-8</code>。</p>
</blockquote>
<blockquote>
<p>知识点： 浮点数二分的时候，<code>while(r - l &gt; eps)</code>
是循环条件的常见写法，但一些刁钻的题可能精度不好把握，<code>for(int j = 0; j &lt; 100; j ++)</code>
直接二分<code>100</code>次，基本什么精度都能达到了，在分析好算法复杂度满足题意的情况下，这样写更加稳定。</p>
</blockquote>
<h3 id="例数列划分">例：数列划分</h3>
<p>给一个有 <span class="math inline">\(n\)</span>
个正整数的序列，连续地将其分为互不重叠的 <span
class="math inline">\(k\)</span>
份，即每一份都是该序列的一个子串，不能调换顺序。</p>
<p>求一个划分方案，使数字之和最大的那一份，其和在所有划分方案里最小。</p>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">9 3</span><br><span class="line">10 20 30 40 50 60 70 80 90</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">10 20 30 40 50 / 60 70 / 80 90</span><br></pre></td></tr></table></figure>
<p>二分答案常常伴随着<strong>贪心</strong>策略——二分可能的答案数值，在验证判定条件时，往往会需要一个复杂度较低的策略，当判定条件支持贪心时，就有更大的可能让二分答案的复杂度低于其它方案。</p>
<p>当指定一个“数字之和最大的那一份”的限制时，实际就是尝试构造一个划分，让每一份都不超过这个限制，如果无法实现，则判定为“否”，如果能实现，则判定为“是”，限制值与判定关系是单调的——值够大就一定能成功划分，值小到一定程度就一定无法划分，那么能否完成划分的临界点，就是本题答案——最大那一份最小的划分。</p>
<p>划分的判定采用贪心策略，因为划分并不改变顺序，那就让每一份尽可能的靠近限制值，直到装不下，再开始划分下一份。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k, a[maxn];</span><br><span class="line"><span class="type">bool</span> split[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Judge</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>, tmpsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmpsum + a[i] &gt; mid) tmpsum = <span class="number">0</span>, cnt++;</span><br><span class="line">        tmpsum += a[i];</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k) != EOF) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">1e9</span>, mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Judge</span>(mid))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmpsum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(split, <span class="number">0</span>, <span class="built_in">sizeof</span>(split));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpsum + a[i] &gt; left || i + <span class="number">1</span> &lt; k - cnt)</span><br><span class="line">                tmpsum = <span class="number">0</span>, split[i] = <span class="literal">true</span>, cnt++;</span><br><span class="line">            tmpsum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span> + !i, a[i]);</span><br><span class="line">            <span class="keyword">if</span> (split[i]) <span class="built_in">printf</span>(<span class="string">&quot; /&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>19.三分</title>
    <url>/2025-04-02-19-%E4%B8%89%E5%88%86/</url>
    <content><![CDATA[<h1 id="三分">三分</h1>
<p>三分是一种用于求解<strong>单峰/单谷函数</strong>极值的搜索算法，通过每次将区间分成三份并比较两个分点的函数值来缩小搜索范围。</p>
<span id="more"></span>
<p>对于一个单峰函数，在区间 <span class="math inline">\([l,r]\)</span>
上有唯一的极大值点。可以取两个三分点：</p>
<ul>
<li><span class="math inline">\(mid1 = l + \frac{r-l}{3}\)</span></li>
<li><span class="math inline">\(mid2 = r - \frac{r-l}{3}\)</span></li>
</ul>
<img src="/2025-04-02-19-%E4%B8%89%E5%88%86/trisection.svg" class="">
<p>比较 <span class="math inline">\(f(mid1)\)</span> 和 <span
class="math inline">\(f(mid2)\)</span> 的大小:</p>
<ul>
<li>如果 <span class="math inline">\(f(mid1) &lt;
f(mid2)\)</span>，说明极大值点在 <span
class="math inline">\([mid1,r]\)</span> 区间内，令 <span
class="math inline">\(l = mid1\)</span></li>
<li>如果 <span class="math inline">\(f(mid1) &gt;
f(mid2)\)</span>，说明极大值点在 <span
class="math inline">\([l,mid2]\)</span> 区间内，令 <span
class="math inline">\(r = mid2\)</span></li>
<li>如果 <span class="math inline">\(f(mid1) =
f(mid2)\)</span>，说明极大值点在 <span
class="math inline">\([mid1,mid2]\)</span> 区间内，令 <span
class="math inline">\(l = mid1, r = mid2\)</span></li>
</ul>
<p>每次迭代可以将区间长度缩小为原来的 <span
class="math inline">\(\frac{2}{3}\)</span>。</p>
<p>对于单谷函数，只需要将比较符号反向即可求出极小值点。</p>
<p>三分的基本框架如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三分求单峰函数极大值点</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">TrisectionMax</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> mid1, mid2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">        mid1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">        mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(mid1) &lt; <span class="built_in">f</span>(mid2)) l = mid1;</span><br><span class="line">        <span class="keyword">else</span> r = mid2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三分求单谷函数极小值点</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">TrisectionMin</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> mid1, mid2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">        mid1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">        mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(mid1) &gt; <span class="built_in">f</span>(mid2)) l = mid1;</span><br><span class="line">        <span class="keyword">else</span> r = mid2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例">示例</h2>
<h3 id="例三分函数">例：三分|函数</h3>
<p>给定 <span class="math inline">\(n\)</span> 个二次函数 <span
class="math inline">\(f_1(x), f_2(x), \ldots, f_n(x)\)</span>（均形如
<span class="math inline">\(ax^2 + bx + c\)</span>），设 <span
class="math inline">\(F(x) = \max\{f_1(x), f_2(x), \ldots,
f_n(x)\}\)</span>，求 <span class="math inline">\(F(x)\)</span> 在区间
<span class="math inline">\([0, 1000]\)</span> 上的最小值。</p>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2 0 0</span><br><span class="line">2</span><br><span class="line">2 0 0</span><br><span class="line">2 -4 2</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0.0000</span><br><span class="line">0.5000</span><br></pre></td></tr></table></figure>
<p>分析：都是朝上的二次函数，画画图可以发现，两个口朝上的单峰函数取较大函数值叠加，仍然是口朝上的单峰函数，那么无数个叠加也仍然是，可以用三分求极值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="type">double</span> a, b, c;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * x * x + b * x + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">F</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ret = f[<span class="number">0</span>].<span class="built_in">calc</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        ret = std::<span class="built_in">max</span>(ret, f[i].<span class="built_in">calc</span>(x));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">TrisectionMin</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> mid1, mid2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</span><br><span class="line">        mid1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">        mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">F</span>(mid1) &gt; <span class="built_in">F</span>(mid2)) l = mid1;</span><br><span class="line">        <span class="keyword">else</span> r = mid2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;f[i].a, &amp;f[i].b, &amp;f[i].c);</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>, <span class="built_in">F</span>(<span class="built_in">TrisectionMin</span>(<span class="number">0</span>, <span class="number">1000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>20.离散化</title>
    <url>/2025-04-03-20-%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    <content><![CDATA[<h1 id="离散化">离散化</h1>
<p>离散化是一种将无限空间中的有限个体映射到有限空间中的方法，常用于处理数据范围很大但实际数据量较小的问题。</p>
<span id="more"></span>
<p>离散化的核心思想是将大范围的数据映射到小范围，同时保持数据之间的相对关系。通常用于处理以下情况：</p>
<ol type="1">
<li>数据范围很大（如 <span class="math inline">\(-2^{31}\)</span> 到
<span class="math inline">\(2^{31}\)</span>）</li>
<li>实际数据点较少</li>
<li>需要处理区间或线段</li>
</ol>
<p>场景举例：</p>
<p>差分专题中的区间改变问题，如果区间是 <span class="math inline">\([(1,
3353), (534543, 231876390), (3353, 5667)]\)</span>
这样的大范围，没法开数组到这么大规模做差分标记，但区间的数量不会太多，比如<span
class="math inline">\(10000\)</span> 个区间，那就至多 <span
class="math inline">\(20000\)</span> 个坐标点（区间起止会提供 <span
class="math inline">\(2\)</span>
个坐标，以及有一些起止点可能重叠）。</p>
<p>离散化处理</p>
<ul>
<li>把 <span class="math inline">\((1, 3353, 534543, 231876390, 3353,
5667)\)</span> 平铺排开</li>
<li>排序：<span class="math inline">\((1, 3353, 3353, 5667, 534543,
231876390)\)</span></li>
<li>去重：<span class="math inline">\((1, 3353, 5667, 534543,
231876390)\)</span> （去掉了一个重复的 <span
class="math inline">\(3353\)</span>）</li>
<li>用序号代替： <span
class="math inline">\(([0]=1,[1]=3353,[2]=5667,[3]=534543,[4]=231876390)\)</span></li>
<li>区间系列 <span class="math inline">\([(1, 3353), (534543,
231876390), (3353, 5667)]\)</span> 改变为序号 <span
class="math inline">\([(0, 1), (3, 4), (1, 2)]\)</span></li>
<li>序号范围显然是坐标点个数以内的，用序号代替原坐标点，就可以开数组做差分或其它区间操作了</li>
<li>最后处理数据时，用序号查询原始数值，做进一步处理</li>
</ul>
<h3 id="例区间合并">例：区间合并</h3>
<p>给定 <span class="math inline">\(n\)</span> 个区间 <span
class="math inline">\([a_i, b_i)\)</span>，求所有区间覆盖的总长度。</p>
<ul>
<li><p>第一行一个整数 <span
class="math inline">\(n\)</span>，表示区间数量</p></li>
<li><p>接下来 <span class="math inline">\(n\)</span> 行，每行两个整数
<span class="math inline">\(a_i,
b_i\)</span>，表示一个区间的起点和终点（左闭右开）</p></li>
<li><p><span class="math inline">\(1 \leq n \leq 2 \times
10^4\)</span></p></li>
<li><p><span class="math inline">\(-2^{31} \leq a &lt; b &lt;
2^{31}\)</span></p></li>
<li><p>答案小于 <span class="math inline">\(2^{31}\)</span></p></li>
</ul>
<p>输出一行一个整数，表示所有区间覆盖的总长度</p>
<p>输入：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">5 11</span><br><span class="line">2 9</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>将所有区间的端点收集并排序</li>
<li>去重得到离散化后的值</li>
<li>使用差分数组或扫描线算法计算覆盖长度</li>
</ol>
<p>参考代码，顺便提供一个离散化参考通用模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个相对通用的离散化模板，把一个数组传入 Make，会执行去重与排序</span></span><br><span class="line"><span class="comment">// 之后可以用序号找去找第 k 个元素， d[k]，也可以用 Loc 找 x 离散后的序号 d.Loc(x)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TP_V&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Discretization</span> &#123;</span><br><span class="line">    std::vector&lt;TP_V&gt; b;</span><br><span class="line">    std::unordered_map&lt;TP_V, <span class="type">int</span>&gt; mp;   <span class="comment">// 二分或hash找离散值对应的序号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;b.<span class="built_in">clear</span>(); mp.<span class="built_in">clear</span>();&#125;</span><br><span class="line">    <span class="built_in">Discretization</span>()&#123;<span class="built_in">Init</span>();&#125;</span><br><span class="line">    <span class="built_in">Discretization</span>(std::vector&lt;TP_V&gt; &amp;a)&#123;<span class="built_in">Make</span>(a);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Make</span><span class="params">(std::vector&lt;TP_V&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">        <span class="built_in">Add</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(std::vector&lt;TP_V&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : a) b.<span class="built_in">push_back</span>(i);</span><br><span class="line">        std::<span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        b.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i ++) mp[b[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    TP_V &amp;<span class="keyword">operator</span>[](<span class="type">int</span> ith)&#123;<span class="keyword">return</span> b[ith];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Loc</span><span class="params">(TP_V x)</span> </span>&#123;<span class="keyword">return</span> mp.<span class="built_in">count</span>(x) ? mp[x] : <span class="number">-1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd[maxn &lt;&lt; <span class="number">1</span>];  <span class="comment">// 差分数组，下标是离散后的序号，而非真实坐标</span></span><br><span class="line"><span class="type">int</span> a[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s, e;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    Discretization&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    <span class="built_in">memset</span>(fd, <span class="number">0</span>, <span class="built_in">sizeof</span>(fd));  <span class="comment">// 注意差分数组初始化为 0</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s, &amp;e);</span><br><span class="line">        a.<span class="built_in">push_back</span>(s);</span><br><span class="line">        a.<span class="built_in">push_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    d.<span class="built_in">Make</span>(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="comment">// 第 i * 2 个元素是一个起点坐标， i * 2 + 1 是它的终点坐标</span></span><br><span class="line">        <span class="type">int</span> s = a[i &lt;&lt; <span class="number">1</span>], e = a[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// Loc找离散化后的序号，用序号做差分，[s,e) 左闭右开</span></span><br><span class="line">        fd[d.<span class="built_in">Loc</span>(s)] ++;</span><br><span class="line">        fd[d.<span class="built_in">Loc</span>(e)] --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>() - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">        <span class="comment">// 还原为点位值，fd[i]的值是 [ d[i], d[i+1] ) 这个左闭右开区间的覆盖次数</span></span><br><span class="line">        fd[i] += i == <span class="number">0</span> ? <span class="number">0</span> : fd[i - <span class="number">1</span>];</span><br><span class="line">        ans += (fd[i] &gt; <span class="number">0</span>)* (d[i + <span class="number">1</span>] - d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例过度种植">例：过度种植</h3>
<p>在笛卡尔平面坐标系中，有 <span class="math inline">\(N\)</span>
(<span class="math inline">\(1 \leq N \leq 1000\)</span>) 个矩形，第
<span class="math inline">\(i\)</span> 个矩形的左上角坐标是 <span
class="math inline">\((x_1,y_1)\)</span>，右下角坐标是 <span
class="math inline">\((x_2,y_2)\)</span>。求这 <span
class="math inline">\(N\)</span>
个矩形所覆盖的总面积（被重复覆盖的区域只计算一次）。</p>
<ul>
<li><p>第一行，一个整数 <span class="math inline">\(N\)</span> (<span
class="math inline">\(1 \leq N \leq 1000\)</span>)</p></li>
<li><p>接下来 <span class="math inline">\(N\)</span> 行，每行四个整数
<span class="math inline">\(x_1,y_1,x_2,y_2\)</span> (<span
class="math inline">\(-10^8 \leq x_1,y_1,x_2,y_2 \leq
10^8\)</span>)</p></li>
<li><p>输出一个整数，表示被覆盖的总面积</p></li>
</ul>
<p>输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0 5 4 1</span><br><span class="line">2 4 6 2</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<p>解题思路：</p>
<ol type="1">
<li>这是一个二维离散化问题，需要对 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 坐标分别进行离散化</li>
<li>使用二维差分记录每个小矩形的覆盖情况</li>
<li>统计被覆盖的小矩形的面积总和</li>
</ol>
<img src="/2025-04-03-20-%E7%A6%BB%E6%95%A3%E5%8C%96/%E7%9F%A9%E5%BD%A2%E7%A6%BB%E6%95%A3%E5%8C%96.svg" class="">
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TP_V&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Discretization</span> &#123;</span><br><span class="line">    std::vector&lt;TP_V&gt; b;</span><br><span class="line">    std::unordered_map&lt;TP_V, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;b.<span class="built_in">clear</span>(); mp.<span class="built_in">clear</span>();&#125;</span><br><span class="line">    <span class="built_in">Discretization</span>()&#123;<span class="built_in">Init</span>();&#125;</span><br><span class="line">    <span class="built_in">Discretization</span>(std::vector&lt;TP_V&gt; &amp;a)&#123;<span class="built_in">Make</span>(a);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Make</span><span class="params">(std::vector&lt;TP_V&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">        <span class="built_in">Add</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(std::vector&lt;TP_V&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : a) b.<span class="built_in">push_back</span>(i);</span><br><span class="line">        std::<span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        b.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i ++) mp[b[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    TP_V &amp;<span class="keyword">operator</span>[](<span class="type">int</span> ith)&#123;<span class="keyword">return</span> b[ith];&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Loc</span><span class="params">(TP_V x)</span> </span>&#123;<span class="keyword">return</span> mp.<span class="built_in">count</span>(x) ? mp[x] : <span class="number">-1</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储所有矩形的坐标</span></span><br><span class="line">    <span class="function">std::vector&lt;Rectangle&gt; <span class="title">rects</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; x_coords, y_coords;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;rects[i].x1, &amp;rects[i].y1, &amp;rects[i].x2, &amp;rects[i].y2);</span><br><span class="line">        x_coords.<span class="built_in">push_back</span>(rects[i].x1);</span><br><span class="line">        x_coords.<span class="built_in">push_back</span>(rects[i].x2);</span><br><span class="line">        y_coords.<span class="built_in">push_back</span>(rects[i].y1);</span><br><span class="line">        y_coords.<span class="built_in">push_back</span>(rects[i].y2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对x和y坐标分别进行离散化</span></span><br><span class="line">    <span class="function">Discretization&lt;<span class="type">int</span>&gt; <span class="title">dx</span><span class="params">(x_coords)</span>, <span class="title">dy</span><span class="params">(y_coords)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建二维差分数组</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">diff</span>(dx.<span class="built_in">size</span>(), std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(dy.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个矩形进行差分标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> loc_x1 = dx.<span class="built_in">Loc</span>(rects[i].x1);</span><br><span class="line">        <span class="type">int</span> loc_y1 = dy.<span class="built_in">Loc</span>(rects[i].y1);</span><br><span class="line">        <span class="type">int</span> loc_x2 = dx.<span class="built_in">Loc</span>(rects[i].x2);</span><br><span class="line">        <span class="type">int</span> loc_y2 = dy.<span class="built_in">Loc</span>(rects[i].y2);</span><br><span class="line">        <span class="comment">// 本题是直角坐标系，“左上”的y更大，“右下”的y更小</span></span><br><span class="line">        <span class="comment">// 调整为“左下”和“右上”，以便一个端点的xy坐标都比另一个端点的xy坐标小</span></span><br><span class="line">        std::<span class="built_in">swap</span>(loc_y1, loc_y2);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 二维差分：左上角+1，右上角-1，左下角-1，右下角+1</span></span><br><span class="line">        <span class="comment">// 最大坐标位置有哨兵（建diff的时候dx.size()和dy.size()都 + 1 了）</span></span><br><span class="line">        <span class="comment">// 参考差分章节的例子：</span></span><br><span class="line">        <span class="comment">// x方向差分：               x差分结果再进行y方向差分：</span></span><br><span class="line">        <span class="comment">// 0  0  0  0  0  0         0  0  0  0  0  0</span></span><br><span class="line">        <span class="comment">// 0  0  0  0  0  0         0 -1  0  0  0 +1</span></span><br><span class="line">        <span class="comment">// 0 +1  0  0  0 -1         0  0  0  0  0  0</span></span><br><span class="line">        <span class="comment">// 0 +1  0  0  0 -1  ===&gt;   0  0  0  0  0  0</span></span><br><span class="line">        <span class="comment">// 0 +1  0  0  0 -1         0 +1  0  0  0 -1</span></span><br><span class="line">        <span class="comment">// 0  0  0  0  0  0         0  0  0  0  0  0</span></span><br><span class="line">        <span class="comment">// PS：上“图”是按二维坐标系，(0,0)坐标在左下绘制，注意别混淆</span></span><br><span class="line">        <span class="comment">// 但注意：本题坐标是矩形端点，而不是方格，端点可以理解为左闭右开，不需要将端点序号加1</span></span><br><span class="line">        diff[loc_x1][loc_y1] ++; <span class="comment">// 左下 + 1</span></span><br><span class="line">        diff[loc_x2][loc_y1] --; <span class="comment">// 右下 - 1</span></span><br><span class="line">        diff[loc_x1][loc_y2] --; <span class="comment">// 左上 - 1</span></span><br><span class="line">        diff[loc_x2][loc_y2] ++; <span class="comment">// 右上 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dx.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; dy.<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>) diff[i][j] += diff[i][j<span class="number">-1</span>];   <span class="comment">// y方向差分恢复原值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dx.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; dy.<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) diff[i][j] += diff[i<span class="number">-1</span>][j];   <span class="comment">// x方向差分恢复原值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dx.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; dy.<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 统计答案</span></span><br><span class="line">            ans += <span class="number">1LL</span> * (diff[i][j] &gt; <span class="number">0</span>) * (dx[i<span class="number">+1</span>] - dx[i]) * (dy[j<span class="number">+1</span>] - dy[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>21.双指针（尺取）</title>
    <url>/2025-04-05-21-%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%88%E5%B0%BA%E5%8F%96%EF%BC%89/</url>
    <content><![CDATA[<h1 id="双指针尺取">双指针（尺取）</h1>
<p>通过两个（或多个）移动的标记，高效地探索或处理数据结构中的连续部分，以简化问题并加快求解速度，通常称为双指针、尺取或滑动窗口等。</p>
<span id="more"></span>
<h2 id="例单词背诵">例：单词背诵</h2>
<p>给一个单词表以及一个文章，要在文章里找包含单词表中单词最多的前提下最短的一段。</p>
<p>进一步解释：在文章中找到起点第 <span class="math inline">\(i\)</span>
个单词，终点第 <span class="math inline">\(j\)</span>
个单词，包含单词表中单词数量最多的<span
class="math inline">\([i,j]\)</span>
区间可能不唯一，找最短的那个区间。</p>
<p>输入 <span class="math inline">\(n\)</span> 然后 <span
class="math inline">\(n\)</span> 个单词的单词表，接着输入 <span
class="math inline">\(m\)</span> 然后 <span
class="math inline">\(m\)</span> 个单词的文章。</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">hot</span><br><span class="line">dog</span><br><span class="line">milk</span><br><span class="line">5</span><br><span class="line">hot</span><br><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">milk</span><br><span class="line">hot</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这道题有“包含最多”和“长度最短”两个要求，而“包含最多”的要求是优先的，这说明要不放弃任何一个包含的单词。</p>
<p>将起点 <span class="math inline">\(j\)</span> 和终点 <span
class="math inline">\(i\)</span> 设置为双指针， <span
class="math inline">\(i\)</span> 先走。</p>
<ol type="1">
<li><span class="math inline">\(i\)</span> 走一步：
<ul>
<li>文章第 <span class="math inline">\(i\)</span>
个单词是否是单词表里的单词</li>
<li>目前的 <span class="math inline">\([j,i]\)</span>
区间包含了这个单词几次</li>
</ul></li>
<li><span class="math inline">\(j\)</span> （可能）走多步：
<ul>
<li>文章第 <span class="math inline">\(j\)</span>
个单词如果不是单词表里的， <span class="math inline">\(j\)</span>
向前走一步</li>
<li>文章第 <span class="math inline">\(j\)</span>
个单词是单词表里的，且目前 <span class="math inline">\([j,i]\)</span>
区间包含不止一个， <span class="math inline">\(j\)</span>
向前走一步</li>
<li>文章第 <span class="math inline">\(j\)</span>
个单词是单词表里的，但目前 <span class="math inline">\([j,i]\)</span>
区间里只有 1 个，<span class="math inline">\(j\)</span>
停下，不再尝试往前走</li>
</ul></li>
<li>现在 <span class="math inline">\([j,i]\)</span>
包含单词数是否增多，<span
class="math inline">\([j,i]\)</span>长度（<code>i-j+1</code>）是否更短，更新答案</li>
<li>重复执行 1) ~ 3)</li>
</ol>
<p>关于是否包含、包含几个的问题，我们学过hash和字典树都可以很容易处理了，当然如果你已熟练掌握，那么现在可以用STL的<code>map</code>或<code>unorderd_map</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[maxn][<span class="number">21</span>], b[maxm][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a[i]);</span><br><span class="line">        mp[a[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp_cnt = <span class="number">0</span>, ans_cnt = <span class="number">0</span>, ans_len = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(b[i])) &#123;    <span class="comment">// map的count查询是否包含</span></span><br><span class="line">            mp[b[i]] ++;        <span class="comment">// 包含则计数+1</span></span><br><span class="line">            <span class="keyword">if</span>(mp[b[i]] == <span class="number">1</span>) &#123; <span class="comment">// 首次计入</span></span><br><span class="line">                tmp_cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(b[j])) &#123;    <span class="comment">// b[j] 是否在单词表中</span></span><br><span class="line">                <span class="keyword">if</span>(mp[b[j]] &gt; <span class="number">1</span>) &#123;  <span class="comment">// [j, i] 是否有不止一个</span></span><br><span class="line">                    mp[b[j]] --;    <span class="comment">// j要向前走，统计值减一</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;          <span class="comment">// [j,i] 只包含一个b[j]，不能丢掉它，结束本次循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j ++;                   <span class="comment">// j 向前走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp_cnt &gt;= ans_cnt) &#123;    <span class="comment">// 总结当前 [j,i] 区间对答案的更新</span></span><br><span class="line">            <span class="keyword">if</span>(tmp_cnt &gt; ans_cnt || i - j + <span class="number">1</span> &lt; ans_len) &#123;</span><br><span class="line">                ans_len = i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans_cnt = tmp_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>, ans_cnt, ans_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例挑选钻石">例：挑选钻石</h2>
<p>给定 <span class="math inline">\(N\)</span> 颗钻石的大小和一个整数
<span class="math inline">\(K\)</span>（<span class="math inline">\(N
\leq 50,000\)</span>, <span class="math inline">\(0 \leq K \leq
1,000,000,000\)</span>），你的任务是确定可以在两个展示柜中展示的最大钻石数量。如果两颗钻石的大小之差超过
<span
class="math inline">\(K\)</span>，则它们不能放在同一个展示柜中；若大小之差恰好为
<span class="math inline">\(K\)</span>，则可以放在同一个展示柜中。</p>
<p>分析：如果把 <span class="math inline">\(N\)</span>
个数排序，那么答案就是找两个不重叠的子串，每个子串最大值与最小值差不超过<span
class="math inline">\(K\)</span>，两个子串长度之和最大的方案。</p>
<p>在排序后，先考虑找一个这样的子串的最大方案怎么找：双指针保持 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span> 的价值之差不超过 <span
class="math inline">\(K\)</span>，统计最长的一段。</p>
<p>考虑找两个不重叠的：如果对任意划分界限，界限左边找一段最长的，界限右边也找一段最长的，最优方案一定在某一个界限时得到。</p>
<p>需要快速知道确定界限时，左边和右边各自的最优解。</p>
<ul>
<li>从左往右双指针一遍：记录每个位置作为界限，左边的最优解</li>
<li>从右往左双指针一遍：记录每个位置作为界限，右边的最优解</li>
<li>枚举界限，把左右最优解加起来，找全局最优</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k, a[maxn], l_max[maxn], r_max[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="built_in">memset</span>(l_max, <span class="number">0</span>, <span class="built_in">sizeof</span>(l_max));</span><br><span class="line">    <span class="built_in">memset</span>(r_max, <span class="number">0</span>, <span class="built_in">sizeof</span>(r_max));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++) &#123;        <span class="comment">// 双指针较快的 i</span></span><br><span class="line">        <span class="keyword">for</span>(;j &lt; i &amp;&amp; a[i] - a[j] &gt; k; j ++);   <span class="comment">// 双指针跟随的 j，保持在刚刚好不超过 K 的最远位置</span></span><br><span class="line">        <span class="comment">// 以 i 为界限的左边最优解，应当是 “以 i 为结尾的新方案” 和 “之前的方案” 的最优的那个</span></span><br><span class="line">        l_max[i] = std::<span class="built_in">max</span>(i &gt; <span class="number">0</span> ? l_max[i - <span class="number">1</span>] : <span class="number">0</span>, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右往左同理，处理好坐标方向和边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>, j = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">for</span>(;j &gt; i &amp;&amp; a[j] - a[i] &gt; k; j --);</span><br><span class="line">        r_max[i] = std::<span class="built_in">max</span>(i &lt; n - <span class="number">1</span> ? r_max[i + <span class="number">1</span>] : <span class="number">0</span>, j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在每个位置作为界限尝试</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, l_max[i] + r_max[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>界限往右的预处理也可以省略：如果已经得到了任意界限左边的最优解（不一定是以界限为结尾的解），从界限出发往右找最远位置，与界限左边的最优解合起来也就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k, a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, l_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(;j &lt; i &amp;&amp; a[i] - a[j] &gt; k; j ++);                       <span class="comment">// [j,i]</span></span><br><span class="line">        l_max = std::<span class="built_in">max</span>(l_max, i - j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(; r &lt; n &amp;&amp; i &lt; n - <span class="number">1</span> &amp;&amp; a[r] - a[i + <span class="number">1</span>] &lt;= k; r ++);    <span class="comment">// [i+1, r-1]</span></span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, r - i - <span class="number">1</span> + l_max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>22.单调栈</title>
    <url>/2025-04-05-22-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h1 id="单调栈">单调栈</h1>
<p>栈内元素保持单调递增或单调递减的顺序，常用于解决"寻找最近的比当前元素大/小的元素"这类问题。</p>
<span id="more"></span>
<p>设栈 <span class="math inline">\(S\)</span> 中元素为 <span
class="math inline">\(S_1, S_2, ..., S_k\)</span>，其中 <span
class="math inline">\(S_1\)</span> 为栈底元素，<span
class="math inline">\(S_k\)</span> 为栈顶元素。</p>
<p>以单调递增栈为例，栈中元素满足:</p>
<p><span class="math inline">\(S_1 &lt; S_2 &lt; ... &lt;
S_k\)</span></p>
<p>当需要插入新元素 <span class="math inline">\(x\)</span> 时:</p>
<ul>
<li>当栈非空且 <span class="math inline">\(x &lt; S_k\)</span>
时，不断弹出栈顶元素</li>
<li>直到栈空或 <span class="math inline">\(x \geq S_k\)</span></li>
<li>将 <span class="math inline">\(x\)</span> 压入栈中</li>
</ul>
<p>通过这种方式，栈内元素始终保持单调性。每个元素最多入栈和出栈各一次，因此单调栈的时间复杂度为
<span class="math inline">\(O(n)\)</span>。</p>
<h2 id="例看到牛头">例：看到牛头</h2>
<p>第 <span class="math inline">\(i\)</span> 头牛在队尾，第 <span
class="math inline">\(N\)</span>
头牛在队头，一个牛能向前看到连续的比它矮的牛的牛头，直到有一头牛比它高，再往前的牛头就看不到了。</p>
<p>求每头牛能看到的牛头的数量之和。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">    身高</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">15  |                          *</span><br><span class="line">    |                          |</span><br><span class="line">12  |  *                 *     |</span><br><span class="line">    |  |                 |     |</span><br><span class="line">10  |  |  *-------------&gt;|     |</span><br><span class="line">    |  |  |       4      |     |</span><br><span class="line">8   |  |  |        *     |     |</span><br><span class="line">    |  |  |  *     |     |     |</span><br><span class="line">6   |  |  |  |  *  |  *  |     |</span><br><span class="line">    |  |  |  |  |  |  |  |     |</span><br><span class="line">4   |  |  |  |  |  |  |  |  *  |</span><br><span class="line">    |  |  |  |  |  |  |  |  |  |</span><br><span class="line">2   |  |  |  |  |  |  |  |  |  |</span><br><span class="line">    +--+--+--+--+--+--+--+--+--+---&gt; 位置</span><br><span class="line">    1  2  3  4  5  6  7  8  9  10</span><br></pre></td></tr></table></figure>
<p>要快速计算每头牛的“视野”，就要快速知道它前面恰好比它高的最近的那个位置</p>
<p>维护一个单调栈，从<span
class="math inline">\(N\)</span>（队头）开始，序号从大到小逐个处理每头牛身高。</p>
<p>对第 <span class="math inline">\(i\)</span> 头牛身高
<code>h[i]</code>，栈里小于
<code>h[i]</code>的都出栈，直到栈空或遇到一个比 <code>h[i]</code>
高的，这就是挡住第 <span class="math inline">\(i\)</span>
头牛视线的牛，它俩之间就是 <span class="math inline">\(i\)</span>
能看到的牛头个数。而栈里比 <code>h[i]</code> 低的这些，不会影响到 <span
class="math inline">\(j &lt; i\)</span> 那些牛的视野，所以出栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">8e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, h[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; h[st.<span class="built_in">top</span>()] &lt; h[i]) &#123;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans += st.<span class="built_in">empty</span>() ? n - i - <span class="number">1</span> : st.<span class="built_in">top</span>() - i - <span class="number">1</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例最大的矩形纸片">例：最大的矩形纸片</h2>
<p><span class="math inline">\(N\)</span>
列，每列给出高度，求最大内部矩形</p>
<img src="/2025-04-05-22-%E5%8D%95%E8%B0%83%E6%A0%88/rec.svg" class="">
<p>分析：每个柱子往一个方向延申，不一定是最优解。最大矩形至少在一根柱子上是抵到顶部的，考虑枚举每个柱子作为抵到顶部的柱子，看往左往右两个方向能延申多远。对于一个方向，单调栈已经可以搞定了，无非就是两个方向分别做一次单调栈。</p>
<p>对于这道题，单调栈维护的是栈底更低、栈顶更高的柱子，对每个位置 <span
class="math inline">\(i\)</span>，栈里比它高的都出栈——因为朝这个方向，比它高的不会影响延申，直到栈空或遇到比它低的，就是延申最远位置了，然后将
<span class="math inline">\(i\)</span> 的高度入栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, h[maxn], l_max[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; st_l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st_l.<span class="built_in">empty</span>() &amp;&amp; h[st_l.<span class="built_in">top</span>()] &gt;= h[i]) &#123;</span><br><span class="line">            st_l.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以 i 为高度往左延申最大矩形长度</span></span><br><span class="line">        l_max[i] = st_l.<span class="built_in">empty</span>() ? i + <span class="number">1</span> : i - st_l.<span class="built_in">top</span>(); </span><br><span class="line">        st_l.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; st_r;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st_r.<span class="built_in">empty</span>() &amp;&amp; h[st_r.<span class="built_in">top</span>()] &gt;= h[i]) &#123;</span><br><span class="line">            st_r.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以 i 为高度往右延申最大矩形长度</span></span><br><span class="line">        <span class="type">int</span> r_max = st_r.<span class="built_in">empty</span>() ? n - i : st_r.<span class="built_in">top</span>() - i;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, <span class="number">1LL</span> * (r_max + l_max[i] - <span class="number">1</span>) * h[i]);        </span><br><span class="line">        st_r.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>23.单调队列</title>
    <url>/2025-04-05-23-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="单调队列">单调队列</h1>
<p>单调队列是一种特殊的队列结构，通过维护队列元素的单调性（递增或递减），可以在O(1)时间内得到一段区间内的最值。</p>
<span id="more"></span>
<p>为了维护单调性，通常需要两端都能出队，所以严格意义上说，它并不是一个数据结构定义中的“队列”。
STL 中有一个很方便的容器 <code>deque</code> 来实现双端队列。</p>
<p>单调队列经常与双指针（尺取）一起使用。</p>
<h2 id="例扫描">例：扫描</h2>
<p><span class="math inline">\(n\)</span> 个数，长度为 <span
class="math inline">\(k\)</span> 的区间从左往右扫过去，输出每一步长度为
<span class="math inline">\(k\)</span> 的区间内的最大值</p>
<p>分析：</p>
<p>右边入队、左边出队，可以在队列里维护 <span
class="math inline">\(k\)</span>
区间的数据，但这样还解决不了最大值问题。</p>
<p>要让这个队的右边也出队：在右边新元素入队前，右边比新元素小的都出队。因为随着
<span class="math inline">\(k\)</span>
区间移动，先入队的肯定先出队，那么先入队却又比右边即将入队元素小的那些已经无“出头之日”了，没必要放在队列里。</p>
<p>这样成功维护了一个左大右小的单调队列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k, a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="comment">// 左边 超出以 i 为右端的 k 区间的元素出队</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; i - q.<span class="built_in">back</span>() + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右边比 a[i] 小的出队</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; a[q.<span class="built_in">front</span>()] &lt; a[i]) &#123;</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_front</span>(i);</span><br><span class="line">        <span class="comment">// 队内最左边的是当前 $k$ 区间最大值</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[q.<span class="built_in">back</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>24.分块</title>
    <url>/2025-04-05-24-%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<h1 id="分块">分块</h1>
<p>字面意思，把数据分成一块一块去处理。</p>
<p>比如数据存在一段一段连续的相同值时，把相同的值看作一个的"块"，从而快速跳过。</p>
<p>比如把要经常批量处理的数据分成一个一个的块，在批量处理时，整个被覆盖的块做整体处理，没整个覆盖的再挨个处理。</p>
<span id="more"></span>
<p>分块首先是一种思想，其次可以用一些套路代码。</p>
<p>作为一种思想，一些问题可以不显式的去做某种代码结构，而是灵活地将数据分块处理即可。</p>
<p>还有一些时候，可以将数据模式化地分块，然后处理一些区间操作与查询。</p>
<h2 id="例立方根">例：立方根</h2>
<p>给定 <span class="math inline">\(q\)</span>
个询问，每个询问给出一个正整数 <span
class="math inline">\(x\)</span>，求所有不大于<span
class="math inline">\(x\)</span>的数的立方根向下取整之和：</p>
<p><span class="math inline">\(\sum_{j=1}^{x} \lfloor \sqrt[3]{j}
\rfloor\)</span></p>
<p>其中 <span class="math inline">\(\lfloor x \rfloor\)</span> 表示对
<span class="math inline">\(x\)</span> 向下取整。</p>
<p>题目按从小到大的顺序给出这些 <span
class="math inline">\(x\)</span></p>
<p>分析：<span class="math inline">\(x\)</span>范围很大，挨个枚举不大于
<span class="math inline">\(x\)</span>
的数必超时。但"立方根向下取整"的值其实是一段一段相同的值组成的，比如<span
class="math inline">\(1\sim 10\)</span> 的立方根是 <span
class="math inline">\(1,1,1,1,1,1,1,2,2,2\)</span>，把立方根相同的一段段数看作一个又一个的"块"，块内相同的值乘以块的长度，就能大跨步计算立方根向下取整之和。</p>
<p>这道题又按从小到大顺序给 <span
class="math inline">\(x\)</span>，那么也不用开数组存前缀结果了，保存之前计算过的最后一块即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cube</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> q, x, last_3 = <span class="number">0</span>, last_3_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">for</span>(;<span class="built_in">cube</span>(last_3 + <span class="number">1</span>) &lt;= x; last_3 ++) &#123;</span><br><span class="line">            last_3_sum += (<span class="built_in">cube</span>(last_3 + <span class="number">1</span>) - <span class="built_in">cube</span>(last_3)) * last_3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, last_3_sum + (x - <span class="built_in">cube</span>(last_3) + <span class="number">1</span>) * last_3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例开关">例：开关</h2>
<p>有 <span class="math inline">\(n\)</span> 盏灯，初始状态均为关闭。有
<span class="math inline">\(m\)</span>
次操作，每次操作为以下两种之一：</p>
<ol type="1">
<li>区间翻转：将区间 <span class="math inline">\([a,b]\)</span>
内的灯状态全部翻转</li>
<li>区间查询：统计区间 <span class="math inline">\([a,b]\)</span>
内开启的灯数量</li>
</ol>
<h3 id="输入">输入</h3>
<p>第一行：两个整数 <span class="math inline">\(n,m\)</span>
(灯的数量和操作次数)</p>
<p>接下来 <span class="math inline">\(m\)</span> 行：每行三个整数 <span
class="math inline">\(c,a,b\)</span></p>
<ul>
<li><span class="math inline">\(c=0\)</span>：区间翻转操作</li>
<li><span class="math inline">\(c=1\)</span>：区间查询操作</li>
<li><span class="math inline">\([a,b]\)</span>：操作区间范围</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">0 1 2</span><br><span class="line">0 2 4</span><br><span class="line">1 2 3</span><br><span class="line">0 2 4</span><br><span class="line">1 1 4</span><br></pre></td></tr></table></figure>
<h3 id="输出">输出</h3>
<p>对每个查询操作输出一行，表示区间内开启的灯数量</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>显然一个一个去操作会很慢，但不同的区间会重叠，整体操作又难处理多次重叠的地方。</p>
<p>分块是对挨个操作和整体操作的折衷：将数据分成特定大小的一块一块，标记好块对应的区域。</p>
<p>更新操作：</p>
<ul>
<li><span class="math inline">\([a,b]\)</span>
区间完整覆盖某一块时，给这一块打个标记，表示整块都异或过一次，这一块的和应该变为块大小减去上一次的和</li>
<li><span class="math inline">\([a,b]\)</span>
区间没有完整覆盖某一块，但有交集，暴力更新这一块的每一个元素，但记得更新之前先应用曾经对整块打过的标记</li>
</ul>
<p>查找操作：</p>
<ul>
<li><span class="math inline">\([a,b]\)</span>
区间完整覆盖某一块时，直接累加这一块的和</li>
<li><span class="math inline">\([a,b]\)</span>
区间没有完整覆盖某一块，但有交集，暴力查询这一块的每个元素，也记得先应用曾经对整块打过的标记</li>
</ul>
<p>假设分块的大小是 <span class="math inline">\(\sqrt{n}\)</span>
，那么块的个数也是 <span
class="math inline">\(\sqrt{n}\)</span>。对于每个 <span
class="math inline">\([a,b]\)</span>，遍历所有块是 <span
class="math inline">\(\sqrt{n}\)</span>，至多首尾两个地方是部分覆盖，暴力处理
<span class="math inline">\(2\)</span> 个块，每个块内部 <span
class="math inline">\(\sqrt{n}\)</span> 个元素，所以处理每个 <span
class="math inline">\([a,b]\)</span> 的复杂度从 <span
class="math inline">\(O(n)\)</span>（最坏情况）降低到 <span
class="math inline">\(O(\sqrt{n})\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> block_size = <span class="built_in">sqrt</span>(maxn);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    <span class="type">int</span> l;              <span class="comment">// 块的左起点</span></span><br><span class="line">    <span class="type">int</span> tag;            <span class="comment">// 对整块的操作标记（避免挨个处理）</span></span><br><span class="line">    <span class="type">int</span> sum;            <span class="comment">// 块内1的个数</span></span><br><span class="line">&#125;;</span><br><span class="line">Block bl[block_size + <span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> n, m, c, a, b, bn;</span><br><span class="line"><span class="type">bool</span> sta[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bn; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> r = bl[i].l + block_size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(bl[i].l &gt;= a &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">            <span class="comment">// 整块都在覆盖内</span></span><br><span class="line">            bl[i].tag ^= <span class="number">1</span>;</span><br><span class="line">            bl[i].sum = block_size - bl[i].sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(bl[i].l &lt;= a &amp;&amp; a &lt;= r || bl[i].l &lt;= b &amp;&amp; b &lt;= r) &#123;</span><br><span class="line">            <span class="comment">// 部分覆盖，挨个处理</span></span><br><span class="line">            bl[i].sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; block_size; j ++) &#123;</span><br><span class="line">                sta[bl[i].l + j] ^= bl[i].tag;   <span class="comment">// 先应用之前记录的 tag</span></span><br><span class="line">                <span class="keyword">if</span>(bl[i].l + j &gt;= a &amp;&amp; bl[i].l + j &lt;= b) &#123;</span><br><span class="line">                    sta[bl[i].l + j] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bl[i].sum += sta[bl[i].l + j];   <span class="comment">// 重新统计块内和</span></span><br><span class="line">            &#125;</span><br><span class="line">            bl[i].tag = <span class="number">0</span>;  <span class="comment">// 每个元素都已最新，tag清空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bn; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> r = bl[i].l + block_size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(bl[i].l &gt;= a &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">            ans += bl[i].sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(bl[i].l &lt;= a &amp;&amp; a &lt;= r || bl[i].l &lt;= b &amp;&amp; b &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; block_size; j ++) &#123;</span><br><span class="line">                sta[bl[i].l + j] ^= bl[i].tag;  <span class="comment">// 先应用之前记录的 tag，易忘，重视！！</span></span><br><span class="line">                ans += bl[i].l + j &gt;= a &amp;&amp; bl[i].l + j &lt;= b ? sta[bl[i].l + j] : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bl[i].tag = <span class="number">0</span>;   <span class="comment">// 每个元素都已最新，tag清空，易忘，重视！！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(bl, <span class="number">0</span>, <span class="built_in">sizeof</span>(bl));</span><br><span class="line">    <span class="built_in">memset</span>(sta, <span class="number">0</span>, <span class="built_in">sizeof</span>(sta));</span><br><span class="line">    bn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += block_size) &#123;</span><br><span class="line">        bl[bn ++].l = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;c, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">Update</span>(a, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Query</span>(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启发">启发</h2>
<p>不要把分块当作处理区间问题的套路，它更是一种数据处理思想。毕竟区间数据处理有更高级的上位算法线段树，在那之后，处理这类区间问题时，并不会经常用分块。</p>
<p>掌握分块思想，应注重于在面对问题时，善于发现数据潜在特点，分块提升效率。</p>
<blockquote>
<p>未来前瞻：数论分块</p>
</blockquote>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>25.倍增与稀疏表</title>
    <url>/2025-04-05-25-%E5%80%8D%E5%A2%9E%E4%B8%8E%E7%A8%80%E7%96%8F%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="倍增与稀疏表st表">倍增与稀疏表（ST表）</h1>
<p>倍增思想的核心在于通过预处理每个状态的跳跃步长（如2的幂次），将线性时间的操作优化为对数时间。其关键在于构建一个跳跃表，每个位置存储跳跃不同<span
class="math inline">\(2^k\)</span>步后的结果。对于多次跳跃问题，将总步数分解为若干2的幂次之和，逐次跳跃即可高效求解。</p>
<span id="more"></span>
<h2 id="倍增思想">倍增思想</h2>
<p>纸币有1元、5元、10元、50元、100元的面额，用于方便地凑成任意金额。</p>
<p>在编程思维中，<span class="math inline">\(2^0, 2^1, 2^2, \dots
2^k\)</span> 可以方便地凑成任意 <span
class="math inline">\(2^{k+1}\)</span>
以内的数（更大的也能凑，但是没那么方便快捷），甚至每个额度只需要出现一次。</p>
<p>随便考虑一个数： <span
class="math inline">\(12\)</span>，它的二进制形式是
<code>1100</code>，二进制的每一位都对应一个<span
class="math inline">\(2^{x}\)</span>，即可以由若干个不重复的<span
class="math inline">\(2^{x}\)</span>凑成。每个整数都可以表达成二进制，所以以上结论显然。</p>
<p>在一些问题中，解存在<strong>某种特定关系</strong>，或许能允许我们<strong>以相对较小的代价</strong>预处理出变量（或偏移量）为
<span class="math inline">\(2^0, 2^1, 2^2, \dots 2^k\)</span>
的结果，从而快速地拼凑任意变量（或偏移量）对应的结果，这就是<strong>倍增思想</strong>。</p>
<h3 id="例变化的数">例：变化的数</h3>
<p>一个数<span class="math inline">\(a\)</span>，每变化一次，就增加
<span class="math inline">\(\lfloor \max (|sin(a)|, |cos(a)|) * 20
\rfloor\)</span>.</p>
<p>用C语言可以这样完成变化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Nexa</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + (<span class="type">int</span>)(std::<span class="built_in">max</span>(<span class="built_in">fabs</span>(<span class="built_in">sin</span>(a)), <span class="built_in">fabs</span>(<span class="built_in">cos</span>(a))) * <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求它变化 <span class="math inline">\(m\)</span> 次的值.</p>
<p>第一行数据组数 <span class="math inline">\(1 \leq t \leq 5 *
10^{4}\)</span>，接下来 <span class="math inline">\(t\)</span>
行数据，每行 <span class="math inline">\(1 \leq a, m \leq 5 *
10^{4}\)</span> 表示将 <span class="math inline">\(a\)</span> 变化 <span
class="math inline">\(m\)</span> 次.</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">8 15</span><br><span class="line">8 9</span><br><span class="line">3 7</span><br><span class="line">11 10</span><br><span class="line">17 14</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">264</span><br><span class="line">162</span><br><span class="line">133</span><br><span class="line">184</span><br><span class="line">256</span><br></pre></td></tr></table></figure>
<p>如果<span class="math inline">\(m\)</span>步慢慢模拟，<span
class="math inline">\(t\)</span>组数据每组<span
class="math inline">\(m\)</span>步就超时了。</p>
<p>如果有每个点走<span
class="math inline">\(2^{0},2^{1},\dots\)</span>步能到达的地方的信息，那么走<span
class="math inline">\(m\)</span>步就会减少到走 <span
class="math inline">\(log_{2}m\)</span>步。</p>
<img src="/2025-04-05-25-%E5%80%8D%E5%A2%9E%E4%B8%8E%E7%A8%80%E7%96%8F%E8%A1%A8/mult1.svg" class="">
<p>这不仅需要知道第 1 个点的各<span
class="math inline">\(2^i\)</span>步到达位置，而是要知道每一个点的各个<span
class="math inline">\(2^i\)</span>步到达的位置</p>
<p>如下图，一个点的绿、蓝、红、紫线路对应<span
class="math inline">\(2^{0},2^{1},,2^{2},2^{3}\)</span> 步</p>
<img src="/2025-04-05-25-%E5%80%8D%E5%A2%9E%E4%B8%8E%E7%A8%80%E7%96%8F%E8%A1%A8/mult2.svg" class="">
<p>如果想从起点走 6 步，就先走 1
步红线，到达一个点，然后需要知道这个点的 1 步蓝线，到达目的地。</p>
<img src="/2025-04-05-25-%E5%80%8D%E5%A2%9E%E4%B8%8E%E7%A8%80%E7%96%8F%E8%A1%A8/mult3.svg" class="">
<p>只要知道<strong>所有点的所有<span
class="math inline">\(2^{0},2^{1},,2^{2},\dots\)</span></strong>
步能到达的位置，就可以在 <span
class="math inline">\(log_{2}m\)</span>时间快速计算从任意点出发走<span
class="math inline">\(m\)</span>步到达的位置。</p>
<img src="/2025-04-05-25-%E5%80%8D%E5%A2%9E%E4%B8%8E%E7%A8%80%E7%96%8F%E8%A1%A8/mult4.svg" class="">
<p>预处理这个信息也有技巧：</p>
<ul>
<li>从每个点出发走 <span class="math inline">\(1\)</span>
步能到的地方，用一个循环处理出来；</li>
<li>从每个点出发走 <span class="math inline">\(2\)</span>
步能到的地方，可以由它走<span
class="math inline">\(1\)</span>步到某个点，该点再走<span
class="math inline">\(1\)</span>步到达，而每个点的<span
class="math inline">\(1\)</span>步到达位置此时已知；</li>
<li>从每个点出发走 <span class="math inline">\(4\)</span>
步能到的地方，可以由它走<span
class="math inline">\(2\)</span>步到某个点，该点再走<span
class="math inline">\(2\)</span>步到达，而每个点的<span
class="math inline">\(2\)</span>步到达位置此时已知；</li>
<li>……</li>
</ul>
<p>以上每一步都遍历一遍所有点，共遍历 <span
class="math inline">\(k\)</span> 次，<span
class="math inline">\(k\)</span> 就是需要预处理的最大的 <span
class="math inline">\(2^{k}\)</span> 步的 <span
class="math inline">\(k\)</span>，假设点个数是 <span
class="math inline">\(n\)</span>，<span class="math inline">\(2^k\approx
n\)</span>，所以这个预处理过程是<span
class="math inline">\(O(nlogn)\)</span>的。</p>
<p>回到题目，一个数<span
class="math inline">\(a\)</span>，每变化一次，就增加 <span
class="math inline">\(\lfloor \max (|sin(a)|, |cos(a)|) * 20
\rfloor\)</span>，它每次至多增加<span
class="math inline">\(20\)</span>，由于<span class="math inline">\(1
\leq a, m \leq 5 * 10^{4}\)</span>，那么这道题最大范围就是 <span
class="math inline">\(5 * 10^4 + 20 * 5 * 10^4 \approx 10^6\)</span></p>
<p>预处理这样做</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxa = <span class="number">2e5</span> + <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxmt = <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> mt[maxa][maxmt];    <span class="comment">// maxa 表示起点的可能性数， maxmt 表示最多处理到 2^maxmt 步</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitMt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; maxa; j ++) &#123;</span><br><span class="line">        mt[j][<span class="number">0</span>] = <span class="built_in">Nexa</span>(j);     <span class="comment">// 初始化走 1 步（即 2^0 步）的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxmt; i ++) &#123;       <span class="comment">// 枚举步长，i 表示 2^i 步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; maxa; j ++) &#123;    <span class="comment">// 枚举起点</span></span><br><span class="line">            <span class="comment">// 利用 2^&#123;i-1&#125; 的信息推算每个 j 位置走 2^i 步的值</span></span><br><span class="line">            <span class="keyword">if</span>(mt[j][i - <span class="number">1</span>] &gt;= maxa) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 超出题目可能的范围，这部分不用计算</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 位置 j 出发走 2^i 步到的位置，可以从 mt[j][i - 1] 出发走 2^&#123;i-1&#125; 步到达</span></span><br><span class="line">            <span class="comment">// mt[*][i - 1] 已由上一轮循环计算好了</span></span><br><span class="line">            mt[j][i] = mt[mt[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 <span class="math inline">\(a\)</span> 出发走 <span
class="math inline">\(m\)</span> 步，就可以拆解成走 <span
class="math inline">\(m\)</span> 的各个二进制位对应的步数。</p>
<p>比如 <span class="math inline">\(m =
7\)</span>，它的最高二进制位就是第 <span class="math inline">\(\lfloor
log_{2}7 \rfloor=2\)</span> 位，第一步就可以走 <span
class="math inline">\(2^2\)</span> 步，对应预处理的表就是
<code>mt[a][2]</code> ，表示从 <span class="math inline">\(a\)</span>
出发走 <span class="math inline">\(2^{2} = 4\)</span> 步到达的位置。</p>
<p>更新位置<code>a = mt[a][2]</code>，准备走下一步，那么还剩下 <span
class="math inline">\(7 - 2^2 = 3\)</span>
步，从刚到达的位置出发，进行下一轮计算。</p>
<p>二进制计算有一些加速的 <code>__builtin_***</code>
函数可以用，这里可以代替 <code>(int)log2(x)</code> 得到更好性能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fastlog</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// log2函数较慢，利用 int 二进制位数高效地计算 (int)log2(x)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">31</span> - __builtin_clz(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m) &#123;</span><br><span class="line">    <span class="type">int</span> lg = <span class="built_in">Fastlog</span>(m);    <span class="comment">// 找距离 m 最近的 2^&#123;lg&#125; 的 lg</span></span><br><span class="line">    a = mt[a][lg];          <span class="comment">// 走 2^&#123;lg&#125; 步</span></span><br><span class="line">    m -= <span class="number">1</span> &lt;&lt; lg;           <span class="comment">// 减去走过的步数，位运算 1&lt;&lt;lg 就是2^&#123;lg&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变化的数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxa = <span class="number">2e5</span> + <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxmt = <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> mt[maxa][maxmt];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Nexa</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + (<span class="type">int</span>)(std::<span class="built_in">max</span>(<span class="built_in">fabs</span>(<span class="built_in">sin</span>(a)), <span class="built_in">fabs</span>(<span class="built_in">cos</span>(a))) * <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitMt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; maxa; j ++) &#123;</span><br><span class="line">        mt[j][<span class="number">0</span>] = <span class="built_in">Nexa</span>(j);     <span class="comment">// 初始化走 1 步（即 2^0 步）的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxmt; i ++) &#123;       <span class="comment">// 枚举步长，i 表示 2^i 步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; maxa; j ++) &#123;    <span class="comment">// 枚举起点</span></span><br><span class="line">            <span class="comment">// 利用 2^&#123;i-1&#125; 的信息推算每个 j 位置走 2^i 步的值</span></span><br><span class="line">            <span class="keyword">if</span>(mt[j][i - <span class="number">1</span>] &gt;= maxa) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 超出题目可能的范围，这部分不用计算</span></span><br><span class="line">            &#125;</span><br><span class="line">            mt[j][i] = mt[mt[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fastlog</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// log2函数较慢，利用 int 二进制位数高效地计算 (int)log2(x)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">31</span> - __builtin_clz(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t, a, m;</span><br><span class="line">    <span class="built_in">InitMt</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t); t --; ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;m);</span><br><span class="line">        <span class="keyword">while</span>(m) &#123;</span><br><span class="line">            <span class="type">int</span> lg = <span class="built_in">Fastlog</span>(m);    <span class="comment">// 找距离 m 最近的 2^&#123;lg&#125; 的 lg</span></span><br><span class="line">            a = mt[a][lg];          <span class="comment">// 走 2^&#123;lg&#125; 步</span></span><br><span class="line">            m -= <span class="number">1</span> &lt;&lt; lg;           <span class="comment">// 减去走过的步数，位运算 1&lt;&lt;lg 就是2^&#123;lg&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="稀疏表">稀疏表</h2>
<p>稀疏表用于解决<strong>可重复贡献问题</strong>。</p>
<p>对于 <span class="math inline">\(a&lt;b\)</span>， <span
class="math inline">\([l, b]\)</span>区间、<span
class="math inline">\([a, r]\)</span>区间以及<span
class="math inline">\([l, r]\)</span> 区间的一些计算：</p>
<ul>
<li>能重复贡献示例：区间最大值，<span class="math inline">\([l,
b]\)</span> 的最大值与 <span class="math inline">\([a, r]\)</span>
最大值较大的那个同时也是 <span class="math inline">\([l,r]\)</span>
的最大值， <span class="math inline">\([a,b]\)</span>
这个区间在最大值问题上就能重复贡献。</li>
<li>不能重复贡献示例： <span class="math inline">\([l, b]\)</span>
的和与 <span class="math inline">\([a, r]\)</span> 的和相加，不等于
<span class="math inline">\([l, r]\)</span>
的和，所以区间和就不能重复贡献。</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">                        [a,r] </span><br><span class="line">             /-------------^-------------\</span><br><span class="line">l            a            b               r</span><br><span class="line">-------------------------------------------</span><br><span class="line">\___________ ____________/</span><br><span class="line">            V</span><br><span class="line">          [l,b]</span><br></pre></td></tr></table></figure>
<p>区间最大/最小值（Range Maximum/Minimum Query,
RMQ）是典型的可重复贡献问题。</p>
<p>这个问题可以用倍增思想加速查询，预处理好每个点作为起点，它加<span
class="math inline">\(2^0, 2^{1},
2^{2},\dots\)</span>为终点的区间解，那么对于任意 <span
class="math inline">\([l, r]\)</span> 的查询，设 <span
class="math inline">\(b\)</span> 为 <span class="math inline">\(b = l +
2^{k} &lt;= r\)</span> 能达到的最大值， <span
class="math inline">\(a\)</span> 为 <span class="math inline">\(a +
2^{k} = r\)</span> 的值，那么 <span class="math inline">\([l,
b]\)</span> 和 <span class="math inline">\([a, r]\)</span> 就是 <span
class="math inline">\([l, l + 2^{k}]\)</span> 和 <span
class="math inline">\([r - 2^{k},
r]\)</span>，只要这个问题可重复贡献，这两个预处理过的答案合起来就是
<span class="math inline">\([l, r]\)</span> 的解。</p>
<p>预处理的过程也是倍增思想来。</p>
<h3 id="例多次查询区间最大值">例：多次查询区间最大值</h3>
<p>给定一个长度为 <span class="math inline">\(N\)</span> 的数列，和
<span class="math inline">\(M\)</span>
次询问，求出每一次询问的区间内数字的最大值。</p>
<p>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">0</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">8</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[maxn], st[maxn][<span class="number">22</span>];   <span class="comment">// 起点最大 maxn，预处理到  maxn + 2^&#123;20&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSt</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">        st[j][<span class="number">0</span>] = a[j];    <span class="comment">// 左闭右开区间理解， [j, j + 1) 就是长为 1 的区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">22</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n - (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)); j ++) &#123;</span><br><span class="line">            <span class="comment">// [j, j + 2^&#123;i-1&#125;) 与 [j + 2^&#123;i-1&#125;, j + 2^&#123;i&#125;) 合并 得到 [j, j + 2^&#123;i&#125;]</span></span><br><span class="line">            st[j][i] = std::<span class="built_in">max</span>(st[j][i - <span class="number">1</span>], st[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fastlog</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">31</span> - __builtin_clz(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 求左闭右开区间 [l, r)</span></span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">Fastlog</span>(r - l);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k)][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitSt</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Query</span>(l, r + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>26.动态规划入门</title>
    <url>/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="动态规划入门">动态规划入门</h1>
<ul>
<li>动态（Dynamic）：问题的解因时间或决策而变化</li>
<li>规划（Programming）：分解子问题，利用子问题之间关系求解</li>
</ul>
<span id="more"></span>
<h2 id="递推与带备忘递归">递推与带备忘递归</h2>
<p>数字三角形：从顶部出发，只能沿箭头走，到底部的哪个路线经过的所有数字之和最大</p>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2_%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.svg" class="">
<p>给每个格子编号</p>
<style>.qtxljvdcgezx{height: 300px;}</style>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2_%E7%BC%96%E5%8F%B7.svg" class="qtxljvdcgezx" title="给每个格子编号">
<p>思考 2 件事：</p>
<ol type="1">
<li><p><strong>最优子结构</strong>：数学化定义问题，分析该问题哪些更小规模的子问题的解可以直接影响它的解</p>
<ul>
<li>定义 <span class="math inline">\(d(i,j)\)</span> 是从 <span
class="math inline">\((i,j)\)</span> 出发到底的最大和</li>
<li>可知 <span class="math inline">\(d(1,1)\)</span> 是问题的最优解</li>
<li><span class="math inline">\(d(i,j)\)</span> 与 <span
class="math inline">\(d(i+1,j)\)</span>、<span
class="math inline">\(d(i+1,j+1)\)</span> 直接相关——有这俩就能确定 <span
class="math inline">\(d(i,j)\)</span></li>
</ul></li>
<li><p><strong>状态转移方程</strong>：对于特定规模的问题，能直接影响它的子问题以什么方式计算能推导到它</p>
<ul>
<li>设 <span class="math inline">\(a(i,j)\)</span> 是 <span
class="math inline">\((i,j)\)</span> 格子的值</li>
<li><span
class="math inline">\(d(i,j)=a(i,j)+\max(d(i+1,j),d(i+1,j+1))\)</span></li>
</ul></li>
</ol>
<p>动态规划的两种等价实现方法，渐进复杂度通常一致</p>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E9%80%92%E6%8E%A8%E4%B8%8E%E9%80%92%E5%BD%92.svg" class="" title="动态规划递推与递归">
<p><strong>自底向上的递推</strong></p>
<p>从小到大逐个解决子问题</p>
<p>优势：没有频繁的递归调用，常数更小</p>
<p>劣势：思维量——需要预先确定好子问题规模大小，即求解的顺序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) dp[n][j] = a[n][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --)    <span class="comment">// 自底向上递推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">            dp[i][j] = std::<span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自顶向下的带备忘递归</strong>（记忆化搜索）</p>
<p>对需要但尚未解决的子问题进行递归求解，否则直接返回备忘</p>
<p>优势：</p>
<ol type="1">
<li>思维量相对小，直接按状态转移方程实现</li>
<li>有的特殊情况下能跳过很多子问题</li>
</ol>
<p>劣势：递归开销，甚至面对有些过大的问题没有足够的递归栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DPS</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> &amp;ans = dp[i][j];</span><br><span class="line">    <span class="keyword">if</span>(ans != <span class="number">-1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    ans = std::<span class="built_in">max</span>(<span class="built_in">DPS</span>(i + <span class="number">1</span>, j), <span class="built_in">DPS</span>(i + <span class="number">1</span>, j + <span class="number">1</span>)) + a[i][j];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有向无环图dp">有向无环图DP</h2>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/DAG.svg" class="" title="有向无环图">
<p>有向无环图（Directed Acyclic
Graph，DAG）是指不存在环的有向图，从任意点出发沿有向边走，不会再回到该点。</p>
<p>很多动态规划问题可以转换为DAG上的最长/最短路或路径计数。</p>
<h3 id="例矩形嵌套">例：矩形嵌套</h3>
<p>给出一系列矩形的长和宽，矩形𝐴能够嵌套在𝐵内部当且仅当𝐴的长与宽都对应严格小于𝐵的长与宽，求这些矩形能够组成的最深嵌套</p>
<p>构建DAG：</p>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97_%E5%BB%BADAG.svg" class="" title="矩形嵌套建DAG">
<p><strong>最优子结构</strong>：</p>
<ul>
<li>"可嵌套"关系可以建模为图：<span class="math inline">\((i,j)\in
E\)</span>表示<span class="math inline">\(j\)</span>能嵌套在<span
class="math inline">\(i\)</span>内，有向边<span
class="math inline">\(i\rightarrow j\)</span>，该图是DAG</li>
<li><span class="math inline">\(d(i)\)</span>表示<span
class="math inline">\(i\)</span>为最外层时的最深嵌套，只与<span
class="math inline">\((i,j)\in E\)</span>的<span
class="math inline">\(j\)</span>有关</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li><span class="math inline">\(d(i)=\max\{d(j)+1|(i,j)\in
E\}\)</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DPS</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;ans = dp[i];</span><br><span class="line">    <span class="keyword">if</span>(ans != <span class="number">-1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    ans = <span class="number">1</span>;    <span class="comment">// 至少包含自身</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) </span><br><span class="line">        <span class="keyword">if</span>(g[i][j] &amp;&amp; <span class="built_in">DPS</span>(j) + <span class="number">1</span> &gt; ans)&#123;</span><br><span class="line">            ans = <span class="built_in">DPS</span>(j) + <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考：如果不止要求最深嵌套层数，还要求把最深嵌套的各个节点按顺序输出，怎么做？</p>
<p>提示：状态转移时记录转移方向</p>
<p>复杂度分析：</p>
<p>要填一个<code>dp[]</code>，有<span
class="math inline">\(O(n)\)</span>项。每一项要一个<span
class="math inline">\(O(n)\)</span>的循环才能得到最终结果，所以<span
class="math inline">\(O(n^2)\)</span>。</p>
<blockquote>
<p>知识点：动态规划的复杂度分析技巧。动态规划就是一个"填表游戏"，其复杂度就由表的大小和完成表的每一项最坏情况的复杂度决定。</p>
</blockquote>
<p>扩展题：有<span
class="math inline">\(n\)</span>种立方体（每种数量无限），选一些堆成尽可能高的柱子，上方的立方体底面长宽必须严格小于下方的立方体。</p>
<p>提示：立方体可以任选一个棱作为高，则另外两个棱构成底面长宽。</p>
<h2 id="区间dp">区间DP</h2>
<h3 id="例括号匹配">例：括号匹配</h3>
<p>给定一个只包含<code>&#123;&#125;</code>、<code>()</code>、<code>[]</code>的字符串
括号嵌套可能不合法，如"<code>&#123;(] )</code>"
给出添加符号最少的方案，使括号嵌套合法</p>
<p><strong>最优子结构</strong>：</p>
<ul>
<li><span class="math inline">\(d(i,j)\)</span> 表示 <span
class="math inline">\([i, j]\)</span>
这段符号的最优解，即最少添加使之合法的方案</li>
<li>可以从 3 个方向转移
<ul>
<li>左边加一个让 <span class="math inline">\(j\)</span> 匹配</li>
<li>右边加一个让 <span class="math inline">\(i\)</span> 匹配，</li>
<li>如果<span class="math inline">\(i\)</span>和<span
class="math inline">\(j\)</span>位置恰好匹配，那么不用加，让它俩匹配</li>
</ul></li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li><span class="math inline">\(d(i,j)=\begin{cases} \min(d(i+1,j-1),
d(i+1,j)+1, d(i,j-1)+1) &amp; \text{如果}s[i]\text{和}s[j]\text{匹配} \\
\min(d(i+1,j)+1, d(i,j-1)+1) &amp; \text{否则} \end{cases}\)</span></li>
</ul>
<h3 id="例矩阵链乘法">例：矩阵链乘法</h3>
<blockquote>
<p>还没学过线性代数的同学，可以简单了解下<strong>矩阵是什么，如何相乘</strong>：</p>
<ul>
<li>两个矩阵相乘，则第一个的列数必须等于第二个的行数，比如第一个 <span
class="math inline">\(a\times b\)</span>，第二个必须 <span
class="math inline">\(b\times c\)</span></li>
<li>矩阵相乘的结果是第一个的行数、第二个的列数，即<span
class="math inline">\(a\times b\)</span> 和 <span
class="math inline">\(b\times c\)</span> 两个矩阵相乘得到 <span
class="math inline">\(a \times c\)</span></li>
<li>相乘方式：结果矩阵的 <span class="math inline">\((i,j)\)</span>
位置的值，是前一个的第 <span class="math inline">\(i\)</span>
行与后一个的第 <span class="math inline">\(j\)</span>
列一一对应相乘再加起来的结果</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x[a][b], y[b][c], z[a][c];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j ++) &#123;</span><br><span class="line">        z[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; b; k ++) &#123;</span><br><span class="line">            z[i][j] += x[i][k] * y[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 两个矩阵的基本元素乘法次数也显而易见了</p>
</blockquote>
<p>计算<span class="math inline">\(n\)</span>个矩阵序列的乘积<span
class="math inline">\(A_1 A_2\cdots
A_n\)</span>，矩阵规模保证能够合法相乘。</p>
<p>矩阵乘满足结合律，任何加括号方法计算结果相同。不同加括号方式，元素相乘次数不同。求一个矩阵乘法次序，使得元素相乘次数最少。</p>
<p>例：<span class="math inline">\(\langle A_1,A_2,A_3
\rangle\)</span>规模分别为<span class="math inline">\(10\times
100\)</span>、<span class="math inline">\(100\times 5\)</span>、<span
class="math inline">\(5\times 50\)</span></p>
<ul>
<li><span class="math inline">\(((A_1 A_2 ) A_3)\)</span>：<span
class="math inline">\(10\cdot 100\cdot 5+10\cdot 5\cdot
50=7500\)</span>次</li>
<li><span class="math inline">\((A_1 (A_2 A_3))\)</span>：<span
class="math inline">\(100\cdot 5\cdot 50+10\cdot 100\cdot
50=75000\)</span>次</li>
</ul>
<p><strong>最优子结构</strong>：</p>
<ul>
<li>最后一次矩阵乘法可以发生在任意位置<span
class="math inline">\(k\)</span>，即<span
class="math inline">\((A_1\cdots A_k)(A_{k+1}\cdots A_n)\)</span></li>
<li><span class="math inline">\(d(i,j)\)</span>：<span
class="math inline">\(A_i A_{i+1}\cdots A_{j-1}
A_j\)</span>这一区间的最优解</li>
<li>每一个<span
class="math inline">\(k\)</span>作为该区间最后一次乘法，都是潜在的最优方案</li>
<li>对应子问题为<span class="math inline">\(d(i,k)\)</span>与<span
class="math inline">\(d(k+1,j)\)</span></li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li>设<span
class="math inline">\(p_0,p_1,\dots,p_n\)</span>是矩阵序列的规模，如<span
class="math inline">\(A_1\)</span>为<span
class="math inline">\(p_0\times p_i\)</span>，<span
class="math inline">\(A_i\)</span>为<span
class="math inline">\(p_{i-1}\times p_i\)</span></li>
<li><span class="math display">\[
d(i,j)=\begin{cases}
0 &amp; \text{如果}i=j \\
\min\limits_{i\leq k\leq j}\{d(i,k)+d(k+1,j)+p_{i-1}p_kp_j\} &amp;
\text{如果}i&lt;j
\end{cases}
\]</span></li>
</ul>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/%E7%9F%A9%E9%98%B5%E9%93%BE_%E6%9C%80%E5%90%8E%E4%B9%98%E6%B3%95%E4%BD%8D%E7%BD%AE.svg" class="" title="矩阵链_最后乘法位置">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DPS</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本情况：如果区间长度为1，不需要乘法</span></span><br><span class="line">    <span class="keyword">if</span>(l == r - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用引用减少重复代码，ans是dp[l][r]的引用，修改它就会修改dp[l][r]</span></span><br><span class="line">    <span class="type">int</span> &amp;ans = dp[l][r];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果已经计算过，直接返回结果（记忆化）</span></span><br><span class="line">    <span class="keyword">if</span>(ans != <span class="number">-1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化：设置为一个足够大的值，表示无穷大</span></span><br><span class="line">    ans = <span class="number">0x3f3f3f3f</span>;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试所有可能的最后一次乘法位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l + <span class="number">1</span>; i &lt; r; i ++)</span><br><span class="line">        <span class="comment">// 状态转移：dp[l][r] = min(dp[l][i] + dp[i][r] + p[l]*p[i]*p[r])</span></span><br><span class="line">        <span class="comment">// 其中p[l]*p[i]*p[r]是最后一次乘法的代价</span></span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, <span class="built_in">DPS</span>(l, i) + <span class="built_in">DPS</span>(i, r) + p[l] * p[i] * p[r]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回区间[l,r]的最优解</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递推也可以写，分析计算顺序，大区间依赖小区间，那么按区间从小到大计算就可以写递推式DP了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化：单个矩阵不需要乘法，所以dp[i][i] = 0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    dp[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一重循环：枚举子问题大小，从小到大处理子问题</span></span><br><span class="line"><span class="comment">// 从长度为2的区间开始，一直到长度为n的区间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++) &#123;</span><br><span class="line">    <span class="comment">// 第二重循环：枚举子问题的起点</span></span><br><span class="line">    <span class="comment">// 对于每个长度，计算所有可能的起点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n - len + <span class="number">1</span>; l ++) &#123;</span><br><span class="line">        <span class="comment">// 计算子问题的终点</span></span><br><span class="line">        <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化dp[l][r]为一种可能的方案：将第一个矩阵与剩余矩阵相乘</span></span><br><span class="line">        dp[l][r] = dp[l + <span class="number">1</span>][r] + <span class="number">1LL</span> * p[l - <span class="number">1</span>] * p[l] * p[r];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第三重循环：枚举最后一次矩阵乘法发生的位置</span></span><br><span class="line">        <span class="comment">// 尝试所有可能的切分点，找到最优解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l + <span class="number">1</span>; i &lt; r; i ++)</span><br><span class="line">            <span class="comment">// 状态转移：dp[l][r] = min(dp[l][i] + dp[i+1][r] + p[l-1]*p[i]*p[r])</span></span><br><span class="line">            <span class="comment">// 其中p[l-1]*p[i]*p[r]是最后一次乘法的代价</span></span><br><span class="line">            dp[l][r] = std::<span class="built_in">min</span>(</span><br><span class="line">                dp[l][r], </span><br><span class="line">                dp[l][i] + dp[i + <span class="number">1</span>][r] + p[l - <span class="number">1</span>] * p[i] * p[r]</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背包dp">背包DP</h2>
<h3 id="例完全背包">例：完全背包</h3>
<p>有<span class="math inline">\(n\)</span>种物品，每种物品<span
class="math inline">\(i \in [1,n]\)</span>的重量<span
class="math inline">\(w_i\)</span>，价值<span
class="math inline">\(v_i\)</span>，数量不限。有一个背包可装总重不超过<span
class="math inline">\(b\)</span>的物品，求背包能装物品的最大总价值。</p>
<p>例：</p>
<p><span class="math inline">\(n=4\)</span>，<span
class="math inline">\(b=10\)</span></p>
<p><span class="math inline">\(v_1=1\)</span>，<span
class="math inline">\(v_2=3\)</span>，<span
class="math inline">\(v_3=6\)</span>，<span
class="math inline">\(v_4=9\)</span></p>
<p><span class="math inline">\(w_1=2\)</span>，<span
class="math inline">\(w_2=3\)</span>，<span
class="math inline">\(w_3=4\)</span>，<span
class="math inline">\(w_4=7\)</span></p>
<p><strong>最优子结构</strong>：</p>
<ul>
<li><span class="math inline">\(k\)</span>：只考虑前<span
class="math inline">\(k\)</span>种物品</li>
<li><span class="math inline">\(y\)</span>：背包装物品总重限制到<span
class="math inline">\(y\)</span> (<span class="math inline">\(y \leq
b\)</span>)</li>
<li><span class="math inline">\(d(k,y)\)</span>：前<span
class="math inline">\(k\)</span>种物品装入容量<span
class="math inline">\(y\)</span>的背包的最优解</li>
<li><span class="math inline">\(d(k,y)\)</span>只与<span
class="math inline">\(d(k,y-w_k)\)</span>和<span
class="math inline">\(d(k-1,y)\)</span>有关</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li><span class="math inline">\(d(k,y) = \max\{d(k,y-w_k)+v_k,
d(k-1,y)\}\)</span></li>
</ul>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/%E8%83%8C%E5%8C%85_%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.svg" class="" title="完全背包">
<p><strong>直接DP</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt;= b; y ++) &#123;</span><br><span class="line">        dp[k][y] = dp[k - <span class="number">1</span>][y];  <span class="comment">// 用前i-1种物品方案初始化前i种物品方案</span></span><br><span class="line">        <span class="keyword">if</span>(y &gt;= w[k])</span><br><span class="line">            dp[k][y] = std::<span class="built_in">max</span>(dp[k][y - w[k]] + v[k], dp[k - <span class="number">1</span>][y]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(dp[i-1][\ldots]\)</span>只在计算<span
class="math inline">\(dp[i][\ldots]\)</span>时被用到，实际上并不需要二维数组。</p>
<p><strong>滚动数组优化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = w[k]; y &lt;= b; y ++)</span><br><span class="line">        dp[y] = std::<span class="built_in">max</span>(dp[y - w[k]] + v[k], dp[y]);</span><br></pre></td></tr></table></figure>
<p><strong>滚动数组</strong>：</p>
<ul>
<li>重复在一个数组内计算不同信息，减少空间复杂度</li>
<li>确保未处理的信息不被覆盖</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>丢失了过程信息，无法还原完整方案</li>
</ul>
<h3 id="例01背包">例：01背包</h3>
<p>有<span class="math inline">\(n\)</span>个物品，每个物品<span
class="math inline">\(i \in [1,n]\)</span>的重量<span
class="math inline">\(w_i\)</span>，价值<span
class="math inline">\(v_i\)</span>（分别只有1个）。有一个背包可装总重不超过<span
class="math inline">\(b\)</span>的物品，求背包能装物品的最大总价值。</p>
<p><strong>最优子结构</strong>：</p>
<ul>
<li><span class="math inline">\(k\)</span>：只考虑前<span
class="math inline">\(k\)</span>种物品</li>
<li><span class="math inline">\(y\)</span>：背包装物品总重限制到<span
class="math inline">\(y\)</span> (<span class="math inline">\(y \leq
b\)</span>)</li>
<li><span class="math inline">\(d(k,y)\)</span>：前<span
class="math inline">\(k\)</span>种物品装入容量<span
class="math inline">\(y\)</span>的背包的最优解</li>
<li><span class="math inline">\(d(k,y)\)</span>只与<span
class="math inline">\(d(k-1,y-w_k)\)</span>和<span
class="math inline">\(d(k-1,y)\)</span>有关</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li><span class="math inline">\(d(k,y) = \max\{d(k-1,y-w_k)+v_k,
d(k-1,y)\}\)</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = b; y &gt;= w[k]; y --)</span><br><span class="line">        dp[y] = std::<span class="built_in">max</span>(dp[y - w[k]] + v[k], dp[y]);</span><br></pre></td></tr></table></figure>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/%E8%83%8C%E5%8C%85_01%E8%83%8C%E5%8C%85.svg" class="" title="01背包">
<p><strong>其他背包问题</strong>：</p>
<ul>
<li>多重背包：每种物品有<span class="math inline">\(k_i\)</span>个</li>
<li>混合背包：有的1个，有的无限个，有的<span
class="math inline">\(k_i\)</span>个</li>
<li>二维背包：每个物品占<span
class="math inline">\(w_i\)</span>重量和<span
class="math inline">\(a_i\)</span>体积，重量体积都有上限</li>
</ul>
<p>背包是一类多阶段决策问题：每做一次决策就可以得到解的一部分。</p>
<p>经典资料参考：<a
href="https://docs.qq.com/pdf/DRHdIcGltTllSVVVp">背包九讲</a></p>
<h2 id="线性结构dp">线性结构DP</h2>
<h3 id="例最长上升子序列">例：最长上升子序列</h3>
<p>给定<span class="math inline">\(n\)</span>个整数<span
class="math inline">\(A_1,A_2,\ldots,A_n\)</span>，找出最长的递增子序列。</p>
<p>例：1 5 3 6 9 8 10</p>
<p>最长上升子序列为：1&lt;3&lt;6&lt;9&lt;10</p>
<p><strong>最优子结构</strong>：</p>
<ul>
<li><span class="math inline">\(d(k)\)</span>：以第<span
class="math inline">\(k\)</span>个元素结尾的最长上升子序列长度</li>
<li><span class="math inline">\(d(k)\)</span>与<span
class="math inline">\(i&lt;k\)</span>的每个<span
class="math inline">\(d(i)\)</span>有关</li>
<li>对任意<span class="math inline">\(i&lt;k\)</span>，如果<span
class="math inline">\(A_i&lt;A_k\)</span>，则<span
class="math inline">\(A_k\)</span>续在以<span
class="math inline">\(A_i\)</span>结尾的子序列的后面</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li><span class="math inline">\(d(k) = \max\{d(i) | i&lt;k \text{且}
A_i&lt;A_k\} + 1\)</span></li>
</ul>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.svg" class="" title="最长上升子序列">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++) &#123;</span><br><span class="line">    dp[k] = <span class="number">1</span>;  <span class="comment">// 至少自身有1的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; k; j ++)</span><br><span class="line">        <span class="keyword">if</span>(a[j] &lt; a[k] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[k])</span><br><span class="line">            dp[k] = dp[j] + <span class="number">1</span>;</span><br><span class="line">    ans = std::<span class="built_in">max</span>(dp[k], ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong>：</p>
<ol type="1">
<li>另存一个"尾元素"序列，表示各长度子序列的末尾元素</li>
<li>从左到右对每个数<span
class="math inline">\(X\)</span>在尾元素序列中二分查找不小于<span
class="math inline">\(X\)</span>的第一个<span
class="math inline">\(Y\)</span></li>
<li>如果找到：用<span class="math inline">\(X\)</span>替换<span
class="math inline">\(Y\)</span>，即该长度的子序列找到了更小的末尾元素</li>
<li>如果找不到：把<span
class="math inline">\(X\)</span>插入尾元素序列末尾，答案增长</li>
</ol>
<img src="/2025-04-16-26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97_%E5%B0%BE%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97.svg" class="" title="最长上升子序列">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tlen = <span class="number">0</span>;   <span class="comment">// 尾元素个数，指向尾元素数组最后一个元素的下一个位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    <span class="type">int</span> ith = std::<span class="built_in">upper_bound</span>(b, b + tlen, a[i]) - b;  <span class="comment">// 找到不小于a[i]的第一个数</span></span><br><span class="line">    b[ith] = a[i];              <span class="comment">// 用a[i]替换找到的位置，没找到则ith就是末尾位置</span></span><br><span class="line">    <span class="keyword">if</span>(ith == tlen) tlen ++;    <span class="comment">// 没有不小于a[i]的数，长度增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例最长公共子序列">例：最长公共子序列</h3>
<p>给两个序列<span class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>，求长度最大的公共子序列。</p>
<p>例：</p>
<ul>
<li><span class="math inline">\(A\)</span>序列：1,3,2,8,6,5,7</li>
<li><span class="math inline">\(B\)</span>序列：2,1,4,8,5,7,9</li>
</ul>
<p>最长公共子序列长度是4，即2,8,5,7</p>
<p><strong>最优子结构</strong>：</p>
<ul>
<li><span class="math inline">\(d(i,j)\)</span>：<span
class="math inline">\(A\)</span>的前<span
class="math inline">\(i\)</span>个元素与<span
class="math inline">\(B\)</span>的前<span
class="math inline">\(j\)</span>个元素的LCS</li>
<li>与<span class="math inline">\(d(i-1,j-1)\)</span>、<span
class="math inline">\(d(i,j-1)\)</span>、<span
class="math inline">\(d(i-1,j)\)</span>有关：考察<span
class="math inline">\(A_i\)</span>与<span
class="math inline">\(B_j\)</span>是否相等</li>
<li>如果<span class="math inline">\(A_i=B_j\)</span>，<span
class="math inline">\(A_i\)</span>与<span
class="math inline">\(B_j\)</span>配对一定可以作为<span
class="math inline">\(d(i,j)\)</span>的一个解的结尾</li>
<li>如果<span class="math inline">\(A_i \neq B_j\)</span>，那么<span
class="math inline">\(d(i,j)\)</span>的解一定是<span
class="math inline">\(d(i-1,j)\)</span>和<span
class="math inline">\(d(i,j-1)\)</span>的其中一个</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li><span class="math inline">\(d(i,j) = \begin{cases} d(i-1,j-1)+1
&amp; \text{若}A_i=B_j \\ \max(d(i,j-1), d(i-1,j)) &amp; \text{若}A_i
\neq B_j \end{cases}\)</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS</span><span class="params">(<span class="type">char</span> a[], <span class="type">int</span> alen, <span class="type">char</span> b[], <span class="type">int</span> blen)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;     <span class="comment">// 假设a、b下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alen; i ++) &#123;       <span class="comment">// a的游标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= blen; j ++) &#123;   <span class="comment">// b的游标</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) &#123;</span><br><span class="line">                <span class="comment">// a[i] == b[j]时，加入a的前i-1、b的前j-1的LCS</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a[i] != b[j]时，从另外两个子问题较大的转移</span></span><br><span class="line">                dp[i][j] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[alen][blen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其它dp前瞻">其它DP前瞻</h2>
<h3 id="状态压缩dp">状态压缩DP</h3>
<p>将子问题当作"状态"，状态转移方程就是状态的变化。把描述子问题的"状态"压缩为一个整数，优化状态转移效率。</p>
<p><strong>例题：互不侵犯</strong></p>
<p><span class="math inline">\(N \times N\)</span>的棋盘放置<span
class="math inline">\(K\)</span>个国王，国王攻击范围为周围8个格子。多少种摆放方案，能够互相不在攻击范围。</p>
<p><span class="math inline">\(d(i,j,l)\)</span>：前<span
class="math inline">\(i\)</span>行，第<span
class="math inline">\(i\)</span>行状态为<span
class="math inline">\(j\)</span>，已放置<span
class="math inline">\(l\)</span>个国王的方案数。 <span
class="math inline">\(j\)</span>就是压缩的状态：0~8格子有/没有国王是一个01串，用<span
class="math inline">\(int\)</span>表示。</p>
<p>状态压缩示意图（<span class="math inline">\(j=41_{(10)} =
101001_{(2)}\)</span>）： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---+---+---+---+---+---+</span><br><span class="line">| 1 | 0 | 1 | 0 | 0 | 1 |</span><br><span class="line">+---+---+---+---+---+---+</span><br><span class="line">| K |   | K |   |   | K |</span><br><span class="line">+---+---+---+---+---+---+</span><br></pre></td></tr></table></figure>
其中K表示放置国王，空格表示不放置国王。这个二进制数101001表示在第1、3、6列放置国王。</p>
<h3 id="数位dp">数位DP</h3>
<p>统计满足一定条件的数的数量，把数字拆解一位一位地用DP处理。</p>
<p><strong>例题：数字计数</strong></p>
<p>给定两个正整数<span class="math inline">\(a,b\)</span>，求<span
class="math inline">\([a,b]\)</span>范围内各数位0~9各出现多少次。</p>
<p>假设<span
class="math inline">\(d(i)\)</span>统计"1"出现的次数（0~9次数都相等）：
<span class="math inline">\(d(i) = d(i-1) \times 10 +
10^{i-1}\)</span>，然后做进一步作后续处理……</p>
<h3 id="树形dp">树形DP</h3>
<p>在树结构上DP。</p>
<p><strong>例题：树上的最远点对</strong></p>
<p><span
class="math inline">\(n\)</span>个结点的树，找两个点，它们的距离最远。</p>
<p><span class="math inline">\(d(i)\)</span>：节点<span
class="math inline">\(i\)</span>的子树中根到叶子的最大距离。 <span
class="math inline">\(d(i) = \max\{d(j)\} + 1\)</span>，<span
class="math inline">\(j\)</span>为<span
class="math inline">\(i\)</span>的子节点。 所有<span
class="math inline">\(d(j)\)</span>最大的<span
class="math inline">\(j=u\)</span>和<span
class="math inline">\(j=v\)</span>，<span
class="math inline">\(d(u)+d(v)+2\)</span>为答案。</p>
<h3 id="轮廓线dp插头dp">轮廓线DP（插头DP）</h3>
<p>轮廓线DP是一种处理网格类问题的动态规划方法，特别适用于需要记录连通性信息的场景。其核心思想是沿着网格的轮廓线进行状态转移，通过记录轮廓线上每个格子的"插头"状态（如是否有路径经过、路径的方向等）来压缩状态空间。插头DP常用于解决哈密顿回路、路径覆盖、连通性等问题，如"回路计数"、"棋盘覆盖"等经典问题。通过巧妙的状态设计和转移规则，插头DP能够高效处理看似复杂的状态转移，是解决特定类型网格问题的重要工具。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>27.分支限界与剪枝</title>
    <url>/2025-04-23-27-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E4%B8%8E%E5%89%AA%E6%9E%9D/</url>
    <content><![CDATA[<h1 id="分支限界与剪枝">分支限界与剪枝</h1>
<p>分支限界与剪枝通过跳过不可能产生最优解的搜索路径，有效加速寻找最佳解决方案的过程。</p>
<span id="more"></span>
<h2 id="回顾回溯">回顾回溯</h2>
<p>回顾：<a href="/2025-03-19-13-暴力枚举/">13.暴力枚举</a></p>
<p>利用回溯可以枚举排列、子集，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;     <span class="comment">// cur 指 &quot;current&quot;, 当前在确定第 cur 个位置是谁</span></span><br><span class="line">    <span class="keyword">if</span>(cur == n) &#123;                              <span class="comment">// 递归终点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)             <span class="comment">// 输出一个排列</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span> + !i, record[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;                                 <span class="comment">// 注意return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;               <span class="comment">// 枚举每个元素</span></span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;                    <span class="comment">// 已放元素排除</span></span><br><span class="line">        vis[i] = <span class="literal">true</span>; record[cur] = a[i];      <span class="comment">// 标记已放本次排列第cur个为a[i]</span></span><br><span class="line">        <span class="built_in">DFS</span>(cur + <span class="number">1</span>);                           <span class="comment">// 递归放第cur+1个</span></span><br><span class="line">        vis[i] = <span class="literal">false</span>;                         <span class="comment">// 回溯取消标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回溯本质上是<strong>在约束条件下</strong>枚举每个元素的所有可能性，其复杂度必然是指数级的，输入规模稍大，时间复杂度就会难以接受。</p>
<p>回溯的结构是搜索树，八皇后等例子已经体验到，搜索树的一些子树可以跳过不搜。跳过整个子树的操作称为<strong>剪枝</strong>。</p>
<p>如果有一个固定的套路可以跳过尽可能多的子树，即进行尽可能多的<strong>剪枝</strong>，就可以一定程度上让回溯跑的更快。</p>
<h2 id="分支限界">分支限界</h2>
<p>最优化问题，即每一种可能性（排列或组合）都对应某种收益，希望这个收益最大化，找最优的可能性。</p>
<p>当回溯用来处理最优化问题，就可以维护一个搜索过程中的最好收益——每当搜到某个方案收益更大，就更新最好收益。</p>
<p>针对搜索树的一棵子树，如果能估算子树可能取得的最好结果，当最好结果不及已经搜到的最好收益时，这棵子树就没有搜索下去的必要，完成一次剪枝。</p>
<img src="/2025-04-23-27-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E4%B8%8E%E5%89%AA%E6%9E%9D/%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C_%E7%95%8C%E4%B8%8E%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0.svg" class="">
<h3 id="例用回溯解01背包">例：用回溯解01背包</h3>
<p>回溯解01背包，就是枚举所有子集，在能装进背包的子集中更新获得价值的最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="number">-1</span>) &#123;                             <span class="comment">// 递归终点,所有元素都已确定</span></span><br><span class="line">        <span class="comment">// 这里计算搜到的子集能否装进背包及价值</span></span><br><span class="line">        <span class="keyword">return</span>;                                 <span class="comment">// 注意return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由n-1~0逆序以便按字典序枚举子集</span></span><br><span class="line">    chose[cur] = <span class="literal">false</span>; <span class="built_in">DFS</span>(cur - <span class="number">1</span>);           <span class="comment">// 不取a[cur]后确定第cur-1个</span></span><br><span class="line">    chose[cur] = <span class="literal">true</span>; <span class="built_in">DFS</span>(cur - <span class="number">1</span>);            <span class="comment">// 取a[cur]后确定第cur-1个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当某一刻搜索到第 <span class="math inline">\(k\)</span> 层，即第<span
class="math inline">\(1\sim k-1\)</span>
个物品是否取已经有一个临时决定时，就在面对一棵子树，估算这棵子树（即第<span
class="math inline">\(k\sim
n\)</span>个物品取与不取）所有可能性中收益<strong>不可能超越</strong>的上限，有很多思路，其中一个思路如图：</p>
<img src="/2025-04-23-27-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E4%B8%8E%E5%89%AA%E6%9E%9D/01%E8%83%8C%E5%8C%85%E7%9A%84%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C.svg" class="">
<p>用背包容量扣除已经放入背包的物品（<span class="math inline">\(1\sim k
- 1\)</span>
的某个子集），剩余容量全放单价最高的，且强行塞满，做一个价值估值。如果这个估值不大于之前已经搜到的最优方案，那这棵子树就不必搜下去了，即当前<span
class="math inline">\(1\sim k - 1\)</span> 选定了特定子集前提下，<span
class="math inline">\(k\sim n\)</span> 的任何子集都不用尝试了。</p>
<p>估算子树的最优可能性不需要是合理的方案，只需要让这个估值必定优于子树所有可能性即可。</p>
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lft, <span class="type">int</span> vcur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cur: 当前物品编号； lft: 剩余容量； vcur: 当前已装入价值</span></span><br><span class="line">    <span class="keyword">if</span>(cur == n) &#123;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(vcur, ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ************************************************** //</span></span><br><span class="line">    <span class="comment">// 最理想情况不如已有解，剪枝</span></span><br><span class="line">    <span class="comment">// vsum[cur]为cur之后物品价值之和；maxvw[cur]为cur之后最高单价</span></span><br><span class="line">    <span class="keyword">if</span>(vcur + std::<span class="built_in">min</span>(vsum[cur], lft * maxvw[cur]) &lt;= ans) <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// ************************************************** //</span></span><br><span class="line">    <span class="comment">// 尝试第cur个物品装或不装</span></span><br><span class="line">    <span class="keyword">if</span>(lft &gt;= w[cur]) <span class="built_in">DFS</span>(cur + <span class="number">1</span>, lft - w[cur], vcur + v[cur]);</span><br><span class="line">    <span class="built_in">DFS</span>(cur + <span class="number">1</span>, lft, vcur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>// ***</code>
之间的这部分代码，就是在枚举子集的基础上增加的分支限界规则。</p>
<h3 id="例用回溯解旅行商问题">例：用回溯解旅行商问题</h3>
<p>若干城市两两之间有路，从一个城市出发，每个城市恰好经过一次并回到原点，总路程最小的方案。</p>
<style>.ntpcouadsknl{}</style>
<img src="/2025-04-23-27-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E4%B8%8E%E5%89%AA%E6%9E%9D/tsp.svg" class="ntpcouadsknl">
<p>枚举排列——行走城市的顺序</p>
<p>子树最优可能性估算策略，即搜索到 <span
class="math inline">\(k\)</span>
步某个走法情况下，后面所有走法里路程最短可能性：</p>
<ul>
<li>剩下每一步都走全局最短边</li>
<li>剩下每一步都走剩下最短边</li>
<li>剩下每一步都走所在点发出的最短边</li>
</ul>
<p>以上策略是否都“对”，哪个最“好”</p>
<p>“对”的策略：估算的值一定比所有可能性都优，因为当估值差于已经得到的解，就剪枝，如果估值不能保证比所有可能性更优，就可能导致剪枝错杀，错过了潜在最优解。</p>
<p>“好”的策略：估值比所有可能性更优的前提下，越贴近实际可能性越好。因为估值瞎猜一个很极端的值，也能做到是“对”的，但“对”不表明有用，它越贴近真实可能值，就越有可能比已经得到的解差，才越可能实现剪枝。不能剪枝的估值没什么用。</p>
<h3 id="例回溯解圆排列">例：回溯解圆排列</h3>
<p>给定若干圆的半径，各圆与底相切，求横向宽度最小的摆放顺序</p>
<style>.gcegxrhmnlrp{}</style>
<img src="/2025-04-23-27-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E4%B8%8E%E5%89%AA%E6%9E%9D/%E5%9C%86%E6%8E%92%E5%88%97_%E7%A4%BA%E6%84%8F.svg" class="gcegxrhmnlrp">
<p>先解决个小问题：两圆横向距离计算</p>
<style>.hkxplyjuiedn{}</style>
<img src="/2025-04-23-27-%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E4%B8%8E%E5%89%AA%E6%9E%9D/%E5%9C%86%E6%8E%92%E5%88%97_%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97.svg" class="hkxplyjuiedn">
<p>枚举排列，找宽度最小的排列。</p>
<p>子树估算方案：假设剩下的圆全用剩下的最小的那个</p>
<blockquote>
<p>当想不出更“好”的估值方案时，简单粗暴但“对”的估值方案仍然有用</p>
</blockquote>
<h2 id="剪枝">剪枝</h2>
<p>相对分支限界，剪枝是一个更宽泛的概念，无论用什么方式，减少搜索树的子树，都是可用的剪枝技巧</p>
<h3 id="例等长的木棒">例：等长的木棒</h3>
<p>有一堆长短不一的木棒是由等长的木棒切割成的</p>
<p>已知各个木棒的长度，求原先那些等长的木棒最短可能的长度</p>
<p>例1：5,2,1,5,2,1,5,2,1</p>
<p>原先为4个长度为6的木棒</p>
<p>例2：1,2,3,4</p>
<p>原先为2个长度为5的木棒</p>
<p>从小到大枚举等长木棒的长度，回溯尝试所有木棒拼凑出整数个该长度</p>
<p>一些可以尝试的剪枝思路：</p>
<ul>
<li>枚举可能的长度去拼凑，这个枚举的长度至少要被总长度整除</li>
<li>短木棒更“灵活”，所以排序优先尝试使用更长的木棒</li>
<li>某次构建使用的第一个最长木棒没成功，则直接回溯</li>
</ul>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>28.搜索加速技巧</title>
    <url>/2025-04-23-28-%E6%90%9C%E7%B4%A2%E5%8A%A0%E9%80%9F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="搜索加速技巧">搜索加速技巧</h1>
<p>双向搜索、<code>A*</code>、<code>IDA*</code>等 BFS、DFS
的改进策略。</p>
<span id="more"></span>
<h2 id="双向bfs">双向BFS</h2>
<p>回顾BFS</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x_, <span class="type">int</span> y_) &#123;</span><br><span class="line">        x = x_;</span><br><span class="line">        y = y_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> startX, <span class="type">int</span> startY)</span> </span>&#123;</span><br><span class="line">    std::queue&lt;Node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(startX, startY));</span><br><span class="line">    visited[startX][startY] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (now.x == endX &amp;&amp; now.y == endY) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nextX = now.x + dx[i], nextY = now.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (graph[nextX][nextY] &amp;&amp; !visited[nextX][nextY]) &#123;</span><br><span class="line">                visited[nextX][nextY] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(nextX, nextY));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS利用队列实现从一点出发，一层一层外扩式搜索。</p>
<p>当知道起点与终点，目的是找到合法最短路时，从起点和终点同时搜索可以极大减小搜索空间。</p>
<p>相比单向BFS,双向BFS可以大大减少搜索空间。假设单向广搜需要搜索到第d层才能到达终点,搜索空间约为<span
class="math inline">\(b^d\)</span>(b为每个节点平均分支数)。而双向广搜只需要各自搜索到第d/2层,搜索空间约为<span
class="math inline">\(2b^{d/2}\)</span>,远小于<span
class="math inline">\(b^d\)</span>。</p>
<img src="/2025-04-23-28-%E6%90%9C%E7%B4%A2%E5%8A%A0%E9%80%9F%E6%8A%80%E5%B7%A7/%E5%8F%8C%E5%90%91%E5%B9%BF%E6%90%9C.svg" class="">
<h2 id="双向dfs">双向DFS</h2>
<p>思想类似，如回溯枚举子集找最优解的问题中，搜索一部分元素的所有子集，再搜索另一部分元素的所有子集，进而拼凑符合条件的方案，也能指数级降低复杂度。</p>
<h3 id="例重量背包">例：重量背包</h3>
<p><span class="math inline">\(n\)</span>
个物品，每个物品有一定重量，在不超过背包容量前提下，最多装多少重量的物品。</p>
<p>思路：</p>
<ul>
<li>回溯枚举前半数物品所有子集，记录能凑出的所有重量，记录并排序。</li>
<li>回溯枚举后半数物品的所有子集，每得到一个子集，用背包容量减去这个子集的重量，剩余重量二分查找前半数物品能凑出的不超出的最大值。</li>
</ul>
<h2 id="a">A*</h2>
<p><code>A*</code>是BFS的改进算法，将BFS的队列改为优先级队列，其优先级是一个“启发式”的函数，每个节点的优先级为:</p>
<p><span class="math inline">\(f(n) = g(n) + h(n)\)</span></p>
<p>其中: - <span
class="math inline">\(g(n)\)</span>是从起点到当前节点<span
class="math inline">\(n\)</span>的实际代价 - <span
class="math inline">\(h(n)\)</span>是从当前节点<span
class="math inline">\(n\)</span>到终点的估计代价(启发函数)</p>
<p>常见的启发函数:</p>
<ul>
<li>曼哈顿距离:适用于网格图,只能上下左右移动。两点间的曼哈顿距离为 <span
class="math inline">\(|x1-x2| +
|y1-y2|\)</span>，即横向和纵向距离之和</li>
<li>欧几里得距离:适用于八方向移动。两点间的欧几里得距离为 <span
class="math inline">\(sqrt((x1-x2)^2 +
(y1-y2)^2)\)</span>，即直线距离</li>
<li>对角线距离:适用于网格图,可以斜向移动。两点间的对角线距离为 <span
class="math inline">\(max(|x1-x2|,
|y1-y2|)\)</span>，因为可以斜着走,只需要走最长的那条边的距离</li>
</ul>
<p>A*算法相比BFS,通过启发函数引导搜索朝目标方向进行,可以大大减少搜索空间。但如果启发函数设计不当,可能会失去最优性。</p>
<h3 id="例八数码">例：八数码</h3>
<style>.pkwnnttahvpg{}</style>
<img src="/2025-04-23-28-%E6%90%9C%E7%B4%A2%E5%8A%A0%E9%80%9F%E6%8A%80%E5%B7%A7/%E5%85%AB%E6%95%B0%E7%A0%81.png" class="pkwnnttahvpg">
<p>九宫格放<span class="math inline">\(1\sim
8\)</span>八个数，一个空格可以看作<span
class="math inline">\(0\)</span>，<span
class="math inline">\(0\)</span>周围的格子可以移到<span
class="math inline">\(0\)</span>上，找一个移动方案将<span
class="math inline">\(1\sim
8\)</span>归位到从上到下、从左到右按顺序的排列。</p>
<p><span class="math inline">\(h\)</span>
函数可以定义为每个数距离目标位置的曼哈顿距离、不在应该在的位置的棋子个数等。</p>
<h2 id="迭代加深iddfs">迭代加深（IDDFS）</h2>
<p>“以DFS方式实现的BFS”</p>
<p>BFS从近到远一点点向外搜索，用队列实现。而IDDFS也是从近到远一点点扩大搜索范围，每次限制一个DFS深度，进行DFS，到达深度就返回，搜完没找到答案时，扩大深度限制，再进行一次DFS。</p>
<p>当BFS的搜索空间过大时，考虑用IDDFS，适合场景：</p>
<ul>
<li>解的深度未知</li>
<li>搜索空间巨大</li>
<li>内存受限</li>
</ul>
<h2 id="ida"><code>IDA*</code></h2>
<p><code>IDA*</code>是迭代加深搜索(IDDFS)和<code>A*</code>的结合。它使用迭代加深的框架，但每次深度限制不是搜索深度，而是启发函数值的限制。</p>
<p>具体来说:</p>
<ol type="1">
<li>设定初始的启发函数值限制</li>
<li>用DFS方式搜索,但当 <span class="math inline">\(f(n) = g(n) +
h(n)\)</span> 超过限制时就返回</li>
<li>如果没找到解，增大启发函数值限制，重新搜索</li>
<li>重复以上步骤直到找到解</li>
</ol>
<p><code>IDA*</code>相比<code>A*</code>的优点:</p>
<ul>
<li>空间复杂度低,因为用DFS实现</li>
<li>不需要维护开放列表和关闭列表</li>
<li>适合搜索空间巨大的问题</li>
</ul>
<p>缺点是可能会重复搜索一些状态。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>29.并查集</title>
    <url>/2025-04-23-29-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集">并查集</h1>
<p>普通并查集与带权并查集，快速实现元素集合的合并与查询。</p>
<span id="more"></span>
<h2 id="普通并查集">普通并查集</h2>
<p>每个集合都有一些点，两个集合之间的任意点连接，则认为两个集合合并</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">集合A:    集合B:</span><br><span class="line">  1         5</span><br><span class="line">  |         |</span><br><span class="line">  2         6---8</span><br><span class="line">  |         |</span><br><span class="line">  3         7---9</span><br><span class="line">  |     </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">当2和6相连时，认为集合合并</span><br><span class="line"></span><br><span class="line">  1         5</span><br><span class="line">  |         |</span><br><span class="line">  2 --------6---8</span><br><span class="line">  |         |</span><br><span class="line">  3         7---9</span><br><span class="line">  |     </span><br><span class="line">  4     </span><br></pre></td></tr></table></figure>
<p>此时想知道 <span class="math inline">\(4\)</span> 和 <span
class="math inline">\(8\)</span> 是否在一个集合中，就不得不 DFS
一下，很费时间。</p>
<p>已在同个集合的两点不再连边，则每个集合都可以看作一个树形结构。</p>
<p>并查集通过<strong>路径压缩</strong>树变得"扁平"</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">      1             </span><br><span class="line">    /   \           </span><br><span class="line">   2     4               1</span><br><span class="line">  /           ====&gt;   / | | \  </span><br><span class="line">3                    2  3 4  5    </span><br><span class="line">  \                     </span><br><span class="line">    5                   </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        p[i] = i;   <span class="comment">// 初始每个元素自己是一个集合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到 x 所在集合的树的根节点，同时进行路径压缩：</span></span><br><span class="line"><span class="comment">// 即 x 到根 路径上每个点都摘出来重新直接连到根节点上</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> p[x] = x == p[x] ? x : <span class="built_in">fa</span>(p[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Join</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 i 与 j 连接，即将它们所在的集合合并为一个</span></span><br><span class="line">    p[<span class="built_in">fa</span>(i)] = <span class="built_in">fa</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>int fa(int x) &#123;return p[x] = x == p[x] ? x : fa(p[x]);&#125;</code>
这行代码是并查集的精髓，拆解分析：</p>
<ul>
<li><code>p[x] =</code> 是在为 <code>x</code>
设置父节点，<code>p[x]</code>设为谁，谁就是<code>x</code>的直接父节点</li>
<li><code>x == p[x] ?</code>
三元运算符，如果<code>x</code>自己就是<code>p[x]</code>，说明<code>x</code>是所在集合树的根节点</li>
<li><code>fa(p[x])</code> 如果 <code>x != p[x]</code>，则递归调用
<code>fa(p[x])</code> ，即从 <code>x</code> 父节点继续向上递归找根节点
<ul>
<li>这个递归会返回根节点，从而前面的 <code>p[x] =</code>
赋值就是根节点的编号</li>
<li><code>fa(p[x])</code> 会继续递归处理 <code>x</code> 的父节点
<code>p[x]</code>，那么 <code>p[p[x]]</code>
也会赋值为根节点，<code>p[p[p[[x]]</code>也会……</li>
<li>从而完成路径压缩——<code>x</code>到根的一路的节点都把父节点设为了根节点</li>
</ul></li>
</ul>
<h2 id="带权并查集">带权并查集</h2>
<p>普通并查集的图，边只表示“是同一个集合”。而有一类表达关系的图，“边”带有关系属性。</p>
<h3 id="例食物链">例：食物链</h3>
<p>有 <span class="math inline">\(N\)</span> 个元素，编号为 <span
class="math inline">\(1∼N\)</span>。每个元素属于 <span
class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span>、<span class="math inline">\(C\)</span>
三种类型之一（比如石头剪刀布），但具体类型未知。</p>
<p>给定 <span class="math inline">\(K\)</span>
条信息，每条信息有两种形式：</p>
<ul>
<li><span class="math inline">\(1\)</span> <span
class="math inline">\(X\)</span> <span
class="math inline">\(Y\)</span>：表示 <span
class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 是同一类型</li>
<li><span class="math inline">\(2\)</span> <span
class="math inline">\(X\)</span> <span
class="math inline">\(Y\)</span>：表示 <span
class="math inline">\(X\)</span> 吃 <span
class="math inline">\(Y\)</span>（<span class="math inline">\(A\)</span>
吃 <span class="math inline">\(B\)</span>，<span
class="math inline">\(B\)</span> 吃 <span
class="math inline">\(C\)</span>，<span class="math inline">\(C\)</span>
吃 <span class="math inline">\(A\)</span>，形成环形）</li>
</ul>
<p>判断这 <span class="math inline">\(K\)</span>
条信息中有多少条是假信息。一条信息在以下情况下为假：</p>
<ul>
<li>与之前的信息冲突（<span class="math inline">\(A\)</span>吃<span
class="math inline">\(B\)</span>，<span
class="math inline">\(B\)</span>吃<span
class="math inline">\(C\)</span>，但<span
class="math inline">\(A\)</span>又吃<span
class="math inline">\(C\)</span>，不符合循环，就是一种冲突）</li>
<li><span class="math inline">\(X\)</span> 或 <span
class="math inline">\(Y\)</span> 大于 <span
class="math inline">\(N\)</span>（出现了不存在的编号）</li>
<li><span class="math inline">\(X\)</span> 吃 <span
class="math inline">\(X\)</span>（自相矛盾）</li>
</ul>
<p>输入：第一行 <span class="math inline">\(N\)</span> <span
class="math inline">\(K\)</span>（<span class="math inline">\(N\)</span>
个元素，<span class="math inline">\(K\)</span> 条信息），接下来 <span
class="math inline">\(K\)</span> 行每行三个整数 <span
class="math inline">\(D\)</span> <span class="math inline">\(X\)</span>
<span class="math inline">\(Y\)</span>（<span
class="math inline">\(D\)</span> 为 <span
class="math inline">\(1\)</span> 或 <span
class="math inline">\(2\)</span>）。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1</span><br><span class="line">2 1 2</span><br><span class="line">2 2 3</span><br><span class="line">2 3 3</span><br><span class="line">1 1 3</span><br><span class="line">2 3 1</span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure>
<p>输出格式：一行，假信息的数量。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>对于石头剪子布，<span class="math inline">\(X\)</span>与<span
class="math inline">\(Y\)</span> 有 3 种边：<span
class="math inline">\(X\)</span> 吃 <span
class="math inline">\(Y\)</span>、<span class="math inline">\(Y\)</span>
吃 <span class="math inline">\(X\)</span>、<span
class="math inline">\(X\)</span>和<span
class="math inline">\(Y\)</span>同类，用集合表示“知道它们两两之间的关系”这个概念，还用这个图来理解：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">集合A:    集合B:</span><br><span class="line">  1         5</span><br><span class="line">  |         |</span><br><span class="line">  2         6---8</span><br><span class="line">  |         |</span><br><span class="line">  3         7---9</span><br><span class="line">  |     </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">当2和6相连时，认为集合合并</span><br><span class="line"></span><br><span class="line">  1         5</span><br><span class="line">  |         |</span><br><span class="line">  2 --------6---8</span><br><span class="line">  |         |</span><br><span class="line">  3         7---9</span><br><span class="line">  |     </span><br><span class="line">  4     </span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(1,2,3,4\)</span> 知道两两相克关系，<span
class="math inline">\(5,6,7,8,9\)</span>
知道两两相克关系，但是两个集合之间相克关系为止。</p>
<p>当某一刻告知了 <span class="math inline">\(2\)</span> 吃 <span
class="math inline">\(6\)</span>，或 <span
class="math inline">\(6\)</span> 吃 <span
class="math inline">\(2\)</span>，或 <span
class="math inline">\(2\)</span> 与 <span
class="math inline">\(6\)</span> 同类，那么<span
class="math inline">\(1\sim 9\)</span>
的两两相克关系就全都能知道了。</p>
<p>这很像并查集的模型，但又不能简单地用父子节点的树来表达。需要让边带权，在路径压缩的时候也要压缩这个权值。</p>
<p><strong>权值定义为：子节点与父节点的“顺时针”距离。</strong></p>
<p>在石头剪子布里，距离就定义为：</p>
<ul>
<li>从石头到剪子、从剪子到布、从布到石头的距离都是 <span
class="math inline">\(1\)</span></li>
<li>从石头到布、从剪子到石头、从布道剪子的距离都是 <span
class="math inline">\(2\)</span>。</li>
</ul>
<p>有这个顺时针距离，就可以确定相克关系。</p>
<p>路径压缩时，仍然是把树“扁平化”，因为维护了任意子节点到父节点的“食物链顺时针”距离，那么就可以压缩出节点到根节点的“食物链顺时针”距离。</p>
<p>用 <span class="math inline">\(A-B\)</span> 表示计算从 <span
class="math inline">\(B\)</span> 出发到 <span
class="math inline">\(A\)</span> 的距离，来演练一下这个合并：</p>
<p>设 <span class="math inline">\(A\)</span>、<span
class="math inline">\(AR\)</span> 是一个集合，<span
class="math inline">\(AR\)</span> 是根节点， <span
class="math inline">\(B\)</span>、<span
class="math inline">\(BR\)</span> 是一个集合，<span
class="math inline">\(BR\)</span> 是根节点。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">    AR     BR</span><br><span class="line">   /        \</span><br><span class="line"> ...         ...</span><br><span class="line"> /            \</span><br><span class="line">A              B</span><br></pre></td></tr></table></figure>
<p>当告知 <span class="math inline">\(A\)</span> 与 <span
class="math inline">\(B\)</span>
的相克关系时，集合合并。先路径压缩，让<span
class="math inline">\(A\)</span>称为<span
class="math inline">\(AR\)</span>的直接子节点，<span
class="math inline">\(B\)</span> 也称为 <span
class="math inline">\(BR\)</span> 的直接子节点</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">  AR     BR</span><br><span class="line"> /        \</span><br><span class="line">A           B</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rt = x == p[x] ? x : <span class="built_in">fa</span>(p[x]);</span><br><span class="line">    d[x] = (d[x] + d[p[x]]) % <span class="number">3</span>;</span><br><span class="line">    p[x] = rt;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中 <code>p[x]</code> 维护 <code>x</code> 的父节点，
<code>d[x]</code> 维护 <code>x</code>到父节点的“食物链顺时针”距离。</p>
<p>当得知 <span class="math inline">\(A\)</span> 与 <span
class="math inline">\(B\)</span> 相克关系时，进行类似合并集合操作，将
<span class="math inline">\(AR\)</span> 作为 <span
class="math inline">\(BR\)</span> 的子节点：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">    BR</span><br><span class="line">   /  \</span><br><span class="line">  AR   B</span><br><span class="line"> /</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>$B-A = (B - BR) + (BR - AR) + (AR-A) $</p>
<p>这里 <span class="math inline">\(AR-A\)</span> 就是代码中的
<code>d[A]</code>，<code>BR-AR</code> 是
<code>d[AR]</code>，<code>BR-B</code>（即<code>-(B-BR)</code>） 是
<code>d[B]</code></p>
<p>因为集合合并是 将 <span class="math inline">\(AR\)</span> 作为 <span
class="math inline">\(BR\)</span> 的子节点，所以在集合合并前后， <span
class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>
的直接父节点不变（这一刻<span
class="math inline">\(A\)</span>暂且没有进一步路径压缩），从而<code>d[A]</code>、<code>d[B]</code>不变。</p>
<p><code>d[AR]</code>
本来作为根节点是<code>0</code>，合并时只有它会变，要根据 <span
class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>
的关系，在成为<span class="math inline">\(BR\)</span>
的子节点后发生变化，变换之前的等式得到：</p>
<p><span class="math inline">\((BR-AR) = (BR-B) - (AR-A) +
(B-A)\)</span></p>
<p>对应代码中的
<code>d[AR] = d[B] - d[A] + &lt;A到B的食物链顺时针距离&gt;</code></p>
<ul>
<li>当<span class="math inline">\(A\)</span>与<span
class="math inline">\(B\)</span>是同类，则<span
class="math inline">\(B-A=0\)</span>，即
<code>d[AR]= d[B] - d[A] + 0</code></li>
<li>当 <span class="math inline">\(A\)</span>吃<span
class="math inline">\(B\)</span>，则<span
class="math inline">\(B-A=1\)</span>，<code>d[AR]= d[B] - d[A] + 1</code></li>
</ul>
<p>从而集合基于 <span class="math inline">\(A\)</span> 与 <span
class="math inline">\(B\)</span>
的关系合并，在两个集合各自路径压缩后，只需要 <span
class="math inline">\(2\)</span> 步：</p>
<ol type="1">
<li>把 <span class="math inline">\(AR\)</span> 接到 <span
class="math inline">\(BR\)</span> 作为子节点，就是更新
<code>p[AR]</code></li>
<li>确定 <span class="math inline">\(AR\)</span> 到 <span
class="math inline">\(BR\)</span> 的距离，就是更新
<code>d[AR]</code></li>
</ol>
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[maxn], d[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fa</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里递归了，故p[x]往上已路径压缩</span></span><br><span class="line">    <span class="type">int</span> rt = x == p[x] ? x : <span class="built_in">fa</span>(p[x]);  </span><br><span class="line">    <span class="comment">// 此时 d[p[x]] 已经是 p[x] 到 rt 的距离，那么 x 到 rt 的距离就是 d[x] + d[p[x]]</span></span><br><span class="line">    d[x] = (d[x] + d[p[x]]) % <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 进行路径压缩，这里和并查集一样，把 x 作为 rt 的直接子节点</span></span><br><span class="line">    p[x] = rt;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N, K, fake = <span class="number">0</span>, op, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">while</span>(K --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(a &gt; N || b &gt; N) &#123;</span><br><span class="line">            fake ++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fa</span>(a) == <span class="built_in">fa</span>(b) &amp;&amp; d[a] != d[b]) &#123;</span><br><span class="line">                <span class="comment">// 如果已是同一集合但 ab 并不是同类，矛盾</span></span><br><span class="line">                <span class="comment">// fa(a) == fa(b) 已经完成了路径压缩，d[a]和d[b]计算时都已是到同一个父节点的距离</span></span><br><span class="line">                fake ++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 a 和 b 都已路径压缩了（在前面的if里）</span></span><br><span class="line">            <span class="comment">// a 祖先 ar 设为 b 祖先的子节点，更新 a 的祖先到 b 的祖先距离 d[ar]</span></span><br><span class="line">            <span class="comment">// 这里 a 和 b 同类，d[ar] 可根据公式推算，</span></span><br><span class="line">            <span class="type">int</span> ar = <span class="built_in">fa</span>(a);    <span class="comment">// 这里要暂存 fa(a)，避免后续合并时重复调用 fa(a) 出现错误</span></span><br><span class="line">            p[ar] = <span class="built_in">fa</span>(b);</span><br><span class="line">            d[ar] = (d[b] - d[a] + <span class="number">3</span>) % <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fa</span>(a) == <span class="built_in">fa</span>(b) &amp;&amp; (d[a] - d[b] + <span class="number">3</span>) % <span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果已是同一集合但 a 不吃 b，矛盾</span></span><br><span class="line">                <span class="comment">// a 吃 b 即 a 到 b “食物链顺时针”距离为 1， +3 补足 %3 的同余避免出现负数</span></span><br><span class="line">                <span class="comment">// a 到 b 的距离，即 b - a = (ar - a) - (br - b) = d[a] - d[b]</span></span><br><span class="line">                fake ++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原理同上</span></span><br><span class="line">            <span class="type">int</span> ar = <span class="built_in">fa</span>(a);</span><br><span class="line">            <span class="comment">// 这里 +4 而不是 +1，是补足 %3 的同余避免出现负数，正确计算“食物链顺时针”距离</span></span><br><span class="line">            p[ar] = <span class="built_in">fa</span>(b);</span><br><span class="line">            d[ar] = (d[b] - d[a] + <span class="number">4</span>) % <span class="number">3</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fake);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>30.图论基础1</title>
    <url>/2025-05-08-30-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h1 id="图论基础1">图论基础1</h1>
<p>优先队列及其底层堆结构原理、最小生成树的 Prim 与 Kruskal
算法、最短路的 Floyd 和 Dijkstra 算法及堆优化版本，以及拓扑排序。</p>
<span id="more"></span>
<h2 id="优先队列">优先队列</h2>
<p>优先队列（Priority Queue）：</p>
<ol type="1">
<li>每次出队的元素都是队列中优先级最高的元素</li>
<li>可以自定义元素的优先级比较方式</li>
</ol>
<img src="/2025-05-08-30-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%801/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.svg" class="">
<p>在C++中，我们可以使用STL的<code>priority_queue</code>来实现优先队列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认是大顶堆（大的元素优先级高）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小顶堆（小的元素优先级高）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line">pq.<span class="built_in">push</span>(x);    <span class="comment">// 入队</span></span><br><span class="line">pq.<span class="built_in">top</span>();      <span class="comment">// 获取队首元素（优先级最高的元素）</span></span><br><span class="line">pq.<span class="built_in">pop</span>();      <span class="comment">// 出队</span></span><br><span class="line">pq.<span class="built_in">empty</span>();    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">pq.<span class="built_in">size</span>();     <span class="comment">// 获取队列大小</span></span><br></pre></td></tr></table></figure>
<p>如果想自定义优先级别,可以定义结构体并<strong>重载</strong>比较符号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; that) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 这里定义优先级比较规则</span></span><br><span class="line">        <span class="comment">// 返回 true 表示 this 的优先级低于 that</span></span><br><span class="line">        <span class="comment">// 返回 false 表示 this 的优先级高于或等于 that</span></span><br><span class="line">        <span class="comment">// 这里以 x * y 大的优先级高为例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x * <span class="keyword">this</span>.y &lt; that.x * that.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Node&gt; pq;</span><br></pre></td></tr></table></figure>
<h3 id="底层原理堆">底层原理:堆</h3>
<p>一个除最后一层都"靠左"外，上面每一层都是"满"的二叉树——完全二叉树</p>
<p>但它不是有序的二叉树，它只保证一个性质：</p>
<p><strong>任意节点的值，都是它作为根的子树的最优值，但和兄弟节点之间大小关系随机</strong>，即每个子树都是一个"堆"</p>
<img src="/2025-05-08-30-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%801/%E5%A0%86.svg" class="">
<p>回顾完全二叉树：</p>
<ul>
<li>任意节点 <span class="math inline">\(i\)</span> 的父节点编号是 <span
class="math inline">\(\lfloor i / 2 \rfloor\)</span></li>
<li>任意节点 <span class="math inline">\(i\)</span> 的左子节点编号 <span
class="math inline">\(i * 2\)</span>，右子节点编号 <span
class="math inline">\(i * 2 + 1\)</span></li>
</ul>
<p>当一个点<code>s</code>除了自身外，它的子节点都已是堆时，通过这个代码可以把它调整成一个堆</p>
<p>设：</p>
<ul>
<li>保存这个完全二叉树的数组是<code>a[]</code></li>
<li>某个节点是<code>s</code>
<ul>
<li><code>s</code>所有子孙的树都是堆，但<code>s</code>作为根的这棵树还不是堆</li>
</ul></li>
<li><code>e</code>是最大节点编号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> s, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设在构建 小根 堆，即目标是任意节点都比它所有子孙节点小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> nex = s &lt;&lt; <span class="number">1</span>; nex &lt;= e; nex &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// nex 指向 s 的左子节点，看 nex 和 nex+1 哪个子节点小，如果右边更小则 nex++ 指向右边</span></span><br><span class="line">        <span class="keyword">if</span>(nex + <span class="number">1</span> &lt;= e &amp;&amp; a[nex + <span class="number">1</span>] &lt; a[nex]) nex ++; </span><br><span class="line">        <span class="comment">// 如果 a[s] 比 左右子节点都小，由于子树已经是堆了，a[s]又更小，那么已经完成了堆的调整，可退出</span></span><br><span class="line">        <span class="keyword">if</span>(a[s] &lt;= a[nex]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 否则，将左右子节点较小的与 a[s] 交换，目的是把较大的值往叶子方向换，把较小的&quot;往上提&quot;</span></span><br><span class="line">        <span class="built_in">Swap</span>(a[s], a[nex]);</span><br><span class="line">        <span class="comment">// s 追着 nex 跑，保持 s 是 nex 父节点</span></span><br><span class="line">        s = nex;                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以前面的图为例，从编号为 <span class="math inline">\(6\)</span>
的节点开始，让 <code>s</code> 作为 <span
class="math inline">\(6,5,4,3,2,1\)</span> 的顺序分别执行一次
<code>HeapAdjust</code> ，就让整个完全二叉树成为堆了。</p>
<p>注意这个顺序不能变，不能是 <span
class="math inline">\(1,2,3,4,5,6\)</span> 的顺序，因为对 <code>s</code>
执行 <code>HeapAdjust</code> 的前提是 <code>s</code>
的子孙树们都已经是堆。从<span
class="math inline">\(6\)</span>开始往前来的话，每个点处理之前，就都已经把它的子孙树点处理为堆了。</p>
<h3 id="堆与优先队列">堆与优先队列</h3>
<p>一个堆，它的堆顶元素就是优先队列出队时最优先的元素。</p>
<p>当堆顶（<code>a[1]</code>）离开</p>
<ol type="1">
<li>需要有元素补位</li>
<li>需要让它仍然是一个堆</li>
</ol>
<p>方法是让最后一个元素 <code>a[e]</code> 补位到 <code>a[1]</code>，然后
<code>e--</code>，此时只有堆顶不符合堆要求，调用一次<code>HeapAdjust</code>就可以了</p>
<p>当加入新元素，</p>
<ol type="1">
<li>先把新元素放到数组末尾（<code>a[++ e] = new_val;</code>）</li>
<li>然后从下往上调整，直到满足堆的性质</li>
</ol>
<p>这个过程与<code>HeapAdjust</code>相似，只不过方向相反，是从叶子往上去，示例代码仍然以小根堆为例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapInsert</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> &amp;e, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// e 是当前堆中最后一个元素的下标</span></span><br><span class="line">    <span class="comment">// 先把新元素放到末尾</span></span><br><span class="line">    a[++e] = x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从下往上调整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = e; i &gt; <span class="number">1</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点比父节点更优，则交换</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[i &gt;&gt; <span class="number">1</span>]) &#123; </span><br><span class="line">            <span class="built_in">Swap</span>(a[i], a[i &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 已经满足堆的性质，可以退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="回顾链式前向星建图">回顾链式前向星建图</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1100</span>;      <span class="comment">// 最大点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm = <span class="number">110000</span>;    <span class="comment">// 最大边数</span></span><br><span class="line"><span class="type">int</span> first[maxn];    <span class="comment">// 每个顶点发出的边的边链表头顶点，可初始化为 -1 </span></span><br><span class="line"><span class="type">int</span> nex[maxm];      <span class="comment">// 同个顶点发出的边的边顶点 next 域</span></span><br><span class="line"><span class="type">int</span> u[maxm];        <span class="comment">// 边的发出顶点</span></span><br><span class="line"><span class="type">int</span> v[maxm];        <span class="comment">// 边的收入顶点</span></span><br><span class="line"><span class="type">int</span> w[maxm];        <span class="comment">// 边的权值</span></span><br><span class="line"><span class="type">int</span> tp;             <span class="comment">// 全局&quot;内存分配&quot;&quot;指针&quot;，就是模拟分配内存时，tp从0开始逐个增加</span></span><br></pre></td></tr></table></figure>
<p>如果不习惯数组式组织数据，写成结构体也可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> nex;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line">Edge e[maxn];</span><br><span class="line"><span class="type">int</span> first[maxn]</span><br><span class="line"><span class="type">int</span> tp;</span><br></pre></td></tr></table></figure>
<img src="/2025-05-08-30-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%801/%E5%89%8D%E5%90%91%E6%98%9F.svg" class="">
<h3 id="prim算法朴素版">Prim算法（朴素版）</h3>
<p>假设我们需要在 <span class="math inline">\(n\)</span>
个城市之间建立通信网络。为了确保所有城市都能相互通信，我们需要铺设 <span
class="math inline">\(n-1\)</span> 条线路。</p>
<p>虽然任意两个城市之间都可以铺设线路（总共有 <span
class="math inline">\(\frac{n(n-1)}{2}\)</span>
条可能的线路），但每条线路都有不同的建设成本。我们的目标是选择 <span
class="math inline">\(n-1\)</span> 条线路，使得总成本最小。</p>
<p>Prim算法采用贪心的思想来解决这个问题：</p>
<ol type="1">
<li>从任意一个城市开始，将其加入已选城市集合</li>
<li>在已选城市集合和未选城市集合之间，选择成本最低的线路</li>
<li>将这条线路连接的新城市加入已选城市集合</li>
<li>重复步骤2和3，直到所有城市都被选中</li>
</ol>
<p>这种算法特别适合城市数量较多、线路较密集的情况。</p>
<img src="/2025-05-08-30-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%801/prim.gif" class="">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释由 AI 生成</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">110</span>;                       <span class="comment">// 最大城市数量</span></span><br><span class="line"><span class="type">int</span> g[maxn][maxn];                          <span class="comment">// 邻接矩阵，存储城市间的距离</span></span><br><span class="line"><span class="type">int</span> key[maxn];                              <span class="comment">// 每个城市到已选城市集合的最小距离</span></span><br><span class="line"><span class="type">int</span> fixed[maxn];                            <span class="comment">// 标记城市是否已加入生成树</span></span><br><span class="line"><span class="type">int</span> last[maxn];                             <span class="comment">// 记录每个城市是通过哪个城市加入生成树的</span></span><br><span class="line"><span class="type">int</span> t, n, m, tmpLen, start;                 <span class="comment">// t:测试用例数 n:城市数 m:线路数 start:起始城市</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;                           <span class="comment">// Prim算法实现，返回最小生成树的总长度</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;                                <span class="comment">// 最小生成树的总长度</span></span><br><span class="line">    <span class="built_in">memset</span>(key, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(key));             <span class="comment">// 初始化所有城市到已选集合的距离为无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(fixed, <span class="number">0</span>, <span class="built_in">sizeof</span>(fixed));            <span class="comment">// 初始化所有城市都未加入生成树</span></span><br><span class="line">    key[start] = <span class="number">0</span>;                             <span class="comment">// 起始城市到已选集合的距离为0</span></span><br><span class="line">    last[start] = <span class="number">-1</span>;                           <span class="comment">// 起始城市没有前驱城市</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;                <span class="comment">// 循环n次，每次选择一个城市加入生成树</span></span><br><span class="line">        <span class="type">int</span> minKey = <span class="number">0x3f3f3f3f</span>;                <span class="comment">// 当前未选城市到已选集合的最小距离</span></span><br><span class="line">        <span class="type">int</span> minKeyNode;                         <span class="comment">// 对应的城市编号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)              <span class="comment">// 遍历所有城市</span></span><br><span class="line">            <span class="keyword">if</span>(!fixed[j] &amp;&amp; key[j] &lt; minKey) &#123;  <span class="comment">// 如果城市未加入生成树且距离更小</span></span><br><span class="line">                minKey = key[j];                <span class="comment">// 更新最小距离</span></span><br><span class="line">                minKeyNode = j;                 <span class="comment">// 记录对应的城市</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        fixed[minKeyNode] = <span class="literal">true</span>;               <span class="comment">// 将选中的城市加入生成树</span></span><br><span class="line">        ret += key[minKeyNode];                 <span class="comment">// 累加这条边的长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)              <span class="comment">// 更新其他未选城市到已选集合的距离</span></span><br><span class="line">            <span class="keyword">if</span>(!fixed[j] &amp;&amp; g[minKeyNode][j] != <span class="number">0</span> &amp;&amp; g[minKeyNode][j] &lt; key[j]) &#123;</span><br><span class="line">                key[j] = g[minKeyNode][j];      <span class="comment">// 如果通过新加入的城市距离更短，则更新</span></span><br><span class="line">                last[j] = minKeyNode;           <span class="comment">// 记录是通过哪个城市加入的</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;                                 <span class="comment">// 返回最小生成树的总长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(O(n^2)\)</span>，$n为顶点数。</p>
<h3 id="kruskal算法">Kruskal算法</h3>
<p>Kruskal算法采用了另一种思路：</p>
<ol type="1">
<li>首先将所有可能的线路按照成本从低到高排序</li>
<li>从成本最低的线路开始，依次检查每条线路</li>
<li>如果这条线路连接的两个城市还没有通过其他线路连通，就选择这条线路</li>
<li>重复步骤2和3，直到所有城市都能相互通信</li>
</ol>
<p>这种算法特别适合城市数量较多、但实际线路较少的情况。</p>
<p>Kruskal算法需要频繁判断两个城市是否已经连通，这正好是并查集的强项。在实现中：</p>
<ol type="1">
<li>初始时，每个城市自成一个集合</li>
<li>当选择一条线路时，将线路连接的两个城市所在的集合合并</li>
<li>判断两个城市是否连通，只需看它们是否在同一个集合中</li>
</ol>
<p>并查集通过路径压缩优化，使得查找和合并操作的时间复杂度接近 <span
class="math inline">\(O(1)\)</span>。</p>
<img src="/2025-05-08-30-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%801/kruskal.gif" class="">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释由 AI 生成</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KNode</span> &#123;                                      <span class="comment">// 存储边的信息</span></span><br><span class="line">    <span class="type">int</span> len;                                        <span class="comment">// 边的长度</span></span><br><span class="line">    <span class="type">int</span> s, e;                                       <span class="comment">// 边的起点和终点</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> KNode &amp;b) <span class="type">const</span> &#123;          <span class="comment">// 重载小于运算符，用于排序</span></span><br><span class="line">        <span class="keyword">return</span> len == b.len ? s &lt; b.s : len &lt; b.len;<span class="comment">// 长度相同时按起点编号排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">KNode</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">KNode</span>(<span class="type">int</span> l_, <span class="type">int</span> s_, <span class="type">int</span> e_): <span class="built_in">len</span>(l_), <span class="built_in">s</span>(s_), <span class="built_in">e</span>(e_) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">KNode eg[maxn * maxn];                              <span class="comment">// 存储所有可能的边</span></span><br><span class="line"><span class="type">int</span> etp;                                            <span class="comment">// 边的数量</span></span><br><span class="line"><span class="type">int</span> p[maxn];                                        <span class="comment">// 并查集数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fa</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;                                     <span class="comment">// 查找i所在集合的代表元素</span></span><br><span class="line">    <span class="keyword">return</span> p[i] == i ? i : p[i] = <span class="built_in">fa</span>(p[i]);        <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;                                    <span class="comment">// Kruskal算法实现</span></span><br><span class="line">    etp = <span class="number">0</span>;                                        <span class="comment">// 初始化边的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)                      <span class="comment">// 遍历所有城市对</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] != <span class="number">0</span>)                        <span class="comment">// 如果两个城市之间有线路</span></span><br><span class="line">                eg[etp++] = <span class="built_in">KNode</span>(g[i][j], i, j);   <span class="comment">// 将这条边加入数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(eg, eg + etp);                             <span class="comment">// 按边的长度排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)                      <span class="comment">// 初始化并查集</span></span><br><span class="line">        p[i] = i;                                   <span class="comment">// 每个城市自成一个集合</span></span><br><span class="line">    </span><br><span class="line">    rtp = <span class="number">0</span>;                                        <span class="comment">// 初始化结果边的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; etp; i++) &#123;                  <span class="comment">// 遍历所有边</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fa</span>(eg[i].s) == <span class="built_in">fa</span>(eg[i].e))             <span class="comment">// 如果边的两个端点已经在同一个集合中</span></span><br><span class="line">            <span class="keyword">continue</span>;                               <span class="comment">// 跳过这条边</span></span><br><span class="line">        </span><br><span class="line">        p[<span class="built_in">fa</span>(eg[i].s)] = <span class="built_in">fa</span>(eg[i].e);              <span class="comment">// 合并两个集合</span></span><br><span class="line">        res[rtp][<span class="number">0</span>] = eg[i].s;                      <span class="comment">// 记录这条边的起点</span></span><br><span class="line">        res[rtp][<span class="number">1</span>] = eg[i].e;                      <span class="comment">// 记录这条边的终点</span></span><br><span class="line">        rtp++;                                      <span class="comment">// 结果边数加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(O(mlogm)\)</span>，<span
class="math inline">\(m\)</span>为边数。</p>
<h2 id="最短路">最短路</h2>
<h3 id="暴力最短路floyd">暴力最短路——Floyd</h3>
<p>求图中<strong>两两之间最短路</strong>。</p>
<p>基于动态规划思想的算法:</p>
<p>对于任意两点 <span class="math inline">\(i\)</span> 和 <span
class="math inline">\(j\)</span>
之间的最短路径,要么是直接相连的边,要么需要经过其他点作为中转。可以枚举所有可能的中转点
<span class="math inline">\(k\)</span>,不断更新 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span> 的最短距离。</p>
<p>具体来说:</p>
<ol type="1">
<li><span class="math inline">\(d_k(i,j)\)</span> 表示从 i 到 j
路径上编号不超过 k 的最短路长度</li>
<li>初始状态: <span class="math inline">\(d_0(i,j) =
w(i,j)\)</span></li>
<li>状态转移: <span class="math inline">\(d_k(i,j) = min\{d_{k-1}(i,j),
d_{k-1}(i,k) + d_{k-1}(k,j)\}\)</span>, 其中 <span
class="math inline">\(1 \leq i,j,k \leq n, i \neq k, j \neq
k\)</span></li>
</ol>
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// 节点范围[1, n]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][k] + g[k][j], g[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(O(n^3)\)</span></p>
<h3 id="例加速通道">例：加速通道</h3>
<p>给定一个无向图 <span class="math inline">\(G=(V,E)\)</span>，其中
<span class="math inline">\(|V|=n\)</span> 个顶点，<span
class="math inline">\(|E|=m\)</span> 条边。每条边 <span
class="math inline">\(e \in E\)</span> 有一个权重 <span
class="math inline">\(w(e)\)</span> 表示通过该边所需时间。</p>
<p>现在可以选择一条边 <span
class="math inline">\(e\)</span>，将其权重变为 <span
class="math inline">\(\lfloor \frac{w(e)}{2} \rfloor\)</span>。求从顶点
<span class="math inline">\(1\)</span> 到顶点 <span
class="math inline">\(n\)</span> 的最短路径长度。</p>
<p>输入： - 不超过 <span class="math inline">\(50\)</span> 组测试数据 -
每组第一行两个整数 <span
class="math inline">\(n,m\)</span>，表示顶点数和边数 - 接下来 <span
class="math inline">\(m\)</span> 行，每行三个整数 <span
class="math inline">\(s,e,t\)</span>，表示顶点 <span
class="math inline">\(s\)</span> 和 <span
class="math inline">\(e\)</span> 之间有一条权重为 <span
class="math inline">\(t\)</span> 的无向边 - <span
class="math inline">\(2 \leq n \leq 100\)</span>，<span
class="math inline">\(1 \leq m \leq 2000\)</span> - 保证顶点 <span
class="math inline">\(1\)</span> 和 <span
class="math inline">\(n\)</span> 连通</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 6</span><br><span class="line">2 3 6</span><br><span class="line">1 3 13</span><br><span class="line">5 6</span><br><span class="line">4 3 3</span><br><span class="line">4 5 18</span><br><span class="line">3 4 0</span><br><span class="line">3 5 2</span><br><span class="line">2 3 10</span><br><span class="line">4 1 6</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>每组数据输出一个整数，表示安装加速通道后的最短路径长度</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>这是一个稠密图问题（节点少边多），适合用Floyd算法求任意两点间最短路。</p>
<p>对每条边 <span class="math inline">\(e\)</span>，计算 <span
class="math inline">\(\min\{dist[1][u] + \lfloor \frac{w(e)}{2} \rfloor
+ dist[v][n]\}\)</span>，其中 <span class="math inline">\(u,v\)</span>
是边 <span class="math inline">\(e\)</span> 的两端点，<span
class="math inline">\(dist[i][j]\)</span> 是 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span>
的最短路。取所有边中的最小值即为答案。</p>
<p>注意:同一对点之间可能有多条边，要保留权值最小的边。时间复杂度O(n³)。</p>
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, g[maxn][maxn], orig[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                g[i][j] = std::<span class="built_in">min</span>(g[i][k] + g[k][j], g[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF &amp;&amp; (n || m)) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0x0f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">while</span>(m --) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            g[a][b] = g[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(orig, g, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">Floyd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            g[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0x0f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                ans = std::<span class="built_in">min</span>(ans, g[<span class="number">1</span>][i] + orig[i][j] / <span class="number">2</span> + g[j][n]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单源最短路dijkstra朴素版">单源最短路——Dijkstra（朴素版）</h3>
<p>一个特定的顶点，到一个特定的终点的最短路 —— Dijkstra算法</p>
<p>算法思想类似最小生成树的 Prim</p>
<p>区别：每次优先的顶点不再是连通分量发出的最短边指向的顶点，而是与源点总距离最短的顶点，直到终点是优先点为止</p>
<img src="/2025-05-08-30-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%801/dijkstra.gif" class="">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(fixed, <span class="number">0</span>, <span class="built_in">sizeof</span>(fixed));</span><br><span class="line">    last[start] = <span class="number">-1</span>;</span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minDisNode, minDis;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        minDis = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!fixed[j] &amp;&amp; dis[j] &lt; minDis) </span><br><span class="line">                minDisNode = j, minDis = dis[j];</span><br><span class="line">        fixed[minDisNode] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(g[minDisNode][j] != <span class="number">0</span> &amp;&amp; minDis + g[minDisNode][j] &lt; dis[j])</span><br><span class="line">                dis[j] = minDis + g[minDisNode][j], last[j] = minDisNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(O(n^2)\)</span></p>
<h2 id="堆优化的prim与dijkstra">堆优化的Prim与Dijkstra</h2>
<ul>
<li>Prim 每一步要在已选和未选之间找成本最低边</li>
<li>Dijkstra 每一步要在未确定距离点中找距离源点最近点</li>
</ul>
<p>这两件事都可以把待考查集合由优先队列管理，每次快速找到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii; <span class="comment">// 预定义数据对，first为结点与起点距离，second为结点编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处 “, vector&lt;pii&gt;, greater&lt;pii&gt; ” 用于让优先队列构建大顶堆，从而每次出队为最小值</span></span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis)); <span class="comment">// 初始化结点与起点距离为无穷大</span></span><br><span class="line">    dis[start] = <span class="number">0</span>;                 <span class="comment">// 起点距离起点为0</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">pii</span>(<span class="number">0</span>, start));          <span class="comment">// 起点放入优先级队列</span></span><br><span class="line">    last[start] = <span class="number">-1</span>;               <span class="comment">// 记录路径，起点的“上一个”为空</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pii now = q.<span class="built_in">top</span>();  <span class="comment">// 优先级队列队顶用“top”而不用“front”</span></span><br><span class="line">        q.<span class="built_in">pop</span>();            <span class="comment">// 出队</span></span><br><span class="line">        <span class="comment">// 如果出队结点记录的距离不是最新的距离，则丢弃该出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(now.first != dis[now.second]) <span class="keyword">continue</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对每个与 now.second 相连接的结点，看是否能更新该结点与起点的距离</span></span><br><span class="line">            <span class="comment">// 能更新则更新后将该结点入队</span></span><br><span class="line">            <span class="keyword">if</span>(g[now.second][i] != <span class="number">0</span> &amp;&amp; now.first + g[now.second][i] &lt; dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i] = now.first + g[now.second][i];</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">pii</span>(dis[i], i));</span><br><span class="line">                last[i] = now.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用堆优化后的 Prim 算法时间复杂度为 <span
class="math inline">\(O(m\log n)\)</span>，其中 <span
class="math inline">\(n\)</span> 为顶点数，<span
class="math inline">\(m\)</span>
为边数。对于稀疏图（即边数远小于顶点数平方，<span
class="math inline">\(m \ll n^2\)</span>），这个复杂度明显优于朴素 Prim
算法的 <span class="math inline">\(O(n^2)\)</span> 复杂度。</p>
<p>总的来说，各算法在使用堆优化后的时间复杂度如下：</p>
<ul>
<li>Prim 算法：堆优化前 <span class="math inline">\(O(n^2)\)</span>
，堆优化后 <span class="math inline">\(O(m\log n)\)</span></li>
<li>Dijkstra 算法：堆优化前 <span class="math inline">\(O(n^2)\)</span>
，堆优化后 <span class="math inline">\(O((m+n)\log n)\)</span></li>
</ul>
<p>效果要看 <span class="math inline">\(m\)</span> 与 <span
class="math inline">\(n\)</span> 的大小关系，越稀疏（边数少），<span
class="math inline">\(m\)</span>越接近<span
class="math inline">\(n\)</span>，堆优化效果越好；越稠密，<span
class="math inline">\(m\)</span>越接近<span
class="math inline">\(n^2\)</span>，效果就变差了。</p>
<h2 id="拓扑排序">拓扑排序</h2>
<p>有向无环图简称DAG（directed acycline
graph）图，任何点无法通过一系列有向边回到该点，因为无环，顶点就有前后顺序（允许并列）</p>
<p>例：一项工程，有a、b、c、...一系列任务，有的任务必须在其它特定任务完成后才能执行，比如
a 执行后才能开始执行
b，等等一系列规则，假如只能单线程执行任务，在此规则下，给出一个可行的任务执行顺序。</p>
<p>任务执行的先后关系就可以作为有向边，合法的数据不可能出现a-&gt;b-&gt;c-&gt;a的死锁，那就是先有鸡还是先有蛋的问题了，所以工程的任务会建成一个
DAG 图，一个正确的拓扑排序，便是一个可行的任务执行顺序——可以有多种解</p>
<p><strong>入度与出度</strong></p>
<p>对于无向图，一个点发出一条边就是一个度</p>
<p>对于有向图，一个点发出一条边就是一个出度，收入一条边就是一个入度。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">C--&gt;A--&gt;B</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">    D</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">点</th>
<th style="text-align: center;">入度</th>
<th style="text-align: center;">出度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>基于入度的拓扑排序算法：以工程例题来说</p>
<ul>
<li>一个顶点入度为 0 ，则意味着该顶点不需要完成其它任务即可开始</li>
<li>当执行完该任务，则依赖该任务的其它任务都可以减少一个入度——减少了一个依赖</li>
<li>继续寻找入度为 0 的顶点，重复操作直至所有任务执行</li>
</ul>
<img src="/2025-05-08-30-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%801/topo.gif" class="">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TopoSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    rtp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化，用于接下来统计入度</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i ++) ind[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="comment">// g[i][j] 表示存在 i 到 j 的有向边</span></span><br><span class="line">            ind[j] += g[i][j];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n &amp;&amp; ind[j]; j ++);</span><br><span class="line">        <span class="comment">// 找到一个入度为 0 的顶点 j</span></span><br><span class="line">        res[rtp ++] = j;</span><br><span class="line">        ind[j] = <span class="number">-1</span>;  <span class="comment">// 标记该顶点已取出</span></span><br><span class="line">        <span class="comment">// 顶点 j 发出的有向边指向的顶点入度都减1</span></span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n; k ++)</span><br><span class="line">            ind[k] -= g[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>31.图论基础2</title>
    <url>/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h1 id="图论基础2">图论基础2</h1>
<p>从网络与流的基本概念出发，讨论最大流问题及其求解算法，包括Ford-Fulkerson方法、Edmonds-Karp算法和Dinic算法。介绍最大流最小割定理，以及费用流问题和二分图匹配问题。</p>
<span id="more"></span>
<h2 id="网络与流">网络与流</h2>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E6%B5%81%E7%BD%91%E7%BB%9C%E7%A4%BA%E4%BE%8B.svg" class="">
<p>网络（流网络，Flow Network）定义：</p>
<ul>
<li>有向图 <span class="math inline">\(G=(V,E)\)</span></li>
<li>每条边 <span class="math inline">\((u,v)\in E\)</span> 有权值 <span
class="math inline">\(c(u,v)\)</span> 表示容量（物料的最大流速）</li>
<li><span class="math inline">\((u,v)\notin E\)</span> 时 <span
class="math inline">\(c(u,v)=0\)</span></li>
<li>有两个特殊的点：源点 <span class="math inline">\(s\in
V\)</span>，汇点 <span class="math inline">\(t\in V\)</span></li>
</ul>
<p>其实就是有向图。</p>
<p>流：<span class="math inline">\(f(u,v)\)</span> 定义在 <span
class="math inline">\((u\in V, v\in V)\)</span> 上的实数函数且满足：</p>
<ul>
<li>容量限制：<span class="math inline">\(f(u,v)\leq c(u,v)\)</span>
&gt; 每条边流量不能超过容量</li>
<li>流量守恒：<span class="math inline">\(\forall u\in
V-\{s,t\}\)</span> 有 <span class="math inline">\(\sum_{v\in
V}f(v,u)=\sum_{u\in V}f(u,v)\)</span> &gt; 源点<span
class="math inline">\(s\)</span>流出多少，最终都一定全部流入汇点<span
class="math inline">\(t\)</span></li>
<li>除源点 <span class="math inline">\(s\)</span> 和汇点 <span
class="math inline">\(t\)</span> 外，流入节点的总量等于节点流出的总量
&gt; 除源点和汇点外，每个点流入多少就必须流出多少，不会“囤积”</li>
<li>"流"的流量：<span class="math inline">\(|f|=\sum_{v\in
V}f(s,v)-\sum_{v\in V}f(v,s)\)</span> &gt; 源点<span
class="math inline">\(s\)</span>总共流出了多少，或者说汇点<span
class="math inline">\(t\)</span>总共流入了多少</li>
</ul>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E6%B5%81%E7%9A%84%E5%AE%9A%E4%B9%89%E7%A4%BA%E4%BE%8B.svg" class="">
<p>多个源点汇点的网络，可以添加超级源点与超级汇点，转换为常规的流网络</p>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E5%A4%9A%E4%B8%AA%E6%BA%90%E7%82%B9%E6%B1%87%E7%82%B9%E7%9A%84%E8%BD%AC%E6%8D%A2.svg" class="">
<h2 id="最大流">最大流</h2>
<p>最大流：流网络中符合流的限制条件的 <span
class="math inline">\(|f|\)</span> 最大的流 <span
class="math inline">\(f\)</span></p>
<p>最大流也是一个线性规划问题：</p>
<p><span class="math inline">\(\max |f| = \sum_{v\in V}f(s,v) -
\sum_{v\in V}f(v,s)\)</span></p>
<p>s.t. <span class="math inline">\(f(i,j) \leq c(i,j)\)</span>, <span
class="math inline">\((i,j)\in E\)</span></p>
<p><span class="math inline">\(\sum_{j\in V}f(i,j) = \sum_{j\in
V}f(j,i)\)</span>, <span class="math inline">\(i\in
V-\{s,t\}\)</span></p>
<p><span class="math inline">\(f(i,j) \geq 0\)</span>, <span
class="math inline">\((i,j)\in E\)</span></p>
<p><span class="math inline">\(|f| \geq 0\)</span></p>
<p>求解线性规划的算法可以解最大流，不过最大流有更有效的方法</p>
<h3 id="ford-fulkerson-方法">Ford-Fulkerson 方法</h3>
<p>"方法"而不是"算法"：Ford-Fulkerson有不同的实现方式</p>
<p>先做一个预设：让<span
class="math inline">\(f(u,v)=-f(v,u)\)</span>，<strong>即<span
class="math inline">\(u\)</span>流向<span
class="math inline">\(v\)</span>的流量，可以抽象地看作有有个<span
class="math inline">\(v\)</span>流向<span
class="math inline">\(u\)</span>的负流量</strong>。</p>
<ul>
<li>残存网络：<span
class="math inline">\(c_f(u,v)=c(u,v)-f(u,v)\)</span> &gt;
每条边还能增加多少流量</li>
<li>增广路：残存网络中<span class="math inline">\(s\)</span>到<span
class="math inline">\(t\)</span>的简单路径 &gt; 沿着能增加流量的边，从
<span class="math inline">\(s\)</span> 走到 <span
class="math inline">\(t\)</span>
的路径，说明这条路径整体可以增加流量</li>
<li>残存容量：增广路上能加推的最大流量 &gt;
这条增广路必然有个边能增加的流量最小，是瓶颈，导致整条路径最多只能增加这么多流量</li>
<li>抵消操作：增广路加推流量时，部分边撤回的原流量 &gt; 把一个边 <span
class="math inline">\(A\rightarrow B\)</span>
的流量“撤回去”，相当于反向边 <span class="math inline">\(B \rightarrow
A\)</span> 的流量增加了</li>
</ul>
<p>如果残存网络不包含增广路径，那么就无法增加流了，说明已得到最大流</p>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E6%AE%8B%E5%AD%98%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%A2%9E%E5%B9%BF%E8%B7%AF.svg" class="">
<p>算法设计思路：不断寻找增广路</p>
<h3 id="edmonds-karp算法">Edmonds-Karp算法</h3>
<ol type="1">
<li>从<span class="math inline">\(s\)</span>出发 BFS 找到<span
class="math inline">\(t\)</span>，得到增广路<span
class="math inline">\(p\)</span></li>
<li>计算路径各边在残存网络的最小值<span
class="math inline">\(\delta\)</span></li>
<li>给<span class="math inline">\(p\)</span>的每条边加上<span
class="math inline">\(\delta\)</span>的流量</li>
<li>重复1~4，直到没有增广路</li>
</ol>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/EK%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F.svg" class="">
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/ek.gif" class="">
<h3 id="dinic算法">Dinic算法</h3>
<p>对残存网络分层：</p>
<p>用BFS根据各节点到 <span class="math inline">\(s\)</span>
的距离分层，得到残存网络的分层图</p>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/dinic%E5%88%86%E5%B1%82%E5%9B%BE.svg" class="">
<p>分析：</p>
<ol type="1">
<li>每次基于BFS的分层网络推流，只会沿着从s到t的最短路径推流。这是因为BFS分层保证了每个节点的层数就是其到源点s的最短距离。</li>
<li>当一轮推流结束后，原来的最短路径必然会被"堵死"（至少有一条边的残余容量变为0）。否则还可以继续在这条路径上推流，与"一轮结束"矛盾。</li>
<li>因此下一轮BFS时，s到t的最短路径长度一定会增加。这是因为:
<ul>
<li>原来的最短路径已经不存在于残存网络中</li>
<li>新的最短路径必然要绕过"堵死"的边，所以路径会更长</li>
</ul></li>
<li>由于图中s到t的路径长度不可能超过节点数n，且每轮至少增加1，所以:
<ul>
<li>最短路径长度从1开始增长</li>
<li>最多增长到n-1就会终止</li>
<li>总轮数不超过n-1轮</li>
</ul></li>
<li>这保证了算法在有限步内一定会终止，且找到最大流</li>
</ol>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/dinic.gif" class="">
<p>参考代码</p>
<p>前向星建图</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fst[maxn];  <span class="comment">// 每个顶点发出的边的边链表头节点，可初始化为 -1 表示每个顶点都还没有边</span></span><br><span class="line"><span class="type">int</span> nex[maxm];  <span class="comment">// 同个顶点发出的边的边节点 next 域</span></span><br><span class="line"><span class="type">int</span> v[maxm];    <span class="comment">// 边的收入顶点</span></span><br><span class="line"><span class="type">int</span> cap[maxm];  <span class="comment">// 边的容量，同时用作残存网络计算</span></span><br><span class="line"><span class="type">int</span> tp;         <span class="comment">// 分配“内存”的模拟游标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    v[tp] = b;          <span class="comment">// 边tp的收入点是b</span></span><br><span class="line">    cap[tp] = w;        <span class="comment">// 容量是w</span></span><br><span class="line">    nex[tp] = fst[a];   <span class="comment">// 头插法为顶点a的边链表插入tp这条边</span></span><br><span class="line">    fst[a] = tp ++;     <span class="comment">// 新增边的游标为tp，之后让tp指向“下一块内存”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DbEdge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="built_in">AddEdge</span>(a, b, w);   <span class="comment">// 添加正向边</span></span><br><span class="line">    <span class="built_in">AddEdge</span>(b, a, <span class="number">0</span>);   <span class="comment">// 反向边容量为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS 建立分层网络</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ly[maxn], work[maxn], n, m, so, te;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DiBFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="built_in">memset</span>(ly, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ly));   <span class="comment">// 初始化各节点的层</span></span><br><span class="line">    q.<span class="built_in">push</span>(so); ly[so] = <span class="number">0</span>;                     <span class="comment">// 源点入队，层为0</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;                         <span class="comment">// 开始BFS</span></span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = fst[now]; i != <span class="number">-1</span>; i = nex[i]) &#123;    <span class="comment">// 枚举当前点发出的边</span></span><br><span class="line">            <span class="keyword">if</span>(ly[v[i]] &gt;= <span class="number">0</span> || !cap[i]) <span class="keyword">continue</span>;      <span class="comment">// 该边收入点已分层或无容量跳过</span></span><br><span class="line">            ly[v[i]] = ly[now] + <span class="number">1</span>;                     <span class="comment">// 该边收入点为下一层</span></span><br><span class="line">            <span class="keyword">if</span>(v[i] == te) <span class="keyword">return</span> <span class="literal">true</span>;                 <span class="comment">// 找到汇点可以结束</span></span><br><span class="line">            q.<span class="built_in">push</span>(v[i]);                               <span class="comment">// 收入点入队继续BFS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单次DFS推流</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DiDFS</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> inc)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tinc;</span><br><span class="line">    <span class="keyword">if</span>(cur == te) <span class="keyword">return</span> inc;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;i = work[cur]; i != <span class="number">-1</span>; i = nex[i]) &#123;      <span class="comment">// 遍历cur发出的边，游标work不重置</span></span><br><span class="line">        <span class="keyword">if</span>(cap[i] &amp;&amp; ly[v[i]] == ly[cur] + <span class="number">1</span> &amp;&amp;         <span class="comment">// 只沿着层增加方向</span></span><br><span class="line">            (tinc = <span class="built_in">DiDFS</span>(v[i], <span class="built_in">min</span>(inc, cap[i]))))&#123;    <span class="comment">// 取路径上最小容量</span></span><br><span class="line">            cap[i] -= tinc;         <span class="comment">// 正向边残存网络容量减小</span></span><br><span class="line">            cap[i ^ <span class="number">1</span>] += tinc;     <span class="comment">// 反向边残存网络容量增加</span></span><br><span class="line">            <span class="keyword">return</span> tinc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用DFS推流在分层图上反复推流直到断开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>, tinc;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">DiBFS</span>()) &#123;    <span class="comment">// 计算分层图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) work[i] = fst[i];  <span class="comment">// 初始化工作游标</span></span><br><span class="line">        <span class="keyword">while</span>(tinc = <span class="built_in">DiDFS</span>(so, inf)) ret += tinc;       <span class="comment">// DFS推多次流，游标不重置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Dinic算法中，work数组实现了<strong>弧优化(arc
optimization)</strong>，这是一个重要的优化技巧。</p>
<p>work数组记录了每个节点当前遍历到的边的位置。当一条边被证明无法增广时，下次DFS到达这个节点时就不需要从头开始遍历，而是从上次遍历到的位置继续。</p>
<ol type="1">
<li>每次BFS建立分层图后，<code>work[i]</code>被初始化为<code>fst[i]</code>，即每个点的第一条边</li>
<li>在DFS过程中，如果某条边无法增广，<code>work[i]</code>会自动移动到下一条边</li>
<li>由于分层图中的流量只能沿着层数增加的方向推送，一旦某条边无法增广，在当前分层图中它就永远无法增广了</li>
<li>因此不需要在下一次DFS时重新检查这条边，直接从<code>work[i]</code>记录的位置继续即可</li>
</ol>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/arc_opt.gif" class="">
<h3 id="最大流最小割定理">最大流最小割定理</h3>
<p><strong>割(Cut)</strong>:</p>
<p>将所有点划分为 <span class="math inline">\(S\)</span> 和 <span
class="math inline">\(V-S\)</span> 两个集合，其中源点 <span
class="math inline">\(s \in S\)</span>，汇点 <span
class="math inline">\(t \in T\)</span>。</p>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E6%9C%80%E5%B0%8F%E5%89%B2.svg" class="">
<p><strong>割的容量</strong>:</p>
<ul>
<li><span class="math inline">\(c(S,T)\)</span> 表示从集合 <span
class="math inline">\(S\)</span> 到集合 <span
class="math inline">\(T\)</span> 的所有边的容量之和</li>
<li>也可以用 <span class="math inline">\(c(s,t)\)</span> 表示 <span
class="math inline">\(c(S,T)\)</span></li>
</ul>
<p><strong>最小割(Minimum Cut)</strong>:</p>
<p>求一个割 <span class="math inline">\((S,T)\)</span> 使得割的容量
<span class="math inline">\(c(S,T)\)</span> 最小</p>
<p>最小割与最大流的关系可以这样理解:</p>
<p>想象一个水管系统，从源点 <span class="math inline">\(s\)</span>
向汇点 <span class="math inline">\(t\)</span>
输送水，如果要切断水流，必须切断所有从 <span
class="math inline">\(S\)</span> 到 <span
class="math inline">\(T\)</span>
的管道，为了代价最小，我们要找到容量和最小的一组管道切断，这组管道就构成了最小割，而这些管道的容量和，恰好等于系统能输送的最大水流量</p>
<p>最大流最小割定理即： <strong>最大流的值等于最小割的值</strong></p>
<h3 id="例最小割点">例：最小割点</h3>
<p>两台电脑通过一系列诸如交换机、路由器等网络设备通信，只要还有网络设备连通它们，就能互相通信，给定它们的相连关系，至少坏掉几个网络设备，会使这两台电脑无法通信？</p>
<p>拆点为边，求最小割集</p>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E6%8B%86%E7%82%B9.svg" class="">
<p>拆点建图参考</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设两个设备编号1和2，其余点输入编号 2~n</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">InP</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * <span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">OutP</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * <span class="number">2</span> + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">while</span>(m --) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);  <span class="comment">// a、b之间有条边</span></span><br><span class="line">    <span class="comment">// 重新编号，把节点 x 拆成两个点，“入点”编号为 x*2，“出点”编号为 x*2+1</span></span><br><span class="line">    <span class="comment">// a*2+1 作为出点，连一条发往入点 b*2 的边，反之同理</span></span><br><span class="line">    <span class="built_in">DbEdge</span>(<span class="built_in">OutP</span>(a), <span class="built_in">InP</span>(b), inf);</span><br><span class="line">    <span class="built_in">DbEdge</span>(<span class="built_in">OutP</span>(b), <span class="built_in">InP</span>(a), inf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    <span class="built_in">DbEdge</span>(<span class="built_in">InP</span>(i), <span class="built_in">OutP</span>(i), <span class="number">1</span>); <span class="comment">// 原始节点的“入点”向“出点”设置容量为 1 的边</span></span><br><span class="line">&#125;</span><br><span class="line">so = <span class="number">0</span>; te = (n + <span class="number">1</span>) * <span class="number">2</span>;       <span class="comment">// 新建源点为0，汇点为 (n+1) * 2，确保与现有编号不冲突</span></span><br><span class="line">n = (n + <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>;            <span class="comment">// 把节点数 n 改为实际建的点数</span></span><br><span class="line"><span class="built_in">DbEdge</span>(so, <span class="built_in">InP</span>(<span class="number">1</span>), inf); <span class="built_in">DbEdge</span>(so, <span class="built_in">OutP</span>(<span class="number">1</span>), inf);  <span class="comment">// 用新建的源点把不该拆的设备1的点“短路”</span></span><br><span class="line"><span class="built_in">DbEdge</span>(<span class="built_in">InP</span>(<span class="number">2</span>), te, inf); <span class="built_in">DbEdge</span>(<span class="built_in">OutP</span>(<span class="number">2</span>), te, inf);  <span class="comment">// 用新建的汇点把不该拆的设备2的点“短路”</span></span><br></pre></td></tr></table></figure>
<p>为什么这样建图有效：</p>
<ul>
<li>如果要删除一个节点，就必须切断其入点到出点的边</li>
<li>这条边的容量为<span
class="math inline">\(1\)</span>，表示删除这个节点的代价为<span
class="math inline">\(1\)</span></li>
<li>其他边的容量为<span
class="math inline">\(inf\)</span>，表示这些边不能被切断</li>
<li>最小割就会选择切断最少的入点-出点边，即删除最少的节点</li>
</ul>
<h2 id="费用流">费用流</h2>
<p>费用流是在最大流的基础上，给每条边增加一个费用属性，表示单位流量通过这条边需要付出的代价。</p>
<p>最小费用最大流问题就是在最大流的基础上，要求总费用最小。</p>
<h3 id="负圈">负圈</h3>
<p>一个图中有负数边，如何求最短路？</p>
<p>——可能没有最短路</p>
<p>如果存在负数圈，路径长度可以无限变小</p>
<p>Floyd
可以判负圈：执行算法求两两最短路，如果一个点到自己的距离为负，则说明有负圈。</p>
<h3 id="最小费用流-负回路算法">最小费用流-负回路算法</h3>
<p>在最大流算法的基础上：</p>
<ul>
<li>在辅助网络上构造新的可行流<span
class="math inline">\(f\)</span></li>
<li>在<span
class="math inline">\(f\)</span>上寻找费用为负数的圈（用Floyd），由流量守恒知，圈的流量为<span
class="math inline">\(0\)</span></li>
<li>在原流上不断叠加费用为负的圈，则总流量不变，总费用减少</li>
<li>重复<span class="math inline">\(1\sim
3\)</span>直到找不到费用为负的圈为止</li>
</ul>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81-%E8%B4%9F%E5%9B%9E%E8%B7%AF%E7%AE%97%E6%B3%95.svg" class="">
<h3 id="最小费用流-最短路径算法">最小费用流-最短路径算法</h3>
<p>不断通过<strong>费用最小的</strong>增广路增加流</p>
<p>该算法有多种实现形式，这里掌握一个类Dinic的写法</p>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E5%88%86%E5%B1%82%E5%9B%BE.svg" class="">
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E6%8E%A8%E6%B5%81.svg" class="">
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-%E4%B8%BB%E5%BE%AA%E7%8E%AF.svg" class="">
<h3 id="二分图匹配">二分图匹配</h3>
<p>设有4个申请读研的学生(<span
class="math inline">\(S_i\)</span>)与4位导师(<span
class="math inline">\(T_i\)</span>)：</p>
<p>每个导师最多只能招收1名学生，每个学生也只能跟随1名导师，下图的边表示学生想要申请的导师</p>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E4%BA%8C%E5%88%86%E5%9B%BE.svg" class="">
<p>如何分配学生与导师的对应关系，能够满足最多学生的志愿</p>
<p>匈牙利算法</p>
<p>假设我们已经找到了一些学生和导师的配对关系,我们把这些配对关系称为"匹配"。</p>
<p>在所有的连线中:</p>
<ul>
<li>已经配对的连线称为"匹配边"</li>
<li>还没有配对的连线称为"非匹配边"</li>
<li>已经配对的学生和导师称为"饱和点"</li>
</ul>
<p>如果我们沿着匹配边和非匹配边交替走,形成的路径就叫"交错路径"。</p>
<p>特别地,如果一条交错路径的起点和终点都是还没有配对的学生或导师(即非饱和点),我们就把这条路径叫做"增广交错路径"。</p>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E4%BA%8C%E5%88%86%E5%9B%BE-%E4%BA%A4%E9%94%99%E8%B7%AF%E5%BE%84.svg" class="">
<p>一个重要的性质:</p>
<p>如果我们找到了一条增广交错路径P,那么可以通过这条路径来增加匹配数:</p>
<ul>
<li>把路径P上的非匹配边变成匹配边</li>
<li>把路径P上的匹配边变成非匹配边</li>
</ul>
<p>这样操作后: 1. 得到的新的边集合仍然是一个合法的匹配 2.
新的匹配比原来的匹配多了一条边</p>
<p>这就说明,每找到一条增广交错路径,就能让匹配数增加1。</p>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/%E4%BA%8C%E5%88%86%E5%9B%BE-%E5%BC%82%E6%88%96%E5%A2%9E%E5%B9%BF.svg" class="">
<p>匈牙利算法的具体步骤如下:</p>
<ol type="1">
<li>先随便找一些配对关系作为初始匹配</li>
<li>重复以下步骤:
<ul>
<li>寻找一条增广交错路径</li>
<li>如果找到了,就沿着这条路径,把匹配边变成非匹配边,非匹配边变成匹配边</li>
<li>如果找不到增广交错路径了,算法结束</li>
</ul></li>
<li>此时得到的就是最大匹配</li>
</ol>
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SearchPath</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;                <span class="comment">// DFS寻找增广交错路线</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= yN; ++ v) &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][v] &amp;&amp; !chk[v]) &#123;        <span class="comment">// u-&gt;v 有边且 v 尚未搜索</span></span><br><span class="line">            chk[v] = <span class="literal">true</span>;              <span class="comment">// 标记搜索</span></span><br><span class="line">            <span class="keyword">if</span>(yM[v] == <span class="number">-1</span> || <span class="built_in">SearchPath</span>(yM[v]))&#123;</span><br><span class="line">                <span class="comment">// v 尚未匹配，或者 v 已匹配且沿着 v 的匹配对象找到增广交错路线</span></span><br><span class="line">                yM[v] = u, xM[u] = v;   <span class="comment">// 将 v 与 u 匹配，即执行交错路线的“异或”操作</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">// 表示找到增广交错路线</span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;                       <span class="comment">// 没找到增广交错路线</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hungarian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(xM, <span class="number">-1</span>, <span class="built_in">sizeof</span>(xM));         <span class="comment">// 初始化匹配对象为空</span></span><br><span class="line">    <span class="built_in">memset</span>(yM, <span class="number">-1</span>, <span class="built_in">sizeof</span>(yM));         <span class="comment">// 初始化匹配对象为空</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;                        <span class="comment">// 初始化匹配数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= xN; u ++) &#123;     <span class="comment">// 考察 x 这一边的每个点</span></span><br><span class="line">        <span class="keyword">if</span>(xM[u] == <span class="number">-1</span>) &#123;               <span class="comment">// 如果 u 没有匹配对象，尝试从 u 出发搜索</span></span><br><span class="line">            <span class="built_in">memset</span>(chk, <span class="literal">false</span>, <span class="built_in">sizeof</span>(chk));    <span class="comment">// 初始化DFS标记</span></span><br><span class="line">            ret += <span class="built_in">SearchPath</span>(u);       <span class="comment">// 如果找到增广交错路线，则匹配总数 +1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分图最大匹配与最大流">二分图最大匹配与最大流</h3>
<p>二分图的最大匹配问题可以转化为最大流问题来求解。具体做法是:</p>
<ol type="1">
<li>添加一个源点s和汇点t</li>
<li>从源点s向二分图左边所有点连边,容量为1</li>
<li>从二分图右边所有点向汇点t连边,容量为1</li>
<li>原二分图中的边改为从左向右的有向边,容量为1</li>
</ol>
<p>这样构造出的网络流模型中,最大流的值就等于原二分图的最大匹配数。因为:</p>
<ul>
<li>每条边容量为1,表示每个点最多只能匹配一次</li>
<li>从s到t的一条流量为1的路径,对应了二分图中的一个匹配</li>
</ul>
<img src="/2025-05-14-31-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%802/bigraph_flow.gif" class="">
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>32.平衡树</title>
    <url>/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<h1 id="平衡树">平衡树</h1>
<p>本章介绍平衡树的概念，详细讲解 AVL
树的平衡因子、四种平衡旋转操作及代码实现，并简介红黑树、Treap、SBT、B
树和 B +
树等其他平衡树。特别介绍了一种特殊的平衡树——伸展树的基本结构、核心操作、基本操作、序列操作、时间复杂度等内容。</p>
<span id="more"></span>
<h2 id="平衡树概念与avl">平衡树概念与AVL</h2>
<h3 id="回顾二叉排序查找树">回顾二叉排序（查找）树</h3>
<ul>
<li>若其左子树非空，则左子树上所有结点的值均小于根结点的值</li>
<li>若其右子树非空，则右子树上所有结点的值均大于等于根结点的值</li>
<li>其左右子树本身又各是一棵二叉排序树</li>
</ul>
<img src="/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.svg" class="">
<p>中序遍历二叉排序树后的结果有什么规律？</p>
<img src="/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.svg" class="">
<p>AVL树是最先发明的自平衡二叉查找树</p>
<p>二叉排序树的操作－删除</p>
<ul>
<li>如果所删结点 <span class="math inline">\(now\)</span>
左右子树有空树：用非空子树树根 <span class="math inline">\(nex\)</span>
顶替被删结点</li>
<li>否则用左子树中序最末结点 <span class="math inline">\(nex\)</span>
顶替被删节点 <span class="math inline">\(now\)</span>，并对 <span
class="math inline">\(nex\)</span> 再次执行删除操作</li>
</ul>
<img src="/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E5%88%A0%E9%99%A4.svg" class="">
<h3 id="平衡树-1">平衡树</h3>
<p>二叉排序树在退化情况下查找与插入性能降低，接近线性而不再是 <span
class="math inline">\(logn\)</span></p>
<p><span class="math inline">\(ASL\)</span>(Average Search
Length)：平均搜索长度</p>
<img src="/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91_%E9%80%80%E5%8C%96.svg" class="">
<p>在插入删除的过程中动态调整二叉树的姿态，尽可能保持<strong>任意子树</strong>的左右子树高度一致，即平衡树。</p>
<h3 id="avl">AVL</h3>
<p>AVL树是最先发明的自平衡二叉查找树，基于<strong>平衡因子</strong>实现</p>
<ul>
<li>平衡因子：该结点左子树与右子树的高度差</li>
<li>AVL树任一结点的平衡因子只能取：-1、0 或 1</li>
<li>对于一棵有n个结点的AVL树，其高度和ASL都保持在<span
class="math inline">\(O(log2n)\)</span></li>
</ul>
<p>判断下面两个树是否是 AVL</p>
<img src="/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91_%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6AVL.svg" class="">
<p>重要操作</p>
<p>平衡旋转：</p>
<p>在插入新节点时，需要调整树的结构以保持平衡。主要有以下四种情况：</p>
<ol type="1">
<li><code>LL</code>：在左子树的左子树插入节点
<ul>
<li>平衡因子由 <span class="math inline">\(1\)</span> 变为 <span
class="math inline">\(2\)</span></li>
<li>需要进行顺时针旋转</li>
</ul></li>
</ol>
<img src="/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91_LL.gif" class="">
<ol start="2" type="1">
<li><code>RR</code>：在右子树的右子树插入节点
<ul>
<li>平衡因子由 <span class="math inline">\(-1\)</span> 变为 <span
class="math inline">\(-2\)</span></li>
<li>需要进行逆时针旋转</li>
</ul></li>
</ol>
<img src="/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91_RR.gif" class="">
<ol start="3" type="1">
<li><code>LR</code>：在左子树的右子树插入节点
<ul>
<li>平衡因子由 <span class="math inline">\(1\)</span> 变为 <span
class="math inline">\(2\)</span></li>
<li>需要先对左子树逆时针旋转，再对根顺时针旋转</li>
</ul></li>
</ol>
<img src="/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91_LR.gif" class="">
<ol type="1">
<li><code>RL</code>：在右子树的左子树插入节点
<ul>
<li>平衡因子由 <span class="math inline">\(-1\)</span> 变为 <span
class="math inline">\(-2\)</span></li>
<li>需要先对右子树顺时针旋转，再对根逆时针旋转</li>
</ul></li>
</ol>
<img src="/2025-05-21-32-%E5%B9%B3%E8%A1%A1%E6%A0%91/%E5%B9%B3%E8%A1%A1%E6%A0%91_RL.gif" class="">
<p>参考模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释内容由AI生成，仅供参考</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;                    <span class="comment">// 定义最大节点数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;                                  <span class="comment">// 定义AVL树节点结构</span></span><br><span class="line">    <span class="type">int</span> key;                                   <span class="comment">// 键，用于二叉树排序</span></span><br><span class="line">    <span class="type">int</span> data;                                  <span class="comment">// 数据域，不参与排序的数据</span></span><br><span class="line">    <span class="type">int</span> left;                                  <span class="comment">// 左子树指针</span></span><br><span class="line">    <span class="type">int</span> right;                                 <span class="comment">// 右子树指针</span></span><br><span class="line">    <span class="type">int</span> height;                                <span class="comment">// 节点高度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;data = key = left = right = height = <span class="number">-1</span>;&#125;           <span class="comment">// 初始化节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> k_, <span class="type">int</span> d_=<span class="number">0</span>)</span></span>&#123;<span class="built_in">Init</span>(); key = k_; data = d_;&#125;       <span class="comment">// 带参数初始化</span></span><br><span class="line">    <span class="built_in">Node</span>()&#123;<span class="built_in">Init</span>();&#125;                            <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k_, <span class="type">int</span> d_=<span class="number">0</span>)&#123;<span class="built_in">Init</span>(k_, d_);&#125;      <span class="comment">// 带参数构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node tr[maxn];                                <span class="comment">// 节点数组</span></span><br><span class="line"><span class="type">int</span> root, tp;                                 <span class="comment">// root为根节点，tp为内存分配指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">UpdateHeight</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;            <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="type">int</span> lh = tr[now].left == <span class="number">-1</span> ? <span class="number">0</span> : tr[tr[now].left].height;     <span class="comment">// 获取左子树高度</span></span><br><span class="line">    <span class="type">int</span> rh = tr[now].right == <span class="number">-1</span> ? <span class="number">0</span> : tr[tr[now].right].height;   <span class="comment">// 获取右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> tr[now].height = (lh &gt; rh ? lh : rh) + <span class="number">1</span>;               <span class="comment">// 更新当前节点高度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">HeightDiff</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;              <span class="comment">// 计算平衡因子</span></span><br><span class="line">    <span class="type">int</span> lh = tr[now].left == <span class="number">-1</span> ? <span class="number">0</span> : tr[tr[now].left].height;     <span class="comment">// 获取左子树高度</span></span><br><span class="line">    <span class="type">int</span> rh = tr[now].right == <span class="number">-1</span> ? <span class="number">0</span> : tr[tr[now].right].height;   <span class="comment">// 获取右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> lh - rh;                           <span class="comment">// 返回平衡因子（左子树高度 - 右子树高度）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LL</span><span class="params">(<span class="type">int</span> an)</span> </span>&#123;                              <span class="comment">// LL型旋转（顺时针旋转）</span></span><br><span class="line">    <span class="type">int</span> bn = tr[an].left;                     <span class="comment">// 保存左子节点</span></span><br><span class="line">    <span class="type">int</span> dn = tr[bn].right;                    <span class="comment">// 保存左子节点的右子树</span></span><br><span class="line">    tr[bn].right = an;                        <span class="comment">// 调整指针关系</span></span><br><span class="line">    tr[an].left = dn;</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(an);                         <span class="comment">// 更新高度</span></span><br><span class="line">    <span class="built_in">UpdateHeight</span>(bn);</span><br><span class="line">    <span class="keyword">return</span> bn;                                <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RR</span><span class="params">(<span class="type">int</span> an)</span> </span>&#123;                              <span class="comment">// RR型旋转（逆时针旋转）</span></span><br><span class="line">    <span class="type">int</span> bn = tr[an].right;                    <span class="comment">// 保存右子节点</span></span><br><span class="line">    <span class="type">int</span> dn = tr[bn].left;                     <span class="comment">// 保存右子节点的左子树</span></span><br><span class="line">    tr[bn].left = an;                         <span class="comment">// 调整指针关系</span></span><br><span class="line">    tr[an].right = dn;</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(an);                         <span class="comment">// 更新高度</span></span><br><span class="line">    <span class="built_in">UpdateHeight</span>(bn);</span><br><span class="line">    <span class="keyword">return</span> bn;                                <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LR</span><span class="params">(<span class="type">int</span> an)</span> </span>&#123;                              <span class="comment">// LR型旋转（先逆时针后顺时针）</span></span><br><span class="line">    tr[an].left = <span class="built_in">RR</span>(tr[an].left);           <span class="comment">// 先对左子树进行逆时针旋转</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LL</span>(an);                            <span class="comment">// 再对根节点进行顺时针旋转</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RL</span><span class="params">(<span class="type">int</span> an)</span> </span>&#123;                              <span class="comment">// RL型旋转（先顺时针后逆时针）</span></span><br><span class="line">    tr[an].right = <span class="built_in">LL</span>(tr[an].right);         <span class="comment">// 先对右子树进行顺时针旋转</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RR</span>(an);                            <span class="comment">// 再对根节点进行逆时针旋转</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> &amp;now, <span class="type">int</span> key, <span class="type">int</span> data=<span class="number">0</span>)</span> </span>&#123;  <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">if</span>(now == <span class="number">-1</span>) &#123;                           <span class="comment">// 如果当前节点为空</span></span><br><span class="line">        now = tp ++;                          <span class="comment">// 分配新节点</span></span><br><span class="line">        tr[now].<span class="built_in">Init</span>(key, data);              <span class="comment">// 初始化新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; tr[now].key) &#123;              <span class="comment">// 如果键值小于当前节点</span></span><br><span class="line">        <span class="built_in">Insert</span>(tr[now].left, key, data);      <span class="comment">// 递归插入左子树</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">HeightDiff</span>(now) == <span class="number">2</span>)              <span class="comment">// 如果平衡因子为2</span></span><br><span class="line">            now = key &lt; tr[tr[now].left].key ? <span class="comment">// 判断是LL还是LR型</span></span><br><span class="line">                <span class="built_in">LL</span>(now) : <span class="built_in">LR</span>(now);            <span class="comment">// 进行相应的旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; tr[now].key) &#123;              <span class="comment">// 如果键值大于当前节点</span></span><br><span class="line">        <span class="built_in">Insert</span>(tr[now].right, key, data);     <span class="comment">// 递归插入右子树</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">HeightDiff</span>(now) == <span class="number">-2</span>)             <span class="comment">// 如果平衡因子为-2</span></span><br><span class="line">            now = key &gt; tr[tr[now].right].key ? <span class="comment">// 判断是RR还是RL型</span></span><br><span class="line">                <span class="built_in">RR</span>(now) : <span class="built_in">RL</span>(now);            <span class="comment">// 进行相应的旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UpdateHeight</span>(now);                        <span class="comment">// 更新当前节点高度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> &amp;now, <span class="type">int</span> key)</span> </span>&#123;              <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="keyword">if</span>(now == <span class="number">-1</span>) <span class="keyword">return</span>;                     <span class="comment">// 如果节点为空，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; tr[now].key) &#123;              <span class="comment">// 如果键值小于当前节点</span></span><br><span class="line">        <span class="built_in">Delete</span>(tr[now].left, key);            <span class="comment">// 递归删除左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; tr[now].key) &#123;              <span class="comment">// 如果键值大于当前节点</span></span><br><span class="line">        <span class="built_in">Delete</span>(tr[now].right, key);           <span class="comment">// 递归删除右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                    <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span>(tr[now].left == <span class="number">-1</span>) &#123;              <span class="comment">// 如果左子树为空</span></span><br><span class="line">            now = tr[now].right;              <span class="comment">// 用右子树替代</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tr[now].right == <span class="number">-1</span>) &#123;        <span class="comment">// 如果右子树为空</span></span><br><span class="line">            now = tr[now].left;               <span class="comment">// 用左子树替代</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                                <span class="comment">// 如果左右子树都不为空</span></span><br><span class="line">            <span class="type">int</span> nd;                           <span class="comment">// 找到左子树中的最大值</span></span><br><span class="line">            <span class="keyword">for</span>(nd = tr[now].left; ; nd = tr[nd].right)</span><br><span class="line">                <span class="keyword">if</span>(tr[nd].right == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            tr[now].key = tr[nd].key;         <span class="comment">// 用最大值替代当前节点</span></span><br><span class="line">            tr[now].data = tr[nd].data;</span><br><span class="line">            <span class="built_in">Delete</span>(tr[now].left, tr[nd].key); <span class="comment">// 递归删除最大值节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(now == <span class="number">-1</span>) <span class="keyword">return</span>;                     <span class="comment">// 如果节点为空，直接返回</span></span><br><span class="line">    <span class="built_in">UpdateHeight</span>(now);                        <span class="comment">// 更新当前节点高度</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">HeightDiff</span>(now) == <span class="number">2</span>) &#123;                <span class="comment">// 如果平衡因子为2</span></span><br><span class="line">        now = <span class="built_in">HeightDiff</span>(tr[now].left) &gt;= <span class="number">0</span> ? <span class="comment">// 判断是LL还是LR型</span></span><br><span class="line">            <span class="built_in">LL</span>(now) : <span class="built_in">LR</span>(now);                <span class="comment">// 进行相应的旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">HeightDiff</span>(now) == <span class="number">-2</span>) &#123;          <span class="comment">// 如果平衡因子为-2</span></span><br><span class="line">        now = <span class="built_in">HeightDiff</span>(tr[now].right) &lt;= <span class="number">0</span> ? <span class="comment">// 判断是RR还是RL型</span></span><br><span class="line">            <span class="built_in">RR</span>(now) : <span class="built_in">RL</span>(now);                <span class="comment">// 进行相应的旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其它各种平衡树简介">其它各种平衡树简介</h2>
<h3 id="红黑树">红黑树</h3>
<p>红黑树是一种广泛使用的平衡树,它通过节点的颜色来维持平衡:</p>
<ol type="1">
<li>每个节点要么是红色,要么是黑色</li>
<li>根节点是黑色</li>
<li>叶子节点(NIL)是黑色</li>
<li>如果一个节点是红色,则它的子节点必须是黑色</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
</ol>
<p>相比AVL树,红黑树: - 牺牲了部分平衡性来换取更少的旋转操作 -
插入删除的维护成本更低 - 被广泛应用于标准库实现中(如C++ STL)</p>
<h3 id="treap">Treap</h3>
<p>Treap = Tree + Heap,是一种随机化的平衡二叉树:</p>
<ol type="1">
<li>每个节点除了键值外还随机分配一个优先级</li>
<li>按照键值组成二叉搜索树</li>
<li>按照优先级组成最大堆</li>
<li>通过旋转操作来维护堆的性质</li>
<li>期望的高度是O(log n)</li>
</ol>
<h3 id="sbt-size-balanced-tree">SBT (Size Balanced Tree)</h3>
<p>SBT是由ICPC选手陈启峰发明的一种平衡树:</p>
<ol type="1">
<li>通过维护子树大小(size)而不是高度来保持平衡</li>
<li>平衡条件比较简单:较小子树的大小不小于较大子树的子树大小</li>
<li>实现相对简单,只需要维护size信息</li>
<li>各种操作的时间复杂度都是O(log n)</li>
<li>在某些情况下比红黑树更容易实现和维护</li>
</ol>
<h3 id="b树和b树">B树和B+树</h3>
<p>这两种树主要用于数据库和文件系统:</p>
<ol type="1">
<li>允许每个节点包含多个键值</li>
<li>所有叶子节点都在同一层</li>
<li>B+树的非叶节点只存储键值,数据都存在叶子节点</li>
<li>特别适合磁盘等外存储器的存储方式</li>
<li>广泛应用于数据库索引和文件系统中</li>
</ol>
<h3 id="用stl解决简单平衡树问题">用STL解决简单平衡树问题</h3>
<p>一些只需要利用平衡树性质，但没有细化考查的问题，可以用STL的<code>map</code>或<code>set</code>完成。</p>
<p><code>std::map</code>
由红黑树实现的数据有序，所有的“键”插入后都是有序的，比如可以用
<code>lower_bound</code> 找特定键的前驱</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; myMap;</span><br><span class="line"><span class="comment">// 假设 myMap 已经填充了一些数据</span></span><br><span class="line"><span class="keyword">auto</span> predecessorIt = myMap.<span class="built_in">lower_bound</span>(targetKey);</span><br><span class="line"><span class="keyword">if</span> (predecessorIt != myMap.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">    <span class="comment">// 回退一步得到前驱</span></span><br><span class="line">    --predecessorIt;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有前驱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::set</code>
是集合的概念，相对<code>map</code>来说它只有“键”没有“值”，在不需要数据映射的时候用
<code>set</code> 更简洁，比如找一个键的前驱</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> successorIt = mySet.<span class="built_in">upper_bound</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (successorIt != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Successor: &quot;</span> &lt;&lt; *successorIt &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No successor found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map</code>和<code>set</code>
都是平衡树实现，在<strong>简单场景</strong>中可以不用繁琐地自己去实现平衡树，在比赛中节约大量时间。</p>
<h2 id="伸展树splay">伸展树（Splay）</h2>
<p>伸展树通过"伸展"操作<strong>将最近访问的节点移动到根节点</strong>，从而保证树的高度在均摊意义下为<span
class="math inline">\(O(log n)\)</span>。</p>
<p>传统平衡树的操作，伸展树基本都可以完成，但可能复杂度高一些，非特异需求不建议用伸展树。</p>
<p>除传统平衡树支持的操作外，伸展树更擅长执行以下操作:</p>
<ol type="1">
<li>区间操作：通过将区间两端点伸展到根节点附近，可以方便地进行区间修改和查询</li>
<li>最近访问优化：由于最近访问的节点会被移动到根部，对于有局部性的访问模式效率更高</li>
<li>动态统计：可以方便地维护子树信息，适合需要频繁修改和查询统计信息的场景</li>
<li>序列操作：通过中序遍历性质，可以方便地进行序列的分割、合并等操作</li>
</ol>
<p>所以掌握一种传统平衡树（比如AVL或SBT）外，还应当掌握伸展树的使用。</p>
<h3 id="基本结构">基本结构</h3>
<p>伸展树的基本结构包含以下信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SplayNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch[<span class="number">2</span>];    <span class="comment">// 左右儿子</span></span><br><span class="line">    <span class="type">int</span> fa;       <span class="comment">// 父亲节点</span></span><br><span class="line">    <span class="type">int</span> val;      <span class="comment">// 节点值</span></span><br><span class="line">    <span class="type">int</span> cnt;      <span class="comment">// 值出现次数</span></span><br><span class="line">    <span class="type">int</span> sz;       <span class="comment">// 子树大小</span></span><br><span class="line">    <span class="type">int</span> lz;       <span class="comment">// 懒标记(用于区间操作)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = fa = val = cnt = sz = lz = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SplayNode</span>() &#123; <span class="built_in">Init</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个节点需要维护以下信息：</p>
<ul>
<li><code>ch[2]</code>：存储左右子节点的编号</li>
<li><code>fa</code>：存储父节点的编号</li>
<li><code>val</code>：节点的值</li>
<li><code>cnt</code>：该值出现的次数</li>
<li><code>sz</code>：以该节点为根的子树大小</li>
<li><code>lz</code>：用于区间操作的懒标记</li>
</ul>
<h3 id="核心操作">核心操作</h3>
<h4 id="旋转操作">1. 旋转操作</h4>
<p>旋转是Splay树的基础操作，用于将一个节点上移一层。旋转操作需要保证：</p>
<ol type="1">
<li>不破坏二叉查找树的性质</li>
<li>正确维护父子关系</li>
<li>更新节点信息</li>
</ol>
<p>旋转分为两种情况：</p>
<ul>
<li>当节点是其父节点的左儿子时，进行右旋</li>
<li>当节点是其父节点的右儿子时，进行左旋</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = sn[x].fa, z = sn[y].fa;</span><br><span class="line">    <span class="type">int</span> chk = <span class="built_in">Ws</span>(x);  <span class="comment">// 判断x是y的左儿子还是右儿子</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新y的子节点</span></span><br><span class="line">    sn[y].ch[chk] = sn[x].ch[chk ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(sn[y].ch[chk]) </span><br><span class="line">        sn[sn[y].ch[chk]].fa = y;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 更新x和y的关系</span></span><br><span class="line">    sn[x].ch[chk ^ <span class="number">1</span>] = y;</span><br><span class="line">    sn[y].fa = x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新x和z的关系</span></span><br><span class="line">    sn[x].fa = z;</span><br><span class="line">    <span class="keyword">if</span>(z) </span><br><span class="line">        sn[z].ch[y == sn[z].ch[<span class="number">1</span>]] = x;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 维护节点信息</span></span><br><span class="line">    <span class="built_in">Maintain</span>(y);</span><br><span class="line">    <span class="built_in">Maintain</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="伸展操作">2. 伸展操作</h4>
<p>伸展操作是Splay树的核心，它将一个节点通过一系列旋转移动到根节点。伸展操作分为三种情况：</p>
<ol type="1">
<li>zig：当父节点是根节点时，直接旋转</li>
<li>zig-zig：当节点和父节点都是左儿子或都是右儿子时，先旋转父节点，再旋转当前节点</li>
<li>zig-zag：当节点和父节点一个是左儿子一个是右儿子时，连续旋转两次当前节点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> target=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = sn[x].fa; (y = sn[x].fa) != target; <span class="built_in">Rotate</span>(x))</span><br><span class="line">        <span class="keyword">if</span>(sn[y].fa != target) </span><br><span class="line">            <span class="built_in">Rotate</span>(<span class="built_in">Ws</span>(x) == <span class="built_in">Ws</span>(y) ? y : x);</span><br><span class="line">    <span class="keyword">if</span>(!target) rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本操作">基本操作</h3>
<h4 id="插入操作">插入操作</h4>
<p>插入操作的基本步骤：</p>
<ol type="1">
<li>如果树为空，直接创建新节点作为根节点</li>
<li>否则，按照二叉查找树的性质找到插入位置</li>
<li>如果找到相同值的节点，增加计数</li>
<li>否则创建新节点</li>
<li>最后进行伸展操作，将新节点移到根节点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) &#123;</span><br><span class="line">        rt = <span class="built_in">Add</span>(k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cur = rt, f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sn[cur].val == k) &#123;</span><br><span class="line">            sn[cur].cnt++;</span><br><span class="line">            <span class="built_in">Maintain</span>(cur);</span><br><span class="line">            <span class="built_in">Maintain</span>(f);</span><br><span class="line">            <span class="built_in">Splay</span>(cur);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f = cur;</span><br><span class="line">        cur = sn[cur].ch[sn[cur].val &lt; k];</span><br><span class="line">        <span class="keyword">if</span>(!cur) &#123;</span><br><span class="line">            <span class="type">int</span> nn = <span class="built_in">Add</span>(k, f);</span><br><span class="line">            <span class="built_in">Splay</span>(nn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除操作">删除操作</h4>
<p>删除操作的基本步骤：</p>
<ol type="1">
<li>首先找到要删除的节点并伸展到根</li>
<li>如果节点计数大于1，直接减少计数</li>
<li>如果节点没有子节点，直接删除</li>
<li>如果节点只有一个子节点，用子节点替代</li>
<li>如果节点有两个子节点，找到前驱节点替代，然后删除前驱节点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Del</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Rank</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(sn[rt].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sn[rt].cnt--;</span><br><span class="line">        <span class="built_in">Maintain</span>(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!sn[rt].ch[<span class="number">0</span>] &amp;&amp; !sn[rt].ch[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">Clear</span>(rt);</span><br><span class="line">        rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理只有一个子节点的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sn[rt].ch[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> cur = rt;</span><br><span class="line">        rt = sn[rt].ch[i ^ <span class="number">1</span>];</span><br><span class="line">        sn[rt].fa = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Clear</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理有两个子节点的情况</span></span><br><span class="line">    <span class="type">int</span> cur = rt, x = <span class="built_in">RtPre</span>();</span><br><span class="line">    sn[sn[cur].ch[<span class="number">1</span>]].fa = x;</span><br><span class="line">    sn[x].ch[<span class="number">1</span>] = sn[cur].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">Clear</span>(cur);</span><br><span class="line">    <span class="built_in">Maintain</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前驱后继查询">前驱后继查询</h4>
<p>前驱后继查询的基本步骤：</p>
<ol type="1">
<li>前驱：找到左子树中的最大值</li>
<li>后继：找到右子树中的最小值</li>
<li>查询后将节点伸展到根</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RtPre</span><span class="params">(<span class="type">int</span> cur=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cur) cur = sn[rt].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> cur = sn[cur].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!cur) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="keyword">while</span>(sn[cur].ch[<span class="number">1</span>]) cur = sn[cur].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">Splay</span>(cur);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RtNxt</span><span class="params">(<span class="type">int</span> cur=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cur) cur = sn[rt].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> cur = sn[cur].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!cur) <span class="keyword">return</span> cur;</span><br><span class="line">    <span class="keyword">while</span>(sn[cur].ch[<span class="number">0</span>]) cur = sn[cur].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">Splay</span>(cur);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列操作">序列操作</h3>
<p>Splay树也可以用于维护序列信息。与线段树相比，Splay树虽然常数较大，但支持更复杂的序列操作，如区间翻转等。</p>
<p>将序列建成的Splay树具有以下性质：</p>
<ol type="1">
<li>中序遍历相当于原序列从左到右的遍历</li>
<li>每个节点代表序列中的一个元素</li>
<li>一棵子树代表序列中的一段区间</li>
</ol>
<h4 id="区间操作">区间操作</h4>
<p>以区间翻转为例，操作步骤如下：</p>
<ol type="1">
<li>将区间左端点前一个节点伸展到根</li>
<li>将区间右端点后一个节点伸展到根的右儿子</li>
<li>此时根的右儿子的左子树就是目标区间</li>
<li>对该子树进行翻转操作并打上懒标记</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">PushDown</span>(cur);</span><br><span class="line">    <span class="built_in">DFS</span>(sn[cur].ch[<span class="number">0</span>], k);</span><br><span class="line">    <span class="built_in">DFS</span>(sn[cur].ch[<span class="number">1</span>], k);</span><br><span class="line">    sn[sn[cur].fa].ch[<span class="built_in">Ws</span>(cur)] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Maintain</span>(sn[cur].fa);</span><br><span class="line">    tbi.<span class="built_in">push_back</span>(sn[cur].val);</span><br><span class="line">    cct.<span class="built_in">push_back</span>(sn[cur].cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="懒标记管理">懒标记管理</h4>
<p>对于区间操作，需要维护懒标记：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushDown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !sn[x].lz) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">UpdateLz</span>(sn[x].ch[<span class="number">0</span>], sn[x].lz);</span><br><span class="line">    <span class="built_in">UpdateLz</span>(sn[x].ch[<span class="number">1</span>], sn[x].lz);</span><br><span class="line">    sn[x].lz = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateLz</span><span class="params">(<span class="type">int</span> x, LL lz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    sn[x].lz += lz;</span><br><span class="line">    sn[x].val -= lz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在访问节点时需要下传标记：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> target=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> f = x; f; f = sn[f].fa) path.<span class="built_in">push_back</span>(f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">PushDown</span>(path[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y; (y = sn[x].fa) != target; <span class="built_in">Rotate</span>(x))</span><br><span class="line">        <span class="keyword">if</span>(sn[y].fa != target) <span class="built_in">Rotate</span>(<span class="built_in">Ws</span>(x) == <span class="built_in">Ws</span>(y) ? y : x);</span><br><span class="line">    <span class="keyword">if</span>(!target) rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用示例">应用示例</h4>
<p>以K小值查询为例，展示了Splay树处理区间操作的能力：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpperBound</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lastLager = <span class="number">0</span>, cur = rt;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        <span class="built_in">PushDown</span>(cur);</span><br><span class="line">        <span class="keyword">if</span>(k &lt; sn[cur].val) &#123;</span><br><span class="line">            lastLager = cur;</span><br><span class="line">            <span class="keyword">if</span>(!sn[cur].ch[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">            cur = sn[cur].ch[<span class="number">0</span>];</span><br><span class="line">        &#125;                </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!sn[cur].ch[<span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            cur = sn[cur].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sn[cur].val &lt;= k) cur = lastLager;</span><br><span class="line">    <span class="keyword">if</span>(cur) <span class="built_in">Splay</span>(cur);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子展示了如何：</p>
<ol type="1">
<li>维护区间信息</li>
<li>处理懒标记</li>
<li>进行区间查询和修改</li>
</ol>
<p>通过这些操作，Splay树可以高效地处理各种序列操作问题。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>单次操作均摊复杂度：<span class="math inline">\(O(log
n)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(n)\)</span></li>
</ul>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>33.范围统计</title>
    <url>/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="范围统计">范围统计</h1>
<p>树状数组、线段树、KD树。</p>
<span id="more"></span>
<h2 id="基本的区间统计问题">基本的区间统计问题</h2>
<h3 id="区间查询">区间查询</h3>
<p>给定 <span class="math inline">\(n\)</span> 个数以及 <span
class="math inline">\(m\)</span> 组 <span class="math inline">\(a,
b\)</span>（其中 <span class="math inline">\(a&gt;0\)</span> 且 <span
class="math inline">\(b&gt;0\)</span>），我们需要计算序号在区间 <span
class="math inline">\([a,b]\)</span> 的数值的和 <span
class="math inline">\(sum(a,b)\)</span>。例如，<span
class="math inline">\(sum(1,1)=15\)</span>，<span
class="math inline">\(sum(5,8)=36\)</span>。</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E5%8C%BA%E9%97%B4_%E7%A4%BA%E4%BE%8B.svg" class="">
<p>为了解决这个问题，我们可以使用前缀和的方法。定义 <span
class="math inline">\(pre(a)=sum(1,a)\)</span>，那么 <span
class="math inline">\(sum(a,b)=pre(b)-pre(a-1)\)</span>。例如，<span
class="math inline">\(sum(5,8)=pre(8)-pre(4)=95-59=36\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) pre[i] = pre[i - <span class="number">1</span>] + c[i];</span><br></pre></td></tr></table></figure>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E5%8C%BA%E9%97%B4_%E5%89%8D%E7%BC%80%E5%92%8C.svg" class="">
<h3 id="单点修改区间查询">单点修改+区间查询</h3>
<p>给定 <span class="math inline">\(n\)</span> 个数以及 <span
class="math inline">\(m\)</span> 组操作，每组操作是以下两种之一：</p>
<ul>
<li>操作1：<span class="math inline">\(1,x,a\)</span>，将序号为 <span
class="math inline">\(x\)</span> 位置的数值加 <span
class="math inline">\(a\)</span></li>
<li>操作2：<span class="math inline">\(2,a,b\)</span>，求序号在区间
<span class="math inline">\([a,b]\)</span> 的数值的和 <span
class="math inline">\(sum(a,b)\)</span></li>
</ul>
<p>例如，输入 <span class="math inline">\(1,6,9; 2,5,8\)</span>，输出
<span class="math inline">\(18+10+8+9=45\)</span>。</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E5%8C%BA%E9%97%B4_%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9.svg" class="">
<h2 id="树状数组">树状数组</h2>
<p>前缀和方法存在以下不足：</p>
<ul>
<li>每个序号“管理”整个前缀，涉及“下属”过多</li>
<li>每个序号被后续序号“管理”，更新要“汇报”的“上级”过多</li>
</ul>
<p>改进思路是减少每个序号的“下级”与“上级”。我们采用以2的幂为单位的分级“管辖”方案：</p>

<p>“管辖”方案：以2的幂为单位分级：</p>
<ul>
<li>“一级”：1,2归2管，3,4归4管，5,6归6管，7,8归8管……</li>
<li>“二级”：4要额外管理1<sub>2，所以2是4的直接下级，4是1</sub>4的前缀和</li>
<li>“三级”：8要额外管理1<sub>4、5</sub>6，所以4、6也是8的直接下级</li>
<li>……</li>
</ul>
<p>树状数组实际上是在数组中存储了一棵树的逻辑结构：</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91.svg" class="">
<p>快速寻找直接“上级”的方法：</p>
<ul>
<li>5(101)的上级是6(110)</li>
<li>4(100)的上级是8(1000)</li>
<li>6(110)的上级是8(1000)</li>
</ul>
<p>规律是：最低的为“1”的二进制位+1。</p>
<p>求 <span class="math inline">\(x\)</span> 的最低的为“1”的二进制位
<span class="math inline">\(lowbit\)</span>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br></pre></td></tr></table></figure>
<p>求 <span class="math inline">\(x\)</span> 的上级：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x + <span class="built_in">Lowbit</span>(<span class="type">int</span> x) </span><br></pre></td></tr></table></figure>
<p>求前缀和：找左侧最大组长</p>
<ul>
<li>6(110)的左侧是4(100)——4&lt;6且是最大组长</li>
<li>7(111)的左侧是6(110)——6&lt;7且是最大组长</li>
</ul>
<p>这些区间互不相交，且无遗漏，相加可得前缀和。规律是：最低的为“1”的二进制位−1。</p>
<p>求 <span class="math inline">\(x\)</span> 的左侧最大组长：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x - <span class="built_in">Lowbit</span>(<span class="type">int</span> x) </span><br></pre></td></tr></table></figure>
<p>单点修改时，需要逐层告知上级“辖区”内数值变化量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt; maxn; x += <span class="built_in">Lowbit</span>(x))</span><br><span class="line">        a[x] += v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前缀和查询时，需要逐个向左侧找最大组长，累加：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x; x -= <span class="built_in">Lowbit</span>(x))</span><br><span class="line">        res += a[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码参考</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> op, n, q;</span><br><span class="line">LL a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt; maxn; x += <span class="built_in">Lowbit</span>(x))</span><br><span class="line">        a[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x; x -= <span class="built_in">Lowbit</span>(x))</span><br><span class="line">        res += a[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q) != EOF) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="built_in">Update</span>(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q --) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">Update</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Query</span>(y) - <span class="built_in">Query</span>(x - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展：</p>
<ul>
<li>区间最值查询：树状数组无法直接维护区间最值，需结合其他数据结构（如线段树）</li>
<li>区间统计：支持维护区间特定统计信息（如奇偶性、模余等），需预处理辅助数组</li>
<li>区间合并/分裂：树状数组无法直接处理区间合并、分裂操作</li>
<li>区间覆盖：树状数组难以高效实现区间赋值或覆盖操作（需结合懒标记等技巧）</li>
</ul>
<p>基于差分的扩展应用：</p>
<ul>
<li>区间修改+单点查询：使用差分数组可高效支持，单点查询转化为前缀和计算</li>
<li>区间修改+区间查询：通过二阶差分与扩展BIT结构，可实现区间和查询</li>
<li>区间最值修改：树状数组不适合直接支持此类操作，需借助其他结构</li>
</ul>
<p>高级扩展结构：</p>
<ul>
<li>二维树状数组：支持二维平面的单点修改与矩形和查询</li>
<li>可持久化树状数组：支持历史版本查询，适用于函数式编程或离线算法</li>
<li>动态开点树状数组：用于高维稀疏数据，节省内存空间</li>
<li>树状数组套权值树：解决带权第k大等复杂统计问题</li>
<li>离线处理：结合莫队算法等，优化多次查询的处理效率</li>
</ul>
<h2 id="线段树">线段树</h2>
<h3 id="在数组之上再建一棵树">在数组之上再建一棵树</h3>
<p>与树状数组不同，在线段树中，上级节点并不存在于数组中，而是另外建立的节点。这种结构使得我们可以更灵活地处理区间操作。</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E7%BA%BF%E6%AE%B5%E6%A0%91.svg" class="">
<p>为了便于计算，我们使用左闭右开区间，数组序号从0开始。设根节点覆盖区间为
<span class="math inline">\([0,n)\)</span>，则左子树为 <span
class="math inline">\([0,\lfloor n/2 \rfloor)\)</span>，右子树为 <span
class="math inline">\([\lfloor n/2
\rfloor,n)\)</span>。可以通过递归操作建树：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">BuildSegTree</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// now: 当前节点； [ls, rs) 左闭右开区间端点</span></span><br><span class="line">    <span class="keyword">if</span>(ls &gt;= rs) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ls == rs - <span class="number">1</span>) &#123;<span class="keyword">return</span> sum[now] = a[ls];&#125;</span><br><span class="line">    sum[now] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = ls + rs &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sum[now] += <span class="built_in">BuildSegTree</span>(now &lt;&lt; <span class="number">1</span>, ls, mid);</span><br><span class="line">    sum[now] += <span class="built_in">BuildSegTree</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs);</span><br><span class="line">    <span class="keyword">return</span> sum[now];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单点修改区间查询-1">单点修改+区间查询</h3>
<p>所有包含序号 <span class="math inline">\(x\)</span>
的区间（节点）都要修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls &gt;= rs) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ls == rs - <span class="number">1</span>) &#123;sum[now] += v; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> mid = ls + rs &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; mid) <span class="built_in">Update</span>(now &lt;&lt; <span class="number">1</span>, ls, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">Update</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs, x, v);</span><br><span class="line">    sum[now] += v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情况1：<span class="math inline">\([x,y)\)</span>包含了 <span
class="math inline">\(now\)</span> 负责的 <span
class="math inline">\([ls,rs)\)</span> 区间，则 <span
class="math inline">\(now\)</span> 区间都计入</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E7%BA%BF%E6%AE%B5%E6%A0%91_%E8%A6%86%E7%9B%96%E5%8C%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5.svg" class="">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt;= ls &amp;&amp; y &gt;= rs) <span class="keyword">return</span> sum[now];</span><br></pre></td></tr></table></figure>
<p>情况2：部分重叠，<span class="math inline">\(y\)</span> 在 <span
class="math inline">\(mid\)</span> 之右，表示 <span
class="math inline">\(now\)</span> 的右半部分需要考虑 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(mid\)</span> 之左同理</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E7%BA%BF%E6%AE%B5%E6%A0%91_%E9%83%A8%E5%88%86%E9%87%8D%E5%8F%A0%E7%9A%84%E6%83%85%E5%86%B5.svg" class="">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(y &gt; mid) ret += <span class="built_in">Query</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs, x, y);</span><br></pre></td></tr></table></figure>
<p>只对与 <span class="math inline">\([x,y)\)</span>
有交集的区间（子树）进行递归 <span class="math inline">\([x,y)\)</span>
覆盖整个区间（子树）时，不再递归直接返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls &gt;= rs) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= ls &amp;&amp; y &gt;= rs) <span class="keyword">return</span> sum[now];</span><br><span class="line">    <span class="type">int</span> mid = ls + rs &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; mid) ret += <span class="built_in">Query</span>(now &lt;&lt; <span class="number">1</span>, ls, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) ret += <span class="built_in">Query</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs, x, y);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line">LL sum[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="function">LL <span class="title">BuildSegTree</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// now: 当前节点； [ls, rs) 左闭右开区间端点</span></span><br><span class="line">    <span class="keyword">if</span>(ls &gt;= rs) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ls == rs - <span class="number">1</span>) &#123;<span class="keyword">return</span> sum[now] = a[ls];&#125;</span><br><span class="line">    sum[now] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = ls + rs &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sum[now] += <span class="built_in">BuildSegTree</span>(now &lt;&lt; <span class="number">1</span>, ls, mid);</span><br><span class="line">    sum[now] += <span class="built_in">BuildSegTree</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs);</span><br><span class="line">    <span class="keyword">return</span> sum[now];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls &gt;= rs) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ls == rs - <span class="number">1</span>) &#123;sum[now] += v; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> mid = ls + rs &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; mid) <span class="built_in">Update</span>(now &lt;&lt; <span class="number">1</span>, ls, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">Update</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs, x, v);</span><br><span class="line">    sum[now] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls &gt;= rs) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= ls &amp;&amp; y &gt;= rs) <span class="keyword">return</span> sum[now];</span><br><span class="line">    <span class="type">int</span> mid = ls + rs &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; mid) ret += <span class="built_in">Query</span>(now &lt;&lt; <span class="number">1</span>, ls, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) ret += <span class="built_in">Query</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs, x, y);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> op, x, y, n, q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q) != EOF) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">BuildSegTree</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">while</span>(q --) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">Update</span>(<span class="number">1</span>, <span class="number">0</span>, n, x - <span class="number">1</span>, y);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">Query</span>(<span class="number">1</span>, <span class="number">0</span>, n, x - <span class="number">1</span>, y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间修改">区间修改</h3>
<p>思考1：当修改区间包含 <span class="math inline">\(now\)</span>
区间时，<span class="math inline">\(now\)</span> 区间是否还需要递归</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E7%BA%BF%E6%AE%B5%E6%A0%91_%E8%A6%86%E7%9B%96%E5%8C%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5.svg" class="">
<p>思考2：如果思考1中答案是"不递归，修改节点的值返回即可"</p>
<p>那新的查询区间在 <span class="math inline">\(now\)</span>
内部（子树）怎么办？</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E7%BA%BF%E6%AE%B5%E6%A0%91_%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E5%9C%A8%E8%8A%82%E7%82%B9%E5%8C%BA%E9%97%B4%E5%86%85.svg" class="">
<p>懒标记（<span
class="math inline">\(lazy\)</span>）：修改时打标记，查询时标记只往下传
1 层 修改时：</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E7%BA%BF%E6%AE%B5%E6%A0%91_%E6%87%92%E6%A0%87%E8%AE%B0.svg" class="">
<p>修改前与查询时：</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/%E7%BA%BF%E6%AE%B5%E6%A0%91_%E6%87%92%E6%A0%87%E8%AE%B0%E4%B8%8B%E4%BC%A0.svg" class="">
<p>懒标记下传参考代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateNode</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs, LL v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rangeN = rs - ls;                           <span class="comment">// 求区间长度</span></span><br><span class="line">    sum[now] += rangeN * v;                         <span class="comment">// 用下传的懒标记更新本区间和</span></span><br><span class="line">    lasy[now] += v;                                 <span class="comment">// 更新节点懒标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushDown</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lasy[now] == <span class="number">0</span> || ls &gt;= rs) <span class="keyword">return</span>;          <span class="comment">// 没有懒标记，或已到叶子</span></span><br><span class="line">    <span class="type">int</span> mid = ls + rs &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">UpdateNode</span>(now &lt;&lt; <span class="number">1</span>, ls, mid, lasy[now]);       <span class="comment">// 下传懒标记到子节点</span></span><br><span class="line">    <span class="built_in">UpdateNode</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs, lasy[now]);</span><br><span class="line">    lasy[now] = <span class="number">0</span>;                                  <span class="comment">// 清除本节点懒标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带懒标记的区间更新操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushUp</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    sum[now] = sum[now &lt;&lt; <span class="number">1</span>] + sum[now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls &gt;= rs) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= ls &amp;&amp; y &gt;= rs) <span class="built_in">UpdateNode</span>(now, ls, rs, v);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">PushDown</span>(now, ls, rs);</span><br><span class="line">        <span class="type">int</span> mid = ls + rs &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; mid) <span class="built_in">Update</span>(now &lt;&lt; <span class="number">1</span>, ls, mid, x, y, v);</span><br><span class="line">        <span class="keyword">if</span>(y &gt; mid) <span class="built_in">Update</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs, x, y, v);</span><br><span class="line">        <span class="built_in">PushUp</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带懒标记的区间查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> ls, <span class="type">int</span> rs, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ls &gt;= rs) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= ls &amp;&amp; y &gt;= rs) <span class="keyword">return</span> sum[now];</span><br><span class="line">    <span class="built_in">PushDown</span>(now, ls, rs);</span><br><span class="line">    <span class="type">int</span> mid = ls + rs &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; mid) ret += <span class="built_in">Query</span>(now &lt;&lt; <span class="number">1</span>, ls, mid, x, y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) ret += <span class="built_in">Query</span>(now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid, rs, x, y);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不只是求和：</p>
<ul>
<li>区间最值查询：维护区间最大值/最小值，适用于RMQ（Range
Maximum/Minimum Query）问题。</li>
<li>区间统计：维护区间内满足特定条件的元素个数，如区间奇偶性、模余性质等。</li>
<li>区间合并：处理区间合并、分裂等操作（如区间染色问题），常用于线段树合并或Segment
Tree Beats。</li>
<li>区间覆盖：处理区间赋值、区间覆盖等操作，需使用懒标记进行高效更新。</li>
<li>区间翻转：处理区间反转操作，通常结合块状链表或平衡树结构实现。</li>
</ul>
<p>区间操作：</p>
<ul>
<li>区间修改+单点查询：使用懒标记优化（如区间加后单点查询），适合延迟传播机制。</li>
<li>区间修改+区间查询：结合懒标记和区间更新（如区间求和与区间加），是线段树基础应用之一。</li>
<li>区间最值更新：维护区间最值的同时支持取min/max等操作（如区间取max），常见于吉司机线段树（Segment
Tree Beats）。</li>
<li>标记永久化：处理不可叠加操作的懒标记技巧（如区间覆盖不下传标记），适用于某些强制覆盖型操作。</li>
</ul>
<p>更复杂的情况：</p>
<ul>
<li>可持久化线段树：支持历史版本查询（如版本回退），适用于离线处理和函数式编程。</li>
<li>动态开点线段树：处理稀疏数据（无需预先开辟全部节点），节省空间适用于大范围但修改少的数据。</li>
<li>李超线段树：处理线段/直线覆盖的最值问题，适用于动态插入线段并查询区间最大/最小值。</li>
<li>线段树分治：结合时间线处理动态问题的离线方法，常用于解决带删除/回滚的问题。</li>
<li>权值线段树：维护值域分布的统计信息（如第k大查询），常配合离散化使用。</li>
<li>树链剖分套线段树：处理树上路径/子树操作，能高效应对树形结构上的区间操作。</li>
<li>平衡树套线段树：处理动态区间插入删除后的区间查询，如Treap/AVL嵌套线段树。</li>
<li>线段树套分块：结合两者优势处理大规模混合操作，提升部分操作效率。</li>
<li>二维线段树：处理矩阵的区间更新与查询，适用于二维平面上的操作。</li>
<li>线段树套Trie：处理数位相关的区间异或/最值问题，如可持久化01-Trie嵌套在线段树中。</li>
<li>区间连通性线段树：结合并查集思想处理区间连通性问题，适用于区间图论相关问题。</li>
</ul>
<h2 id="k-d树">K-D树</h2>
<p>思考：如果用线段树的写法统计二维的数据，直观的思路是什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> v, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> up, <span class="type">int</span> down, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right || up == down)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    val[now] += v;</span><br><span class="line">    <span class="keyword">if</span>(left == right - <span class="number">1</span> &amp;&amp; up == down - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> lrmid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> udmid = up + down &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; lrmid &amp;&amp; y &lt; udmid) <span class="built_in">InitNode</span>(<span class="number">0</span>, now), <span class="built_in">Update</span>(dr[<span class="number">0</span>][now], v, left, lrmid, up, udmid, x, y);</span><br><span class="line">    <span class="keyword">if</span>(x &lt; lrmid &amp;&amp; y &gt;= udmid) <span class="built_in">InitNode</span>(<span class="number">1</span>, now), <span class="built_in">Update</span>(dr[<span class="number">1</span>][now], v, left, lrmid, udmid, down, x, y);</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= lrmid &amp;&amp; y &lt; udmid) <span class="built_in">InitNode</span>(<span class="number">2</span>, now), <span class="built_in">Update</span>(dr[<span class="number">2</span>][now], v, lrmid, right, up, udmid, x, y);</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= lrmid &amp;&amp; y &gt;= udmid) <span class="built_in">InitNode</span>(<span class="number">3</span>, now), <span class="built_in">Update</span>(dr[<span class="number">3</span>][now], v, lrmid, right, udmid, down, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那三维、四维...K维的情况呢？</p>
<p>需要一个数据结构，处理任意维度的统计 <span
class="math inline">\(K\)</span> 个维度——<span
class="math inline">\(K-Dimensional\)</span>——K-D树</p>
<p>以二叉树的形式处理任意维度的数据</p>
<h3 id="二维平面点个数统计">二维平面点个数统计</h3>
<p>尝试建树：
每次用一条线把平面递归地分为两部分，水平划分有用吗？当求一个矩形区域的点个数的时候</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/KD%E6%A0%91_%E6%B0%B4%E5%B9%B3%E5%88%92%E5%88%86.svg" class="">
<p>水平与竖直结合</p>
<p>思考：什么时候水平分，什么时候竖直分？</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/KD%E6%A0%91_%E6%B0%B4%E5%B9%B3%E7%AB%96%E7%9B%B4%E7%BB%93%E5%90%88.svg" class="">
<p>点的离散程度——坐标方差 <span class="math inline">\(x\)</span> 坐标与
<span class="math inline">\(y\)</span>
坐标哪个方差大，按哪个维度划分，让划分后的区域内，点尽可能的"聚集"，便于统计</p>
<img src="/2025-05-23-33-%E8%8C%83%E5%9B%B4%E7%BB%9F%E8%AE%A1/KD%E6%A0%91_%E7%94%A8%E6%96%B9%E5%B7%AE%E5%86%B3%E5%AE%9A%E5%88%92%E5%88%86%E6%96%B9%E5%90%91.svg" class="">
<p>统计思想：和线段树类似，覆盖区域则直接返回，否则递归</p>
<p>高维处理：同二维一样，各维度方差选最大的做划分</p>
<p>更多任务：</p>
<ul>
<li>K近点</li>
<li>最远点</li>
<li>曼哈顿最近距离</li>
<li>……</li>
</ul>
<p>参考模板：<a
href="https://github.com/CSGrandeur/icpc_solution/blob/master/templates/DataStructure.md#kd%E6%A0%91">icpc_solution/DataStructure.md
at master · CSGrandeur/icpc_solution · GitHub</a></p>
<h3 id="例k远点">例：k远点</h3>
<p>平面上有 <span class="math inline">\(n\)</span> 个点。现在有 <span
class="math inline">\(m\)</span> 次询问，每次给定一个点 <span
class="math inline">\((px,py)\)</span> 和一个整数 <span
class="math inline">\(k\)</span>，输出 <span
class="math inline">\(n\)</span> 个点中离 <span
class="math inline">\((px,py)\)</span> 的距离第 <span
class="math inline">\(k\)</span> 大的点的标号。如果有两个(或多个)点距离
<span class="math inline">\((px,py)\)</span>
相同，那么认为标号较小的点距离较大。</p>
<p><span class="math inline">\(1 \leq k \leq 20\)</span></p>
<p>分析：</p>
<ul>
<li>第 <span class="math inline">\(k\)</span> 远的点，就是从远到近的第
<span class="math inline">\(k\)</span> 个，<span
class="math inline">\(k\)</span>范围不大。</li>
<li>KD树中每个节点都是一个具体的点，这个点的两个子树对应从它劈开（或横或竖）后的两个矩形区域</li>
<li>开一个小根堆（优先队列），并开始对树回溯（搜索）</li>
<li>每访问一个点，将其与堆顶比较，大就进堆，且保持堆里不超过 k
个元素</li>
<li>对于左右子树，优先访问子树的矩形距离目标点更远的那个</li>
<li>如果堆里有k个元素，此时一棵子树的矩形距离比堆顶还近，那这课子树不用搜（分支限界/剪枝）</li>
</ul>
<p>发散：k近点问题思路类似</p>
<h3 id="例平面统计">例：平面统计</h3>
<p>多次操作，对整数坐标位置加数字或者求某个矩形区域的数字和</p>
<ul>
<li>每个节点对应一个矩形区域</li>
<li>这个矩形区域被它横或竖分成两半</li>
<li>该节点“掌管”一棵子树</li>
</ul>
<p>在节点维护子树元素个数，某个坐标增加数值，就是节点的插入或更新</p>
<p>统计操作类似线段树——全覆盖（要统计的矩形覆盖了子树的矩形）就子树的统计值返回，部分覆盖就递归进入子树。</p>
<p>思考：KD树的平衡问题。必要时可以通过平衡因子判断后对整棵子树离线重构。重构而不是像平衡树那样旋转是因为KD树没法那样旋转……</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>ACMCOURSE</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
