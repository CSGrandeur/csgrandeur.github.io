<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.csgrandeur.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="排序 将无序数据变为有序，不明确指定顺序的情况下默认从小到大排序。 排序需要具体的方案来实现，不同的方案执行效率不同，通常用元素的“比较次数”与“移动次数”作为执行的代价来衡量不同排序算法的效率。">
<meta property="og:type" content="article">
<meta property="og:title" content="07.排序">
<meta property="og:url" content="http://blog.csgrandeur.cn/2025-03-10-07-%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="CSGrandeur&#39;s Thinking">
<meta property="og:description" content="排序 将无序数据变为有序，不明确指定顺序的情况下默认从小到大排序。 排序需要具体的方案来实现，不同的方案执行效率不同，通常用元素的“比较次数”与“移动次数”作为执行的代价来衡量不同排序算法的效率。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.csgrandeur.cn/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_insert_base.svg">
<meta property="og:image" content="http://blog.csgrandeur.cn/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_quick.gif">
<meta property="og:image" content="http://blog.csgrandeur.cn/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_selection_tree.png">
<meta property="og:image" content="http://blog.csgrandeur.cn/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_base.gif">
<meta property="article:published_time" content="2025-03-10T04:06:33.000Z">
<meta property="article:modified_time" content="2025-05-21T02:10:04.424Z">
<meta property="article:author" content="CSGrandeur">
<meta property="article:tag" content="ACM">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.csgrandeur.cn/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_insert_base.svg">


<link rel="canonical" href="http://blog.csgrandeur.cn/2025-03-10-07-%E6%8E%92%E5%BA%8F/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://blog.csgrandeur.cn/2025-03-10-07-%E6%8E%92%E5%BA%8F/","path":"2025-03-10-07-排序/","title":"07.排序"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>07.排序 | CSGrandeur's Thinking</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?7958adf931092425a489778560129144"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CSGrandeur's Thinking</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Cogito Ergo Sum</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%88%B0%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">从插入排序到希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">希尔排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%88%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.</span> <span class="nav-text">从冒泡排序到快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%88%B0%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">从选择排序到堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">堆排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%9F%BA%E4%BA%8E%E7%9B%B8%E4%BA%92%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.</span> <span class="nav-text">非基于相互比较的排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.3.</span> <span class="nav-text">桶排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stl-sort-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">1.6.</span> <span class="nav-text">STL： sort 的基本使用</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CSGrandeur</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.csgrandeur.cn/2025-03-10-07-%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CSGrandeur">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CSGrandeur's Thinking">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="07.排序 | CSGrandeur's Thinking">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          07.排序
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-10 12:06:33" itemprop="dateCreated datePublished" datetime="2025-03-10T12:06:33+08:00">2025-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-21 10:10:04" itemprop="dateModified" datetime="2025-05-21T10:10:04+08:00">2025-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ACM/ACMCOURSE/" itemprop="url" rel="index"><span itemprop="name">ACMCOURSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="排序">排序</h1>
<p>将无序数据变为有序，不明确指定顺序的情况下默认从小到大排序。</p>
<p>排序需要具体的方案来实现，不同的方案执行效率不同，通常用元素的“比较次数”与“移动次数”作为执行的代价来衡量不同排序算法的效率。</p>
<span id="more"></span>
<p>综合评价一个排序算法有以下三个要素：</p>
<ul>
<li>时间复杂度：元素的比较次数与移动次数与数据规模 <span
class="math inline">\(n\)</span> 关系，通常简化为大写字母 <span
class="math inline">\(O\)</span>与 <span
class="math inline">\(n\)</span>
的多项式最高次幂去掉系数的形式表达，比如 <span
class="math inline">\(O(n^2)\)</span>、<span
class="math inline">\(O(nlog_{2}n)\)</span>等。</li>
<li>空间复杂度：一些排序算法需要利用额外的内存来完成，也用 <span
class="math inline">\(O\)</span>表达式表示，如果只用一两个或十几个<code>int</code>空间，通常称为空间复杂度
<span class="math inline">\(O(1)\)</span>，如果额外内存规模接近 <span
class="math inline">\(n\)</span> 且成正比，通常称为空间复杂度 <span
class="math inline">\(O(n)\)</span>。</li>
<li>稳定性：如果两个元素的关键数据相等，排序前与排序后这两元素的前后顺序总能保持不变，则这样的排序算法是“稳定”的；反之，如果排序后这两元素前后顺序可能变化，不能确保与排序前一致，就称为不稳定的。
举个例子，一个学生的信息用结构体表达： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> age, height, weight;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Student s[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure>
需要按身高排序，那么<code>height</code>就是关键数据，对
<code>s[1000]</code>
排序时，相同<code>height</code>的学生前后位置随意变化不影响排序的正确性，但是排序前与排序后他们的先后位置是否变化这一“稳定性”在有的应用场景是需要的，所以排序算法的稳定性是一个重要属性。</li>
</ul>
<h2 id="从插入排序到希尔排序">从插入排序到希尔排序</h2>
<h3 id="插入排序">插入排序</h3>
<p>插入排序在一个数组中从前往后对每个元素做处理，在“考察”元素
<code>a[i]</code> 时，实际上数组已经被分成两部分， <span
class="math inline">\([0,i)\)</span> 这部分是已经有序的部分（最开始考察
<code>a[0]</code>，它只有一个元素，当然也是有序的），<span
class="math inline">\([i + 1, n)\)</span>
这部分是后续要考察的。在有序的部分找出 <code>a[i]</code> 的 Lower
Bound，将 <code>a[i]</code> 插入到这个位置之前，就让有序的部分增加了
<span class="math inline">\(1\)</span>，直到<span
class="math inline">\([0, n)\)</span>都有序。</p>
<img src="/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_insert_base.svg" class="" title="基本插入排序">
<p>已经学过有序数组中的二分查找，那么找到 <code>a[i]</code>
插入的位置可以用二分查找比<code>for</code>循环一个个找过去更快一些。</p>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：最坏情况每个元素都插入最前面，把已经有序的数据往后挪，<span
class="math inline">\(1+2+\dots +n-1 \approx O(n^2)\)</span></li>
<li>空间复杂度：除了数组本身，额外空间只有一些辅助变量，并没有达到 <span
class="math inline">\(n\)</span> 的级别，是 <span
class="math inline">\(O(1)\)</span></li>
<li>稳定性：对于关键数据相等的元素，后考察的在先考察的后面，插入位置找
Lower Bound，能保证排序后相对关系不变，<strong>稳定</strong></li>
</ul>
<p>实现方式不唯一，查找和插入都可以用线性表章节练习时的方法实现，这里给一种参考：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insertionsort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> now = a[i], j;</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &gt; <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; now; j --) &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];    <span class="comment">// 遇到不大于now的数之前，挨个往后挪一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = now;             <span class="comment">// 找到不大于now的位置，插入到该位置之后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序">希尔排序</h3>
<p>把数据按下标按固定间距分组，比如 <span
class="math inline">\(0,5,10,\dots\)</span>一组，<span
class="math inline">\(1,6,11,\dots\)</span>一组，<span
class="math inline">\(2,7,12,\dots\)</span>一组……各组可以分别做插入排序，然后缩小分组的固定间距再来一次，直到间距为
<span class="math inline">\(1\)</span>时再来一次，完成排序。</p>
<p>这样排序带来效率提升的主要原因是，在普通插入排序中，每个数在插入正确的位置时需要一个一个地跳过在它前面比它大的数。</p>
<p>而希尔排序中通过有跨度的分组排序，可以让数据跳过很多移动步骤。</p>
<p>比如 <span class="math inline">\(5,6,7,3,1\)</span>
中，插入朴素插入排序需要让 <span
class="math inline">\(1\)</span>挨个跳过前面 <span
class="math inline">\(4\)</span> 个数，而用希尔排序，把 <span
class="math inline">\(5,7,1\)</span>分成一组， <span
class="math inline">\(6,3\)</span> 分成一组， <span
class="math inline">\(1\)</span> 只需要跳过 <span
class="math inline">\(5\)</span> 和 <span
class="math inline">\(7\)</span> 两个数就到达的正确位置。</p>
<p><span class="math inline">\(n\)</span> 个数希尔排序具体步骤是：</p>
<ol type="1">
<li>以 <span class="math inline">\(\lfloor n/2 \lfloor\)</span>
为间距分组，分别进行插入排序 比如 <span
class="math inline">\(3,5,2,4,6,1,7,8\)</span> ，第一次分组就是 <span
class="math inline">\(3,6\)</span> 一组（ <span
class="math inline">\(3\)</span> 的下标是 <span
class="math inline">\([0]\)</span>， <span
class="math inline">\(6\)</span> 的下标是 <span
class="math inline">\([4]\)</span>，间距为 <span
class="math inline">\(4\)</span>）， <span
class="math inline">\(5,1\)</span> 一组， <span
class="math inline">\(2,7\)</span> 一组， <span class="math inline">\(4,
8\)</span> 一组</li>
<li>以 <span class="math inline">\(\lfloor n/4 \lfloor\)</span>
为间距分组，分别进行插入排序</li>
<li>不断缩小分组间距，直到以 <span class="math inline">\(1\)</span>
为间距分组，此时只有一个组，包含所有数，进行最后一次插入排序</li>
</ol>
<p>假设带有间距的插入排序
<code>InsertShort(int a[], int n, int start, int gap)</code>
（<code>start</code>表示第几组，<code>gap</code>表示间距）已经实现，在希尔排序中调用它，希尔排序参考如下：</p>
<blockquote>
<p>思考：分组个数与 <code>gap</code> 是什么关系？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">0</span>; start &lt; gap; start ++) &#123;</span><br><span class="line">            <span class="built_in">InsertSort</span>(a, n, start, gap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：希尔排序具体能省略多少移动，与数据分布和gap有关，经验来说复杂度在
<span class="math inline">\(O(n^{1.25}) \sim
O(1.6n^{1.25})\)</span></li>
<li>空间复杂度：除了数组本身，额外空间只有一些辅助变量， <span
class="math inline">\(O(1)\)</span></li>
<li>稳定性：分组分别插入排序的时候，某个组的数可能跳过了其它组与它相等的数，从而无法保证稳定，是
<strong>不稳定</strong> 排序</li>
</ul>
<h2 id="从冒泡排序到快速排序">从冒泡排序到快速排序</h2>
<h3 id="冒泡排序">冒泡排序</h3>
<p>从头到尾挨个比较相邻的两个元素，如果前一个比后一个大，就交换两个的位置。</p>
<p>在这个过程中，最大的那个数肯定会被持续交换到结尾。</p>
<p>那么再来一轮，从头到尾挨个比较（不过最后那个位置已经是最大的数，就不用管它了），第二大的数肯定会交换到倒数第二个位置。</p>
<p>如此进行，就会将第三大、第四大的数一轮又一轮地推到后面，最后数组就有序了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++) &#123;          <span class="comment">// 进行 n-1 轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j ++) &#123;  <span class="comment">// 每多一轮，就可以少管末尾一个数</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;              <span class="comment">// 判断相邻两数是否要交换</span></span><br><span class="line">                std::<span class="built_in">swap</span>(a[j], a[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：两个循环，第二个循环（挨个比较）是个递减的等差数列，
<span class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：除了数组本身，额外空间只有一些辅助变量， <span
class="math inline">\(O(1)\)</span></li>
<li>稳定性：相等的数不交换，能确保稳定</li>
</ul>
<h3 id="快速排序">快速排序</h3>
<p>也是基于交换的排序，但是比冒泡排序能够进行更高效的交换，基本思想：</p>
<p>取一个元素为中心，所有比它小的元素放它前面，比它大的放它后面。前后两部分分别递归地做相同的事。</p>
<img src="/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_quick.gif" class="" title="快速排序">
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// left、right左闭右开，low、high闭区间</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right - <span class="number">1</span>) <span class="keyword">return</span>;   <span class="comment">// 递归终点，只有一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> low = left;         <span class="comment">// low 游标从待排序最左元素下标开始</span></span><br><span class="line">    <span class="type">int</span> high = right - <span class="number">1</span>;   <span class="comment">// high 游标从待排序最右元素下标开始</span></span><br><span class="line">    <span class="type">int</span> center = a[low];    <span class="comment">// 选最左元素作为中心，a[low]存到临时变量center中，此时 low 位置空了出来</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 从右边开始挨个往左看，不小于 center 就保持不动，否则停下</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt;= center) high --;</span><br><span class="line">        <span class="comment">// 遇到了一个小于 center 的元素 a[high]，放到 low 指向的位置，此时 high 位置空了出来</span></span><br><span class="line">        a[low] = a[high];</span><br><span class="line">        <span class="comment">// 从左边开始挨个往右看，不大于 center 就保持不动，否则停下</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= center) low ++;</span><br><span class="line">        <span class="comment">// 遇到一个大于 center 的元素 a[low]，放到 low 指向的位置，此时 low 位置空了出来</span></span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// while循环结束，low 与 high 相遇，该位置空了出来，把刚才拿出的 center 放回来</span></span><br><span class="line">    a[low] = center;</span><br><span class="line">    <span class="built_in">QuickSort</span>(a, left, low);        <span class="comment">// 递归处理左半边，区间 [left, low)</span></span><br><span class="line">    <span class="built_in">QuickSort</span>(a, low + <span class="number">1</span>, right);   <span class="comment">// 递归处理右半边，区间 [low + 1, right)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：此处不作详细分析，在理想情况下（或平均情况下） <span
class="math inline">\(O(nlogn)\)</span></li>
<li>空间复杂度：递归存储开销， <span
class="math inline">\(O(logn)\)</span></li>
<li>稳定性：用于划分的中心数字有一定随机性，无法保证稳定性，<strong>不稳定</strong></li>
</ul>
<p>最坏情况：选择划分数可能每次都在一端，退化为 <span
class="math inline">\(n^2\)</span>，可以每次在 <span
class="math inline">\(low, high, \lfloor (low + high) / 2
\rfloor\)</span>三者取中间数降低最坏情况概率。</p>
<h2 id="从选择排序到堆排序">从选择排序到堆排序</h2>
<h3 id="选择排序">选择排序</h3>
<ul>
<li>在所有数中找出最小的数，与第一个位置的数交换</li>
<li>在剩下的数里选最小的数，与第二个位置的数交换</li>
<li>重复以上操作，直到不再剩下数</li>
</ul>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：每次剩下的数是个等差数列， <span
class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：无额外开销， <span
class="math inline">\(O(n)\)</span></li>
<li>稳定性：交换操作可能破坏部分数的前后关系，<strong>不稳定</strong></li>
</ul>
<p>一种优化——树形选择排序</p>
<img src="/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_selection_tree.png" class="" title="树形选择排序">
<p>像世界杯这样的锦标赛方式捉对pk来选出最小的数，已选出的数拿走后把锦标赛的这一步该数改为无穷大，重复这个赛区的“比赛”能得到新的最小的数。</p>
<h3 id="堆排序">堆排序</h3>
<p>用一个二叉堆的数据结构在原数组空间中维护最小数，它可以在 <span
class="math inline">\(O(nlogn)\)</span> 的一次初始化之后，每次在 <span
class="math inline">\(O(logn)\)</span>
时间内维护堆结构（让各子堆的堆顶都是堆内的最小值）。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> s, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> nex = s &lt;&lt; <span class="number">1</span>; nex &lt;= e; nex &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nex + <span class="number">1</span> &lt;= e &amp;&amp; a[nex + <span class="number">1</span>] &lt; a[nex]) nex ++;</span><br><span class="line">        <span class="keyword">if</span>(a[s] &lt;= a[nex]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Swap</span>(a[s], a[nex]);</span><br><span class="line">        s = nex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n &gt;&gt; <span class="number">1</span>; i; i --) <span class="built_in">HeapAdjust</span>(a, i, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i --) &#123;</span><br><span class="line">        <span class="built_in">Swap</span>(a[i], a[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(a, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></li>
<li>空间复杂度：无额外开销， <span
class="math inline">\(O(1)\)</span></li>
<li>稳定性：<strong>不稳定</strong></li>
</ul>
<p>堆是一个很有意义的数据结构，未来会了解优先队列，有很多任务需要在一堆动态插入的数据中找最小，堆可以在
<span
class="math inline">\(O(logn)\)</span>时间内维护堆的性质的这一特性将非常有用，经典算法
Dijkstra、Prim等都会用到基于堆实现的优先级队列。</p>
<h2 id="归并排序">归并排序</h2>
<p>在学过顺序表的归并操作之后，归并排序就不难理解了。</p>
<ul>
<li>从左到右每 <span class="math inline">\(2\)</span> 个数归并一次</li>
<li>从左到右每 <span class="math inline">\(4\)</span> 个数的前 <span
class="math inline">\(2\)</span> 个数与后 <span
class="math inline">\(2\)</span> 个数归并一次</li>
<li>从左到右每 <span class="math inline">\(8\)</span> 个数的前 <span
class="math inline">\(4\)</span> 个数与后 <span
class="math inline">\(4\)</span> 个数归并一次</li>
<li>直到所有的数归并到了一起，全部有序</li>
</ul>
<p>不过实现归并排序用递归的方式会更加方便，参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> mergeTemp[<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">char</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [left, right) 是待排序的区间</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right - <span class="number">1</span>) <span class="keyword">return</span>;   <span class="comment">// 递归终点，只有1个数</span></span><br><span class="line">    <span class="type">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;    <span class="comment">// 取中点，划分为左右两半</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(a, left, mid);        <span class="comment">// 递归地对左半边归并排序</span></span><br><span class="line">    <span class="built_in">MergeSort</span>(a, mid, right);       <span class="comment">// 递归地对右半边归并排序</span></span><br><span class="line">    <span class="comment">// 以上两个递归执行完后，左右两半边分别有序，接下来把两半边归并到一起</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i = k = left, j = mid; i &lt; mid &amp;&amp; j &lt; right; )</span><br><span class="line">    mergeTemp[k ++] = a[i] &lt;= a[j] ? a[i ++] : a[j ++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid) mergeTemp[k ++] = a[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; right) mergeTemp[k ++] = a[j ++];</span><br><span class="line">    <span class="comment">// 完成了[left, right)的排序，但用到了临时数组，把它拷贝回原数组这个区间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(a + left, mergeTemp + left, <span class="built_in">sizeof</span>(a[<span class="number">0</span>]) * (right - left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析三要素：</p>
<ul>
<li>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></li>
<li>空间复杂度：用到一个临时数组， <span
class="math inline">\(O(n)\)</span></li>
<li>稳定性：归并过程可以控制相等元素的先后关系，<strong>稳定</strong></li>
</ul>
<h2 id="非基于相互比较的排序">非基于相互比较的排序</h2>
<h3 id="基数排序">基数排序</h3>
<p>在对整数排序时，把各个十进制位分开考虑</p>
<ul>
<li>先将“个位”是 <span class="math inline">\(0 \sim 9\)</span>
的数放到对应的槽中，然后从 <span class="math inline">\(0 \sim 9\)</span>
的槽有序取出，所有数现在就按个位排好序了；</li>
<li>再将“十位”是 <span class="math inline">\(0 \sim 9\)</span>
的数放到对应的槽中，然后从 <span class="math inline">\(0 \sim 9\)</span>
的槽有序取出，所有数现在就按十位排好序了，且对于十位相同，个位不同的那些数，没有破坏之前个位排好的先后关系；</li>
<li>再将“百位”……</li>
<li>直到各个位都排完</li>
</ul>
<img src="/2025-03-10-07-%E6%8E%92%E5%BA%8F/sort_base.gif" class="" title="基数排序">
<p>参考代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1100</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; l[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSortIth</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> dec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">        l[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        l[a[i] / dec % <span class="number">10</span>].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxa = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        maxa = maxa &gt; a[i] ? maxa : a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, dec = <span class="number">1</span>; maxa; i ++, maxa /= <span class="number">10</span>, dec *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">RadixSortIth</span>(a, n, dec);</span><br><span class="line">        <span class="built_in">MoveBack</span>(a, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计数排序">计数排序</h3>
<p>适用于一定范围不大的整数排序，初始化一个统计各个数出现次数的数组，遍历待排序数组，统计每个数的个数。</p>
<p>遍历计数的数组，把原数组的数从小到大按重复个数一一列出来，完成排序。</p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountingSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大数</span></span><br><span class="line">    <span class="type">int</span> maxa = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        maxa = maxa &gt; a[i] ? maxa : a[i];</span><br><span class="line">    <span class="comment">// 统计每个数的个数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(maxa + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        count[a[i]]++;</span><br><span class="line">    <span class="comment">// 按个数统计，从小到大列出每个数</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxa; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; count[i]; j ++)</span><br><span class="line">            a[index ++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="桶排序">桶排序</h3>
<p>把数值的区间分成若干个子区间，设置一些“桶”，把对应区间的数放进桶里。</p>
<p>对每个桶里的数用其它算法排序，再将各个桶的数取出按顺序放在一起。</p>
<h2 id="stl-sort-的基本使用">STL： sort 的基本使用</h2>
<p><code>C++</code>的 STL 提供了 sort
函数，它的前两个参数是待排序数组的开头和末尾的迭代器，默认升序排序。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>第三个参数可选，可以传入一个自己定义的比较两元素的函数，用于自定义排序方案，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br></pre></td></tr></table></figure>
<p>这个代码通过 <code>cmp</code> 就实现了降序排序</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ACM/" rel="tag"># ACM</a>
              <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025-03-06-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80/" rel="prev" title="06.字符串基础">
                  <i class="fa fa-angle-left"></i> 06.字符串基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025-03-10-08-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" rel="next" title="08.栈与队列">
                  08.栈与队列 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">CSGrandeur</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://fastly.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://fastly.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://fastly.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"CSGrandeur/csgrandeur.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
