<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.csgrandeur.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="LeetCode OJ is a platform for preparing technical coding interviews. LeetCode OJ 是为与写代码有关的技术工作面试者设计的训练平台。 LeetCode OJ:http:&#x2F;&#x2F;oj.leetcode.com&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 题解">
<meta property="og:url" content="http://blog.csgrandeur.cn/2014-01-15-LeetCode-OJ-Solution/index.html">
<meta property="og:site_name" content="CSGrandeur&#39;s Thinking">
<meta property="og:description" content="LeetCode OJ is a platform for preparing technical coding interviews. LeetCode OJ 是为与写代码有关的技术工作面试者设计的训练平台。 LeetCode OJ:http:&#x2F;&#x2F;oj.leetcode.com&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2014-01-15T07:34:00.000Z">
<meta property="article:modified_time" content="2025-03-06T02:27:46.945Z">
<meta property="article:author" content="CSGrandeur">
<meta property="article:tag" content="LeetCode题解">
<meta property="article:tag" content="题解">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://blog.csgrandeur.cn/2014-01-15-LeetCode-OJ-Solution/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://blog.csgrandeur.cn/2014-01-15-LeetCode-OJ-Solution/","path":"2014-01-15-LeetCode-OJ-Solution/","title":"LeetCode 题解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LeetCode 题解 | CSGrandeur's Thinking</title>
  
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-69787882-2","only_pageview":true,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CSGrandeur's Thinking</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Cogito Ergo Sum</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#implement-trie-prefix-tree"><span class="nav-number">1.</span> <span class="nav-text">208.Implement
Trie (Prefix Tree)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#course-schedule"><span class="nav-number">2.</span> <span class="nav-text">207.Course
Schedule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse-linked-list"><span class="nav-number">3.</span> <span class="nav-text">206.Reverse
Linked List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isomorphic-strings"><span class="nav-number">4.</span> <span class="nav-text">205.Isomorphic
Strings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-primes"><span class="nav-number">5.</span> <span class="nav-text">204.Count
Primes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-linked-list-elements"><span class="nav-number">6.</span> <span class="nav-text">203.Remove
Linked List Elements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#happy-number"><span class="nav-number">7.</span> <span class="nav-text">202.Happy
Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitwise-and-of-numbers-range"><span class="nav-number">8.</span> <span class="nav-text">201.Bitwise
AND of Numbers Range*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#number-of-islands"><span class="nav-number">9.</span> <span class="nav-text">200.Number of
Islands</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree-right-side-view"><span class="nav-number">10.</span> <span class="nav-text">199.Binary
Tree Right Side View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#house-robber"><span class="nav-number">11.</span> <span class="nav-text">198.House
Robber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#number-of-1-bits"><span class="nav-number">12.</span> <span class="nav-text">191.Number of 1
Bits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse-bits"><span class="nav-number">13.</span> <span class="nav-text">190.Reverse
Bits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate-array"><span class="nav-number">14.</span> <span class="nav-text">189.Rotate
Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#best-time-to-buy-and-sell-stock-iv"><span class="nav-number">15.</span> <span class="nav-text">188.Best
Time to Buy and Sell Stock IV*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#repeated-dna-sequences"><span class="nav-number">16.</span> <span class="nav-text">187.Repeated
DNA Sequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#largest-number"><span class="nav-number">17.</span> <span class="nav-text">179.Largest
Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dungeon-game"><span class="nav-number">18.</span> <span class="nav-text">174.Dungeon
Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-search-tree-iterator"><span class="nav-number">19.</span> <span class="nav-text">173.Binary
Search Tree Iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#factorial-trailing-zeroes"><span class="nav-number">20.</span> <span class="nav-text">172.Factorial
Trailing Zeroes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#excel-sheet-column-number"><span class="nav-number">21.</span> <span class="nav-text">171.Excel
Sheet Column Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#majority-element"><span class="nav-number">22.</span> <span class="nav-text">169.Majority
Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#excel-sheet-column-title"><span class="nav-number">23.</span> <span class="nav-text">168.Excel
Sheet Column Title</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fraction-to-recurring-decimal"><span class="nav-number">24.</span> <span class="nav-text">166.Fraction
to Recurring Decimal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compare-version-numbers"><span class="nav-number">25.</span> <span class="nav-text">165.Compare
Version Numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-gap"><span class="nav-number">26.</span> <span class="nav-text">164.Maximum
Gap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-peak-element"><span class="nav-number">27.</span> <span class="nav-text">162.Find Peak
Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#intersection-of-two-linked-lists"><span class="nav-number">28.</span> <span class="nav-text">160.Intersection
of Two Linked Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#min-stack"><span class="nav-number">29.</span> <span class="nav-text">155.Min Stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-minimum-in-rotated-sorted-array-ii"><span class="nav-number">30.</span> <span class="nav-text">154.Find
Minimum in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-minimum-in-rotated-sorted-array"><span class="nav-number">31.</span> <span class="nav-text">153.Find
Minimum in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-product-subarray"><span class="nav-number">32.</span> <span class="nav-text">152.Maximum
Product Subarray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse-words-in-a-string"><span class="nav-number">33.</span> <span class="nav-text">151.Reverse
Words in a String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#evaluate-reverse-polish-notation"><span class="nav-number">34.</span> <span class="nav-text">150.Evaluate
Reverse Polish Notation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#max-points-on-a-line"><span class="nav-number">35.</span> <span class="nav-text">149.Max
Points on a Line</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-list"><span class="nav-number">36.</span> <span class="nav-text">148.Sort List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insertion-sort-list"><span class="nav-number">37.</span> <span class="nav-text">147.Insertion
Sort List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lru-cache"><span class="nav-number">38.</span> <span class="nav-text">146.LRU Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree-postorder-traversal"><span class="nav-number">39.</span> <span class="nav-text">145.Binary
Tree Postorder Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree-preorder-traversal"><span class="nav-number">40.</span> <span class="nav-text">144.Binary
Tree Preorder Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reorder-list"><span class="nav-number">41.</span> <span class="nav-text">143.Reorder
List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linked-list-cycle-ii"><span class="nav-number">42.</span> <span class="nav-text">142.Linked
List Cycle II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linked-list-cycle"><span class="nav-number">43.</span> <span class="nav-text">141.Linked
List Cycle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-break-ii"><span class="nav-number">44.</span> <span class="nav-text">140.Word Break
II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-break"><span class="nav-number">45.</span> <span class="nav-text">139.Word
Break</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-list-with-random-pointer"><span class="nav-number">46.</span> <span class="nav-text">138.Copy
List with Random Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#single-number-ii"><span class="nav-number">47.</span> <span class="nav-text">137.Single
Number II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#single-number"><span class="nav-number">48.</span> <span class="nav-text">136.Single
Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#candy"><span class="nav-number">49.</span> <span class="nav-text">135.Candy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gas-station"><span class="nav-number">50.</span> <span class="nav-text">134.Gas
Station</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clone-graph"><span class="nav-number">51.</span> <span class="nav-text">133.Clone
Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#palindrome-partitioning-ii"><span class="nav-number">52.</span> <span class="nav-text">132.Palindrome
Partitioning II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#palindrome-partitioning"><span class="nav-number">53.</span> <span class="nav-text">131.Palindrome
Partitioning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#surrounded-regions"><span class="nav-number">54.</span> <span class="nav-text">130.Surrounded
Regions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sum-root-to-leaf-numbers"><span class="nav-number">55.</span> <span class="nav-text">129.Sum
Root to Leaf Numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#longest-consecutive-sequence"><span class="nav-number">56.</span> <span class="nav-text">128.Longest
Consecutive Sequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-ladder-ii"><span class="nav-number">57.</span> <span class="nav-text">127.Word Ladder
II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-ladder"><span class="nav-number">58.</span> <span class="nav-text">126.Word
Ladder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valid-palindrome"><span class="nav-number">59.</span> <span class="nav-text">125.Valid
Palindrome</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree-maximum-path-sum"><span class="nav-number">60.</span> <span class="nav-text">124.Binary
Tree Maximum Path Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#best-time-to-buy-and-sell-stock-iii"><span class="nav-number">61.</span> <span class="nav-text">123.Best
Time to Buy and Sell Stock III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#best-time-to-buy-and-sell-stock-ii"><span class="nav-number">62.</span> <span class="nav-text">122.Best
Time to Buy and Sell Stock II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#best-time-to-buy-and-sell-stock"><span class="nav-number">63.</span> <span class="nav-text">121.Best
Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#triangle"><span class="nav-number">64.</span> <span class="nav-text">120.Triangle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pascals-triangle-ii"><span class="nav-number">65.</span> <span class="nav-text">119.Pascal&#39;s
Triangle II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pascals-triangle"><span class="nav-number">66.</span> <span class="nav-text">118.Pascal&#39;s
Triangle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#populating-next-right-pointers-in-each-node-ii"><span class="nav-number">67.</span> <span class="nav-text">117.Populating
Next Right Pointers in Each Node II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#populating-next-right-pointers-in-each-node"><span class="nav-number">68.</span> <span class="nav-text">116.Populating
Next Right Pointers in Each Node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#distinct-subsequences"><span class="nav-number">69.</span> <span class="nav-text">115.Distinct
Subsequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatten-binary-tree-to-linked-list"><span class="nav-number">70.</span> <span class="nav-text">114.Flatten
Binary Tree to Linked List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#path-sum-ii"><span class="nav-number">71.</span> <span class="nav-text">113.Path Sum
II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#path-sum"><span class="nav-number">72.</span> <span class="nav-text">112.Path Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-depth-of-binary-tree"><span class="nav-number">73.</span> <span class="nav-text">111.Minimum
Depth of Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#balanced-binary-tree"><span class="nav-number">74.</span> <span class="nav-text">110.Balanced
Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#convert-sorted-list-to-binary-search-tree"><span class="nav-number">75.</span> <span class="nav-text">109.Convert
Sorted List to Binary Search Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#convert-sorted-array-to-binary-search-tree"><span class="nav-number">76.</span> <span class="nav-text">108.Convert
Sorted Array to Binary Search Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree-level-order-traversal-ii"><span class="nav-number">77.</span> <span class="nav-text">107.Binary
Tree Level Order Traversal II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#construct-binary-tree-from-inorder-and-postorder-traversal"><span class="nav-number">78.</span> <span class="nav-text">106.Construct
Binary Tree from Inorder and Postorder Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#construct-binary-tree-from-preorder-and-inorder-traversal"><span class="nav-number">79.</span> <span class="nav-text">105.Construct
Binary Tree from Preorder and Inorder Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-depth-of-binary-tree"><span class="nav-number">80.</span> <span class="nav-text">104.Maximum
Depth of Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree-zigzag-level-order-traversal"><span class="nav-number">81.</span> <span class="nav-text">103.Binary
Tree Zigzag Level Order Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree-level-order-traversal"><span class="nav-number">82.</span> <span class="nav-text">102.Binary
Tree Level Order Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#symmetric-tree"><span class="nav-number">83.</span> <span class="nav-text">101.Symmetric
Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#same-tree"><span class="nav-number">84.</span> <span class="nav-text">100.Same Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recover-binary-search-tree"><span class="nav-number">85.</span> <span class="nav-text">99.Recover
Binary Search Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#validate-binary-search-tree"><span class="nav-number">86.</span> <span class="nav-text">98.Validate
Binary Search Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interleaving-string"><span class="nav-number">87.</span> <span class="nav-text">97.Interleaving
String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-binary-search-trees-ii"><span class="nav-number">88.</span> <span class="nav-text">96.Unique
Binary Search Trees II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-binary-search-trees"><span class="nav-number">89.</span> <span class="nav-text">95.Unique
Binary Search Trees</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree-inorder-traversal"><span class="nav-number">90.</span> <span class="nav-text">94.Binary
Tree Inorder Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#restore-ip-addresses"><span class="nav-number">91.</span> <span class="nav-text">93.Restore
IP Addresses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse-linked-list-ii"><span class="nav-number">92.</span> <span class="nav-text">92.Reverse
Linked List II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decode-ways"><span class="nav-number">93.</span> <span class="nav-text">91.Decode
Ways</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#subsets-ii"><span class="nav-number">94.</span> <span class="nav-text">90.Subsets
II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gray-code"><span class="nav-number">95.</span> <span class="nav-text">89.Gray Code</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge-sorted-array"><span class="nav-number">96.</span> <span class="nav-text">88.Merge
Sorted Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scramble-string"><span class="nav-number">97.</span> <span class="nav-text">87.Scramble
String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partition-list"><span class="nav-number">98.</span> <span class="nav-text">86.Partition
List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximal-rectangle"><span class="nav-number">99.</span> <span class="nav-text">85.Maximal
Rectangle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#largest-rectangle-in-histogram"><span class="nav-number">100.</span> <span class="nav-text">84.Largest
Rectangle in Histogram</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-duplicates-from-sorted-list-ii"><span class="nav-number">101.</span> <span class="nav-text">83.Remove
Duplicates from Sorted List II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-duplicates-from-sorted-list"><span class="nav-number">102.</span> <span class="nav-text">82.Remove
Duplicates from Sorted List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-in-rotated-sorted-array-ii"><span class="nav-number">103.</span> <span class="nav-text">81.Search
in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-duplicates-from-sorted-array-ii"><span class="nav-number">104.</span> <span class="nav-text">80.Remove
Duplicates from Sorted Array II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-search"><span class="nav-number">105.</span> <span class="nav-text">79.Word
Search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#subsets"><span class="nav-number">106.</span> <span class="nav-text">78.Subsets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#combinations"><span class="nav-number">107.</span> <span class="nav-text">77.Combinations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-window-substring"><span class="nav-number">108.</span> <span class="nav-text">76.Minimum
Window Substring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-colors"><span class="nav-number">109.</span> <span class="nav-text">75.Sort
Colors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-a-2d-matrix"><span class="nav-number">110.</span> <span class="nav-text">74.Search a
2D Matrix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-matrix-zeroes"><span class="nav-number">111.</span> <span class="nav-text">73.Set Matrix
Zeroes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#edit-distance"><span class="nav-number">112.</span> <span class="nav-text">72.Edit
Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#simplify-path"><span class="nav-number">113.</span> <span class="nav-text">71.Simplify
Path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#climbing-stairs"><span class="nav-number">114.</span> <span class="nav-text">70.Climbing
Stairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sqrtx"><span class="nav-number">115.</span> <span class="nav-text">69.Sqrt(x)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#text-justification"><span class="nav-number">116.</span> <span class="nav-text">68.Text
Justification</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#plus-one"><span class="nav-number">117.</span> <span class="nav-text">67.Plus One</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valid-number"><span class="nav-number">118.</span> <span class="nav-text">66.Valid
Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-binary"><span class="nav-number">119.</span> <span class="nav-text">65.Add
Binary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-path-sum"><span class="nav-number">120.</span> <span class="nav-text">64.Minimum Path
Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-paths-ii"><span class="nav-number">121.</span> <span class="nav-text">63.Unique Paths
II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-paths"><span class="nav-number">122.</span> <span class="nav-text">62.Unique
Paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate-list"><span class="nav-number">123.</span> <span class="nav-text">61.Rotate
List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#permutation-sequence"><span class="nav-number">124.</span> <span class="nav-text">60.Permutation
Sequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spiral-matrix-ii"><span class="nav-number">125.</span> <span class="nav-text">59.Spiral
Matrix II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#length-of-last-word"><span class="nav-number">126.</span> <span class="nav-text">58.Length of
Last Word</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert-interval"><span class="nav-number">127.</span> <span class="nav-text">57.Insert
Interval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge-intervals"><span class="nav-number">128.</span> <span class="nav-text">56.Merge
Intervals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jump-game"><span class="nav-number">129.</span> <span class="nav-text">55.Jump Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spiral-matrix"><span class="nav-number">130.</span> <span class="nav-text">54.Spiral
Matrix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-subarray"><span class="nav-number">131.</span> <span class="nav-text">53.Maximum
Subarray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#n-queens-ii"><span class="nav-number">132.</span> <span class="nav-text">52.N-Queens
II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#n-queens"><span class="nav-number">133.</span> <span class="nav-text">51.N-Queens</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#powx-n"><span class="nav-number">134.</span> <span class="nav-text">50.Pow(x, n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anagrams"><span class="nav-number">135.</span> <span class="nav-text">49.Anagrams</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rotate-image"><span class="nav-number">136.</span> <span class="nav-text">48.Rotate
Image</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#permutations-ii"><span class="nav-number">137.</span> <span class="nav-text">47.Permutations
II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#permutations"><span class="nav-number">138.</span> <span class="nav-text">46.Permutations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jump-game-ii"><span class="nav-number">139.</span> <span class="nav-text">45.Jump Game
II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wildcard-matching"><span class="nav-number">140.</span> <span class="nav-text">44.Wildcard
Matching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multiply-strings"><span class="nav-number">141.</span> <span class="nav-text">43.Multiply
Strings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trapping-rain-water"><span class="nav-number">142.</span> <span class="nav-text">42.Trapping
Rain Water</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#first-missing-positive"><span class="nav-number">143.</span> <span class="nav-text">41.First
Missing Positive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#combination-sum"><span class="nav-number">144.</span> <span class="nav-text">40.Combination
Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#combination-sum-ii"><span class="nav-number">145.</span> <span class="nav-text">39.Combination
Sum II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-and-say"><span class="nav-number">146.</span> <span class="nav-text">38.Count and
Say</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sudoku-solver"><span class="nav-number">147.</span> <span class="nav-text">37.Sudoku
Solver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valid-sudoku"><span class="nav-number">148.</span> <span class="nav-text">36.Valid
Sudoku</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-insert-position"><span class="nav-number">149.</span> <span class="nav-text">35.Search
Insert Position</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-for-a-range"><span class="nav-number">150.</span> <span class="nav-text">34.Search for
a Range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-in-rotated-sorted-array"><span class="nav-number">151.</span> <span class="nav-text">33.Search
in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#longest-valid-parentheses"><span class="nav-number">152.</span> <span class="nav-text">32.Longest
Valid Parentheses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#next-permutation"><span class="nav-number">153.</span> <span class="nav-text">31.Next
Permutation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#substring-with-concatenation-of-all-words"><span class="nav-number">154.</span> <span class="nav-text">30.Substring
with Concatenation of All Words</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#divide-two-integers"><span class="nav-number">155.</span> <span class="nav-text">29.Divide
Two Integers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implement-strstr"><span class="nav-number">156.</span> <span class="nav-text">28.Implement
strStr()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-element"><span class="nav-number">157.</span> <span class="nav-text">27.Remove
Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-duplicates-from-sorted-array"><span class="nav-number">158.</span> <span class="nav-text">26.Remove
Duplicates from Sorted Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse-nodes-in-k-group"><span class="nav-number">159.</span> <span class="nav-text">25.Reverse
Nodes in k-Group</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap-nodes-in-pairs"><span class="nav-number">160.</span> <span class="nav-text">24.Swap
Nodes in Pairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge-k-sorted-lists"><span class="nav-number">161.</span> <span class="nav-text">23.Merge k
Sorted Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generate-parentheses"><span class="nav-number">162.</span> <span class="nav-text">22.Generate
Parentheses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge-two-sorted-lists"><span class="nav-number">163.</span> <span class="nav-text">21.Merge
Two Sorted Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valid-parentheses"><span class="nav-number">164.</span> <span class="nav-text">20.Valid
Parentheses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-nth-node-from-end-of-list"><span class="nav-number">165.</span> <span class="nav-text">19.Remove
Nth Node From End of List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sum"><span class="nav-number">166.</span> <span class="nav-text">18.4Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#letter-combinations-of-a-phone-number"><span class="nav-number">167.</span> <span class="nav-text">17.Letter
Combinations of a Phone Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sum-closest"><span class="nav-number">168.</span> <span class="nav-text">16.3Sum
Closest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sum-1"><span class="nav-number">169.</span> <span class="nav-text">15.3Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#longest-common-prefix"><span class="nav-number">170.</span> <span class="nav-text">14.Longest
Common Prefix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#roman-to-integer"><span class="nav-number">171.</span> <span class="nav-text">13.Roman to
Integer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#integer-to-roman"><span class="nav-number">172.</span> <span class="nav-text">12.Integer to
Roman</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#container-with-most-water"><span class="nav-number">173.</span> <span class="nav-text">11.Container
With Most Water</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regular-expression-matching"><span class="nav-number">174.</span> <span class="nav-text">10.Regular
Expression Matching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#palindrome-number"><span class="nav-number">175.</span> <span class="nav-text">9.Palindrome
Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-to-integer-atoi"><span class="nav-number">176.</span> <span class="nav-text">8.String
to Integer (atoi)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse-integer"><span class="nav-number">177.</span> <span class="nav-text">7.Reverse
Integer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zigzag-conversion"><span class="nav-number">178.</span> <span class="nav-text">6.ZigZag
Conversion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#longest-palindromic-substring"><span class="nav-number">179.</span> <span class="nav-text">5.Longest
Palindromic Substring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#median-of-two-sorted-arrays"><span class="nav-number">180.</span> <span class="nav-text">4.Median
of Two Sorted Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#longest-substring-without-repeating-characters"><span class="nav-number">181.</span> <span class="nav-text">3.Longest
Substring Without Repeating Characters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-two-numbers"><span class="nav-number">182.</span> <span class="nav-text">2.Add Two
Numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#two-sum"><span class="nav-number">183.</span> <span class="nav-text">1.Two Sum</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CSGrandeur</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.csgrandeur.cn/2014-01-15-LeetCode-OJ-Solution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CSGrandeur">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CSGrandeur's Thinking">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LeetCode 题解 | CSGrandeur's Thinking">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode 题解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-01-15 15:34:00" itemprop="dateCreated datePublished" datetime="2014-01-15T15:34:00+08:00">2014-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-06 10:27:46" itemprop="dateModified" datetime="2025-03-06T10:27:46+08:00">2025-03-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>LeetCode OJ is a platform for preparing technical coding
interviews.</p>
<p>LeetCode OJ 是为与写代码有关的技术工作面试者设计的训练平台。</p>
<p>LeetCode OJ:<a
target="_blank" rel="noopener" href="http://oj.leetcode.com/">http://oj.leetcode.com/</a></p>
<span id="more"></span>
<p>默认题目顺序为题目添加时间倒叙，本文题解顺序与OJ题目顺序一致（OJ会更新，至少目前一致。。。）。
习惯大括号换行，遇到大括号默认不换行的样例代码，导致有的换行有的没换行，实在懒得一个个改……</p>
<hr />
<p>2015.11.17更新：今天又看leetcode，发现题目列表终于有编号了。
咦，新题目加锁了，要25 dollar一个月的捐赠……</p>
<hr />
<p>Made By：<a target="_blank" rel="noopener" href="http://blog.csgrandeur.com/">CSGrandeur</a>: <a
target="_blank" rel="noopener" href="http://blog.csgrandeur.com/2014-01-15-LeetCode-OJ-Solution/">LeetCode
题解</a></p>
<hr />
<h3 id="implement-trie-prefix-tree"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-trie-prefix-tree/">208.Implement
Trie (Prefix Tree)</a></h3>
<blockquote>
<p>20170209</p>
</blockquote>
<p>基本字典树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *nex[<span class="number">26</span>];</span><br><span class="line">        <span class="type">bool</span> word;</span><br><span class="line">        <span class="built_in">Node</span>()&#123;<span class="built_in">memset</span>(nex, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(nex)), word = <span class="literal">false</span>;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node;</span><br><span class="line">            p = p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;word = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node *p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : prefix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;nex[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="course-schedule"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule/">207.Course
Schedule</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>先构造个图。一开始没想拓扑排序的事，就用DFS来判断的，标记-1表示<code>尚未考察</code>，0表示<code>暂没结果</code>，1表示<code>确认可选修</code>。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; fst, nex, v;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ok;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ok[i] != <span class="number">-1</span>) <span class="keyword">return</span> ok[i];</span><br><span class="line">        ok[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = fst[i]; j != <span class="number">-1</span>; j = nex[j])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">DFS</span>(v[j]))</span><br><span class="line">                <span class="keyword">return</span> ok[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ok[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        fst.<span class="built_in">resize</span>(numCourses + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        ok.<span class="built_in">resize</span>(numCourses + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            nex.<span class="built_in">push_back</span>(fst[prerequisites[i].first]);</span><br><span class="line">            fst[prerequisites[i].first] = nex.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            v.<span class="built_in">push_back</span>(prerequisites[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = numCourses - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            numCourses -= <span class="built_in">DFS</span>(i);</span><br><span class="line">        <span class="keyword">return</span> !numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="reverse-linked-list"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">206.Reverse
Linked List</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>好像又是老题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="isomorphic-strings"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/isomorphic-strings/">205.Isomorphic
Strings</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>思路一是两个map互相映射，出现矛盾则说明不同构。两个map用于解决其中一个串可能有多个字符对应另一个串同一个字符，只用一个map则会掉这个坑。、</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">mp1</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span>, <span class="title">mp2</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp1[s[i]]) mp1[s[i]] = t[i];</span><br><span class="line">            <span class="keyword">if</span>(!mp2[t[i]]) mp2[t[i]] = s[i];</span><br><span class="line">            <span class="keyword">if</span>(mp1[s[i]] != t[i] || mp2[t[i]] != s[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路二是把俩字符串按同一规则转换，转换后字符串直接比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">convert</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">mp</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp[s[i]]) mp[s[i]] = p ++;</span><br><span class="line">            s[i] = mp[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">convert</span>(s);</span><br><span class="line">        <span class="built_in">convert</span>(t);</span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="count-primes"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/count-primes/">204.Count
Primes</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>筛素数，以前比赛时候写的滚瓜烂熟的，现在竟然忘了还复习一下……
从2开始把每个其倍数都标记成合数，然后往后枚举，枚举到的没标记的一定是素数（如果它是合数，它的质因数肯定比它小，而比它小的质数的倍数都已经标记过了），继续标记其所有倍数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">pr</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ret ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt; n; j += i)</span><br><span class="line">                    pr[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-linked-list-elements"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-linked-list-elements/">203.Remove
Linked List Elements</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>好像又是老题，开头加个哨兵节点就不用担心head节点被删除的情况了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(ListNode *p = pre; head != <span class="literal">NULL</span>; head = head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="happy-number"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/happy-number/">202.Happy
Number</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>直接思路是用哈希记录判循环，降低空间复杂度可以用两个值一个每次算一步，另一个每次算两步来判循环。
还有个方法是只要大于 6 就一直进行，能保证计算结束，不知道怎么证明的。
代码放传统思路。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SumSquare</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += (x % <span class="number">10</span>) * (x % <span class="number">10</span>);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">count</span>(n))</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(n);</span><br><span class="line">            n = <span class="built_in">SumSquare</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">count</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="bitwise-and-of-numbers-range"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/bitwise-and-of-numbers-range/">201.Bitwise
AND of Numbers Range</a>*</h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>二进制从左往右看，当遇到某位不相等的时候，最终结果后面的位都会是0，因为在<code>n~m</code>之间，连续的数字中这些位肯定会出现0。题目巧在如果思路转换为求二进制最长相同前缀，代码就很简单了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)</span><br><span class="line">        &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一种理解方式也很好，把n的右侧的1一一去掉，当n不大于m的时候，n剩下的就是那个相同前缀。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; m)</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="number-of-islands"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/">200.Number of
Islands</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>我一定是做了道假题。。DFS、BFS随便做，好陈旧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> row, col;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;grid, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y));</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nex = <span class="built_in">make_pair</span>(now.first + dx[i], now.second + dy[i]);</span><br><span class="line">                <span class="keyword">if</span>(nex.first &gt;= <span class="number">0</span> &amp;&amp; nex.first &lt; row &amp;&amp; nex.second &gt;= <span class="number">0</span> &amp;&amp; nex.second &lt; col &amp;&amp; grid[nex.first][nex.second] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    grid[nex.first][nex.second] = <span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(nex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        row = grid.<span class="built_in">size</span>();</span><br><span class="line">        col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    ret ++, <span class="built_in">BFS</span>(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-right-side-view"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/">199.Binary
Tree Right Side View</a></h3>
<blockquote>
<p>20170208</p>
</blockquote>
<p>二叉树层次遍历，加个层数标记。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *p;</span><br><span class="line">        <span class="type">int</span> layer;</span><br><span class="line">        <span class="built_in">Node</span>(TreeNode *p_, <span class="type">int</span> layer_):<span class="built_in">p</span>(p_), <span class="built_in">layer</span>(layer_)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">Node</span>(root, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Node now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(last != now.layer)</span><br><span class="line">            &#123;</span><br><span class="line">                last = now.layer;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(now.p-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now.p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(now.p-&gt;right, now.layer + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(now.p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(now.p-&gt;left, now.layer + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="house-robber"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/">198.House
Robber</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>简单的动态规划，两个数一个表示<code>上一个没rob</code>的当前最佳收益，另一个表示<code>上一个rob了</code>的，反复更新。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>] + m);</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="number-of-1-bits"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-1-bits/">191.Number of 1
Bits</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>做过树状数组应该对<code>n&amp;(n-1)</code>很熟了，<code>n-1</code>让二进制末尾的1变0，这个1后面的0都变1，和<code>n</code>做按位与就相当于去掉了最后一个1，这样每次操作都能去掉一个1，一位一位统计就快多了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-bits"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-bits/">190.Reverse
Bits</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>首先是最直接的方法，把所有bit放到新数中的对应位置。 题目提到一句“If
this function is called many times, how would you optimize
it?”是很值得思考的。直接的方法进行了32次操作，每个操作里有若干次位运算，这个数字是否可以优化呢？
一个可能思路是并行的分治。问题二分，并行用位运算实现，这样就<code>log(32)=5</code>次操作了。</p>
<p>直接思路：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++)</span><br><span class="line">            ret |= ((n &gt;&gt; i) &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并行分治思路：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n &amp; <span class="number">0x0000FFFF</span>) &lt;&lt; <span class="number">16</span> | (n &amp; <span class="number">0xFFFF0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        n = (n &amp; <span class="number">0x00FF00FF</span>) &lt;&lt; <span class="number">8</span> | (n &amp; <span class="number">0xFF00FF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n = (n &amp; <span class="number">0x0F0F0F0F</span>) &lt;&lt; <span class="number">4</span> | (n &amp; <span class="number">0xF0F0F0F0</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n = (n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (n &amp; <span class="number">0xCCCCCCCC</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n = (n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (n &amp; <span class="number">0xAAAAAAAA</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-array"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-array/">189.Rotate
Array</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>空间复杂度不是<code>O(1)</code>的想都不要想。网上方法已经很多了，如：
1、后<code>k</code>个翻转，前面的翻转，再整个翻转。
2、前<code>k</code>个和后<code>k</code>个一一swap，就变成后<code>n-k</code>个做<code>k</code>旋转的子问题了，继续进行到结束。
3、把数组分成若干个以<code>k</code>为间隔的“子数组”，而且这个“子数组”是可以循环回去的，比如<code>1, 2, 3, 4, 5</code>,
<code>k=3</code>，“子数组”就是<code>1, 4, 2, 5, 3</code>，对它做<code>step=1</code>的右循环。
这里放 方法3 的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> readynum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; readynum &lt; nums.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + k; ; j = (j + k) % nums.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(tmp, nums[j]);</span><br><span class="line">                readynum ++;</span><br><span class="line">                <span class="keyword">if</span>(j == i)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="best-time-to-buy-and-sell-stock-iv"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">188.Best
Time to Buy and Sell Stock IV</a>*</h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>一开始思路是常规的记忆化搜索，状态记录为<code>[第i天价格][剩下k次][是否在买入状态]</code>，是否买入状态是二值的，所以内存主要在于天数和次数的取值，小trick是k取值过大时候，可缩小到天数的<code>1/2</code>。结果还是超内存了，虽然网上看到有类似解法没超内存，不过看最大那组数据，还是不适合开二维数组的。</p>
<p>这题有个特别之处，当考察第<code>i</code>天时，并不关心这是多少天了，而关心的只是当前的盈利情况和剩下多少次交易机会，于是数组缩小为次数<code>k</code>这一维。两个数组分别表示剩下<code>k</code>次的买入状态余额和非买入状态余额，状态方程是<code>buy[k]=max(buy[k], sell[k-1] - price); sell[k]=max(sell[k], buy[k] + price);</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; prices.<span class="built_in">size</span>() / <span class="number">2</span>)</span><br><span class="line">            k = prices.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buy</span><span class="params">(k + <span class="number">1</span>, <span class="number">-0x3f3f3f3f</span>)</span>, <span class="title">sell</span><span class="params">(k + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> price : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = k; i &gt; <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                buy[i] = <span class="built_in">max</span>(buy[i], sell[i - <span class="number">1</span>] - price);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = k; i &gt; <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                sell[i] = <span class="built_in">max</span>(sell[i], buy[i] + price);</span><br><span class="line">                ret = <span class="built_in">max</span>(sell[i], ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="repeated-dna-sequences"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/repeated-dna-sequences/">187.Repeated
DNA Sequences</a></h3>
<blockquote>
<p>20170207</p>
</blockquote>
<p>没遇到网上说的内存问题，直接unordered_map过掉了。用字典树应该会比较快和稳定吧。
对每个长度为10的串进行统计，大于1次就做记录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">bool</span>&gt; mp;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">10</span>; i &lt;= s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp = s.<span class="built_in">substr</span>(i - <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(tmp))</span><br><span class="line">                mp[tmp] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mp[tmp] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                mp[tmp] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="largest-number"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-number/">179.Largest
Number</a></h3>
<p>一开始用递归写了个复杂逻辑的comp函数，后来发现，主要确定两个字符串 a,
b 的 a+b 和 b+a 的大小关系，就能确定 a 和 b 的顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b &gt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector vs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            vs.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(num));</span><br><span class="line">        <span class="built_in">sort</span>(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">atoi</span>(vs[<span class="number">0</span>].<span class="built_in">c_str</span>()) == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : vs) res += v;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="dungeon-game"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/dungeon-game/">174.Dungeon
Game</a></h3>
<p>从左上角开始 DP 的话，无法做到既贪心当前最优，又保证路径最优。</p>
<p>从右下角开始 DP，则可以只考虑路径最优，dp[i][j]表示从(i,
j)位置到终点所需最小health值。</p>
<p>这道题也可以用二分答案来直接从左上角贪心，不过速度会慢很多。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = dungeon.<span class="built_in">size</span>(), cols = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vectordp</span>(rows);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">vector</span>(cols, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = cols - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; rows - <span class="number">1</span> &amp;&amp; j &lt; cols - <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) - dungeon[i][j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; rows - <span class="number">1</span>) dp[i][j] = <span class="built_in">max</span>(<span class="number">1</span>, dp[i + <span class="number">1</span>][j] - dungeon[i][j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; cols - <span class="number">1</span>) dp[i][j] = <span class="built_in">max</span>(<span class="number">1</span>, dp[i][j + <span class="number">1</span>] - dungeon[i][j]);</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(<span class="number">1</span>, -dungeon[i][j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分答案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateMinimumHP</span><span class="params">(vector&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = <span class="number">0x3f3f3f3f</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Test</span>(mid, dungeon)) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> mid, vector tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows = tmp.<span class="built_in">size</span>(), cols = tmp[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j ++) &#123; <span class="keyword">if</span>(i &amp;&amp; j &amp;&amp; tmp[i - <span class="number">1</span>][j] + mid &gt; <span class="number">0</span> &amp;&amp; tmp[i][j - <span class="number">1</span>] + mid &gt; <span class="number">0</span>)</span><br><span class="line">                    tmp[i][j] = <span class="built_in">max</span>(tmp[i - <span class="number">1</span>][j] + tmp[i][j], tmp[i][j - <span class="number">1</span>] + tmp[i][j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &amp;&amp; tmp[i - <span class="number">1</span>][j] + mid &gt; <span class="number">0</span>)</span><br><span class="line">                    tmp[i][j] = tmp[i - <span class="number">1</span>][j] + tmp[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &amp;&amp; tmp[i][j - <span class="number">1</span>] + mid &gt; <span class="number">0</span>)</span><br><span class="line">                    tmp[i][j] = tmp[i][j - <span class="number">1</span>] + tmp[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i || j)</span><br><span class="line">                    tmp[i][j] = -mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[rows - <span class="number">1</span>][cols - <span class="number">1</span>] + mid &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-search-tree-iterator"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-search-tree-iterator/">173.Binary
Search Tree Iterator</a></h3>
<p>变形的非递归中序遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    stack s;</span><br><span class="line">    TreeNode *now;</span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line">        now = root;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(now);</span><br><span class="line">            now = now-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        now = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode *tmp = now;</span><br><span class="line">        now = now-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(now)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(now);</span><br><span class="line">            now = now-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="factorial-trailing-zeroes"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/factorial-trailing-zeroes/">172.Factorial
Trailing Zeroes</a></h3>
<p>阶乘的每个数中，每个因子 2 和每个因子 5 可以构成一个0，而 2 远比 5
多，比如 8 就有三个 2，于是统计因子 5 的个数。</p>
<p>让输入 n 迭代除以 5，第一次得到 5 的倍数的个数，第二次是 25
倍数的个数，最后得到所有因子 5 的个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">            ret += n /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="excel-sheet-column-number"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-number/">171.Excel
Sheet Column Number</a></h3>
<p>比用Number算Title容易点，在算每一位时候记得加 1 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">titleToNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">            ret = ret * <span class="number">26</span> + c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="majority-element"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/">169.Majority
Element</a></h3>
<p>很有意思的题目，要求的数占超过一半，那么在O(n)时间里把不同的数抵消掉，“多数数”肯定会被留下来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">                x = num, cnt ++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt += num == x ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="excel-sheet-column-title"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-title/">168.Excel
Sheet Column Title</a></h3>
<p>跳过 0 的 26 进制，处理每一位的时候要减 1 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += (n - <span class="number">1</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            n = (n - <span class="number">1</span>) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="fraction-to-recurring-decimal"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/fraction-to-recurring-decimal/">166.Fraction
to Recurring Decimal</a></h3>
<p>有边界数据，所以直接转成long long做，处理正负号。</p>
<p>对小数部分，每次求余数乘 10
再做下一位，当余数重复出现就是循环了。找重复用unordered_map。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        string ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num = numerator, deno = denominator, nm;</span><br><span class="line">        <span class="keyword">if</span>(num * deno &lt; <span class="number">0</span>) ret = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        num = <span class="built_in">abs</span>(num), deno = <span class="built_in">abs</span>(deno);</span><br><span class="line">        ret += <span class="built_in">to_string</span>(num / deno);</span><br><span class="line">        <span class="keyword">if</span>(num % deno == <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        unordered_map mp;</span><br><span class="line">        ret += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> now = num % deno * <span class="number">10</span>; now; )</span><br><span class="line">        &#123;</span><br><span class="line">            mp[now] = ret.<span class="built_in">length</span>();</span><br><span class="line">            ret += <span class="string">&#x27;0&#x27;</span> + now / deno;</span><br><span class="line">            now = now % deno * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(now))</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">insert</span>(mp[now], <span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                ret += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="compare-version-numbers"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/compare-version-numbers/">165.Compare
Version Numbers</a></h3>
<p>按<code>.</code>分开，逐个按数字大小比较。
C++怎么就没个方便的split函数呢。。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">vpos1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">vpos2</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">lp1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">lp2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        version1 += <span class="string">&quot;.&quot;</span>, version2 += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(vpos1 &lt; version<span class="number">1.l</span>ength() || vpos2 &lt; version<span class="number">2.l</span>ength())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">vnum1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">vnum2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            vpos1 = version<span class="number">1.f</span>ind(<span class="string">&quot;.&quot;</span>, lp1);</span><br><span class="line">            vpos2 = version<span class="number">2.f</span>ind(<span class="string">&quot;.&quot;</span>, lp2);</span><br><span class="line">            <span class="keyword">if</span>(vpos1 &lt; version<span class="number">1.l</span>ength())</span><br><span class="line">                vnum1 = <span class="built_in">atoi</span>(version<span class="number">1.</span><span class="built_in">substr</span>(lp1, vpos1 - lp1).<span class="built_in">c_str</span>()), lp1 = vpos1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(vpos2 &lt; version<span class="number">2.l</span>ength()) </span><br><span class="line">                vnum2 = <span class="built_in">atoi</span>(version<span class="number">2.</span><span class="built_in">substr</span>(lp2, vpos2 - lp2).<span class="built_in">c_str</span>()), lp2 = vpos2 + <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span>(vnum1 &gt; vnum2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vnum1 &lt;vnum2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximum-gap"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-gap/">164.Maximum
Gap</a></h3>
<p>很久没碰过桶排序了，这道题有个很有意思的推理——把 n 个数放到 n
个桶里，两种情形，1、每个桶一个数。2、存在有多个数的桶，那也一定有其他的空桶。</p>
<p>这两种情况下，最大gap都是某个桶的最小值与它前面最近的有数的桶的最大值之差，所以避免了桶内排序，O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGap</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> minNum = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> gap = <span class="built_in">ceil</span>((<span class="type">double</span>)(maxNum - minNum) / (nums.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> bcnt = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(gap == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; <span class="built_in">bucket</span>(bcnt, <span class="built_in">make_pair</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">int</span> bsite = (nums[i] - minNum) / gap; </span><br><span class="line">            <span class="keyword">if</span>(bucket[bsite].first == <span class="number">-1</span> || bucket[bsite].first &gt; nums[i])</span><br><span class="line">                bucket[bsite].first = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(bucket[bsite].second == <span class="number">-1</span> || bucket[bsite].second &lt; nums[i])</span><br><span class="line">                bucket[bsite].second = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> last = minNum, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucket.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i].first != <span class="number">-1</span>)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, bucket[i].first - last);</span><br><span class="line">            <span class="keyword">if</span>(bucket[i].second != <span class="number">-1</span>)</span><br><span class="line">                last = bucket[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="find-peak-element"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/find-peak-element/">162.Find Peak
Element</a></h3>
<p><code>O(logn)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="intersection-of-two-linked-lists"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160.Intersection
of Two Linked Lists</a></h3>
<p>先统计两个链表长度，将 长链表 对准 距离末尾 与短链表长度相同
位置，同步遍历返回交叉点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> na, nb;</span><br><span class="line">        ListNode *ha = headA, *hb = headB;</span><br><span class="line">        <span class="keyword">for</span>(na = nb = <span class="number">0</span>; ha || hb;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ha) na ++, ha = ha-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(hb) nb ++, hb = hb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(na &gt; nb) headA = headA-&gt;next, na --;</span><br><span class="line">        <span class="keyword">while</span>(nb &gt; na) headB = headB-&gt;next, nb --;</span><br><span class="line">        <span class="keyword">while</span>(headA != headB) headA = headA-&gt;next, headB = headB-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="min-stack"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/min-stack/">155.Min Stack</a></h3>
<p>一开始做的是每个元素存两个数的数组，一个表示数值，一个表示“上一个最小值下标”。然后觉得这样的话，不是最小值的那些位置，其实浪费了空间。
还是用两个数组或者两个栈，一个存数，一个存最小值好了。
看Discuss里24ms的答案也没什么特别的，运行时间的浮动吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    stack v;</span><br><span class="line">    stack m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">empty</span>() || x &lt;= m.<span class="built_in">top</span>())</span><br><span class="line">            m.<span class="built_in">push</span>(x);</span><br><span class="line">        v.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!m.<span class="built_in">empty</span>() &amp;&amp; m.<span class="built_in">top</span>() == v.<span class="built_in">top</span>())</span><br><span class="line">            m.<span class="built_in">pop</span>();</span><br><span class="line">        v.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="find-minimum-in-rotated-sorted-array-ii"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">154.Find
Minimum in Rotated Sorted Array II</a></h3>
<p>首先如果首尾大量相同元素，那么“先去掉末尾连续相同元素”和“二分的时候nums[mid]==nums[left]时left++”这样的方法，都会退化为O(n)。于是尽可能想二分的方法，有了下面这个分治的方法，然而经不起推敲，其实即便分治，还是会退化成O(n)。贴上两种代码吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &gt;= nums[right])</span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[left]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[left]) left ++;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">findRelMin</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRelMin</span><span class="params">(vector&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right - <span class="number">1</span>) <span class="keyword">return</span> nums[left];</span><br><span class="line">        <span class="type">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] == nums[right - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">findRelMin</span>(nums, left, mid);</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">findRelMin</span>(nums, mid, right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s = left, e = right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[s]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == e ? nums[s] : nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="find-minimum-in-rotated-sorted-array"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153.Find
Minimum in Rotated Sorted Array</a></h3>
<p>二分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>(), mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == nums.<span class="built_in">size</span>() ? nums[<span class="number">0</span>] : nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximum-product-subarray"><a
target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/">152.Maximum
Product Subarray</a></h3>
<p>维护当前位置连续乘积的最大值 tmpp 和最小值 tmpn
，最大值和最小值都可能由三种情况得到：上一个数的
tmpp<em>A[i]，上一个数的 tmpn</em>A[i]，A[i]本身。</p>
<p>不断更新答案，最终输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmpp = A[<span class="number">0</span>], tmpn = A[<span class="number">0</span>], tmp, ans = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmpp;</span><br><span class="line">            tmpp = <span class="built_in">max</span>(<span class="built_in">max</span>(A[i], A[i] * tmpp), A[i] * tmpn);</span><br><span class="line">            tmpn = <span class="built_in">min</span>(<span class="built_in">min</span>(A[i], A[i] * tmp), A[i] * tmpn);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmpp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-words-in-a-string"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/reverse-words-in-a-string/">151.Reverse
Words in a String</a></h3>
<p>先翻转整个字符串，然后从前往后一个单词一个单词地再翻转一次，同时去除多余空格，等于是扫描两遍，O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseWords</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start != s.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(start != s.<span class="built_in">length</span>() &amp;&amp; s[start] == <span class="string">&#x27; &#x27;</span>) start ++;</span><br><span class="line">            <span class="keyword">for</span>(end = start; end != s.<span class="built_in">length</span>() &amp;&amp; s[end] != <span class="string">&#x27; &#x27;</span>; end ++);</span><br><span class="line">            <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; start &lt;= end - <span class="number">1</span>) s[j ++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = end - <span class="number">1</span>; start &lt; i; start ++, i --)</span><br><span class="line">                <span class="built_in">swap</span>(s[i], s[start]), s[j ++] = s[start];</span><br><span class="line">            <span class="keyword">while</span>(start &lt; end) s[j ++] = s[start ++];</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="evaluate-reverse-polish-notation"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/">150.Evaluate
Reverse Polish Notation</a></h3>
<p>逆波兰表达式计算四则运算。用栈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector &amp;tokens)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        stack s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i ++) &#123; <span class="keyword">if</span>(<span class="built_in">isdigit</span>(tokens[i][<span class="number">0</span>]) || tokens[i].<span class="built_in">length</span>() &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">atoi</span>(tokens[i].<span class="built_in">c_str</span>()));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a = s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">            b = s.<span class="built_in">top</span>();s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span>(tokens[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: s.<span class="built_in">push</span>(b + a); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: s.<span class="built_in">push</span>(b - a); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: s.<span class="built_in">push</span>(b * a); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: s.<span class="built_in">push</span>(b / a); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="max-points-on-a-line"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/max-points-on-a-line/">149.Max
Points on a Line</a></h3>
<p>平面上一条直线最多穿过多少点。乍一看好熟悉的问题，做了这么久计算几何。。。却还真没做过这个小问题。</p>
<p>第一反应当然不能O(n^3)枚举了，枚举圆周好像也不行，毕竟是考察所有点，不是某个点。那么应该就是哈希斜率了吧。</p>
<p>肯定少不了竖直的线，哈希斜率这不像是这类OJ让写的题吧。。忘了map这回事了。</p>
<p>确定思路之后，还是看看别人博客吧，少走点弯路，然后就学习了还有unordered_map这么个东西，<a
target="_blank" rel="noopener" href="http://blog.csdn.net/tontkeng/article/details/17244361">还有一个博客</a>
的思路挺好，避免double问题，把斜率转化成化简的x、y组成字符串。</p>
<p>再另外就是重叠的点了，想让题目坑一点，怎能少得了这种数据，单独处理一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a point.</span></span><br><span class="line"><span class="comment"> * struct Point &#123;</span></span><br><span class="line"><span class="comment"> *     int x;</span></span><br><span class="line"><span class="comment"> *     int y;</span></span><br><span class="line"><span class="comment"> *     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector &amp;points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">            <span class="type">int</span> tmpans = <span class="number">0</span>, same = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = points[j].x - points[i].x, y = points[j].y - points[i].y;</span><br><span class="line">                <span class="type">int</span> g = <span class="built_in">gcd</span>(x, y);</span><br><span class="line">                <span class="keyword">if</span>(g != <span class="number">0</span>) x /= g, y /= g;</span><br><span class="line">                <span class="keyword">else</span> &#123;same ++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span>) x = -x, y = -y;</span><br><span class="line">                string tmp = <span class="built_in">to_string</span>(x) + <span class="string">&quot; &quot;</span> + <span class="built_in">to_string</span>(y);</span><br><span class="line">                <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(tmp)) mp[tmp] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> mp[tmp] ++;</span><br><span class="line">                tmpans = <span class="built_in">max</span>(tmpans, mp[tmp]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(tmpans + <span class="number">1</span> + same, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a ? <span class="built_in">gcd</span>(b % a, a) : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sort-list"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/sort-list/">148.Sort List</a></h3>
<p>又长见识了，原来链表也可以O(nlogn)排序的。没往下想就查了一下，看到人说用归并，于是才开始想能不能实现。。。</p>
<p>O(n)找到中点，把中点的next变成NULL，对两部分递归。递归结束后对两部分归并，先找到newhead，即两部分的头部val较小的那个，然后归并就把小的从newhead往后续。</p>
<p>把最后的next赋值NULL，返回newhead。</p>
<p>又有空数据@_@.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">            n ++, p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> head; n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(-- n)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        ListNode *tmp = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *nl = <span class="built_in">sortList</span>(head);</span><br><span class="line">        ListNode *nr = <span class="built_in">sortList</span>(tmp);</span><br><span class="line">        ListNode *newhead;</span><br><span class="line">        <span class="keyword">if</span>(nl-&gt;val &lt; nr-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            newhead = nl;</span><br><span class="line">            nl = nl-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newhead = nr;</span><br><span class="line">            nr = nr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = newhead;</span><br><span class="line">        <span class="keyword">while</span>(nl != <span class="literal">NULL</span> &amp;&amp; nr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nl-&gt;val &lt; nr-&gt;val) p-&gt;next = nl, p = p-&gt;next, nl = nl-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = nr, p = p-&gt;next, nr = nr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nl != <span class="literal">NULL</span>) p-&gt;next = nl, p = p-&gt;next, nl = nl-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(nr != <span class="literal">NULL</span>) p-&gt;next = nr, p = p-&gt;next, nr = nr-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="insertion-sort-list"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/insertion-sort-list/">147.Insertion
Sort List</a></h3>
<p>指针操作很烦啊。。暴力枚举插入位置，注意细节就能过了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">insertionSortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *newhead = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        newhead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; newhead-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *tmp = head-&gt;next;</span><br><span class="line">                head-&gt;next = newhead;</span><br><span class="line">                newhead = head;</span><br><span class="line">                head = tmp;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode *pre = newhead, *p = newhead-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;val &lt; head-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="lru-cache"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/lru-cache/">146.LRU Cache</a></h3>
<p>新建数据类class Val，保存key、val和访问自增标记updatecnt。</p>
<p>用unordered_map更新数据，增加updatecnt，并把更新的数据放入队列，最关键是处理capacity满了的时候，队列依次出队，map中不存在的和updatecnt和最新数据不相等的项目都忽略，直到发现updatecnt和map中存的最新状态相等，则为(最近未使用)数据，出队后在map中erase。思路有点像STL队列实现版本的Dijkstra。</p>
<p><a
target="_blank" rel="noopener" href="http://blog.csdn.net/doc_sgl/article/details/15378513">有一个博客</a>
的方法更好，map中存的是链表的节点指针，链表顺序表示访问情况，这样就把map内容和链表的每个节点一一对应了，没有冗余节点，且更新操作也是O(1)的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Val</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> updatecnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Val&gt; mp;</span><br><span class="line">    queue q;</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            mp[key].updatecnt ++;</span><br><span class="line">            q.<span class="built_in">push</span>(mp[key]);</span><br><span class="line">            <span class="keyword">return</span> mp[key].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            mp[key].val = value;</span><br><span class="line">            mp[key].updatecnt ++;</span><br><span class="line">            q.<span class="built_in">push</span>(mp[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">size</span>() == cap)</span><br><span class="line">            &#123;</span><br><span class="line">                Val tmp;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(tmp.key) &amp;&amp; tmp.updatecnt == mp[tmp.key].updatecnt)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mp.<span class="built_in">erase</span>(mp.<span class="built_in">find</span>(tmp.key));</span><br><span class="line">                mp[key].key = key;</span><br><span class="line">                mp[key].val = value;</span><br><span class="line">                mp[key].updatecnt = <span class="number">0</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(mp[key]);</span><br><span class="line">            &#125;</span><br><span class="line">            mp[key].key = key;</span><br><span class="line">            mp[key].val = value;</span><br><span class="line">            mp[key].updatecnt = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(mp[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-postorder-traversal"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/binary-tree-postorder-traversal/">145.Binary
Tree Postorder Traversal</a></h3>
<p>二叉树的非递归后序遍历，考研的时候非常熟悉了，现在写又要想好久。重点是关于右子树遍历时候需要一个标记，或者标记根节点出栈次数，或者标记右子树是否访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *visited;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(root), root = root-&gt;left;</span><br><span class="line">            root = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span> || visited == root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                visited = root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-preorder-traversal"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/binary-tree-preorder-traversal/">144.Binary
Tree Preorder Traversal</a></h3>
<p>前序遍历的非递归就容易多了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            root = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>) s.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>) s.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reorder-list"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/reorder-list/">143.Reorder
List</a></h3>
<p>找到中间位置，把中间之后的链表反转，两个指针一个从头一个从尾开始互插，奇偶和指针绕得有点晕，理清就好了。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode *pre, *p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">            n ++, p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>) <span class="keyword">return</span>; n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        pre = p = head;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(n --) p = p-&gt;next, pre = pre-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *tail = pre;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp1 = p-&gt;next, *tmp2 = tail-&gt;next;</span><br><span class="line">            p-&gt;next = tail;</span><br><span class="line">            tail-&gt;next = tmp1;</span><br><span class="line">            p = tmp1;</span><br><span class="line">            <span class="keyword">if</span>(p == tail || p == tmp2) <span class="keyword">break</span>;</span><br><span class="line">            tail = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="linked-list-cycle-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/linked-list-cycle-ii/">142.Linked
List Cycle II</a></h3>
<p>设置两个指针<code>slow</code>和<code>fast</code>，从<code>head</code>开始，<code>slow</code>一次一步，<code>fast</code>一次两步，如果<code>fast</code>能再次追上<code>slow</code>则有圈。
设<code>slow</code>走了<code>n</code>步，则<code>fast</code>走了<code>2*n</code>步，设圈长度m，圈起点到<code>head</code>距离为<code>k</code>，相遇位置距离圈起点为<code>t</code>，则有：</p>
<p><code>n = k + t + pm;</code> (1)</p>
<p><code>2*n = k + t + qm;</code>(2)</p>
<p>这里p和q是任意整数。（不过fast速度是slow二倍，则肯定在一圈内追上，p就是0了）</p>
<p><code>2 * (1) - (2)</code>
得<code>k = lm - t;(l = q - 2 * p)</code></p>
<p>即 <code>k</code> 的长度是若干圈少了 <code>t</code> 的长度。
因此这时候，一个指针从<code>head</code>开始，另一个从相遇位置开始，都每次只走一步，当从<code>head</code>开始的指针走到圈开始位置时，两指针刚好相遇。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *slow, *fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            <span class="keyword">if</span>(slow == <span class="literal">NULL</span> || fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)</span><br><span class="line">            slow = slow-&gt;next, fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="linked-list-cycle"><a
target="_blank" rel="noopener" href="http://www.cnblogs.com/CSGrandeur/admin/Linked%20List%20Cycle%20">141.Linked
List Cycle</a></h3>
<p>呃，时间逆序做的结果。。。成买一送一了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *slow, *fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            <span class="keyword">if</span>(slow == <span class="literal">NULL</span> || fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-break-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/word-break-ii/">140.Word Break
II</a></h3>
<p>先递推，<code>dp[i] == true</code> 表示 <code>s</code> 中前
<code>i</code> 个字符的串是符合要求的，枚举位置 <code>i</code> ，对于
<code>i</code> 枚举位置 <code>j &lt; i</code>，如果
<code>dp[j] == true</code>且
<code>j ~ i</code>的串在字典中，则<code>dp[i] = true</code>。</p>
<p>同时对于这样的 <code>j</code>,
<code>i</code>，<code>site[i].push_back(j)</code>，即在 <code>i</code>
位置的可行迭代表中增加位置 <code>j</code>。</p>
<p>完成site之后，从尾部倒着DFS过去就得到了所有串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">DFS</span><span class="params">(<span class="type">const</span> string &amp;s, vector *site, <span class="type">int</span> ith)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; site[ith].<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector tmp;</span><br><span class="line">            string str = s.<span class="built_in">substr</span>(site[ith][i], ith - site[ith][i]);</span><br><span class="line">            <span class="keyword">if</span>(site[site[ith][i]].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp = <span class="built_in">DFS</span>(s, site, site[ith][i]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; tmp.<span class="built_in">size</span>(); j ++)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(tmp[j] + <span class="string">&quot; &quot;</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">wordBreak</span><span class="params">(string s, unordered_set &amp;dict)</span> </span>&#123;</span><br><span class="line">        vector *site = <span class="keyword">new</span> vector[s.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="type">bool</span> *dp = <span class="keyword">new</span> <span class="type">bool</span>[s.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">bool</span>) * s.<span class="built_in">length</span>());</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] == <span class="literal">true</span> &amp;&amp; dict.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i - j)))</span><br><span class="line">                   site[i].<span class="built_in">push_back</span>(j), dp[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFS</span>(s, site, s.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-break"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/word-break/">139.Word
Break</a></h3>
<p>参考Word Break II，对于dp标记，当dp[i]为true时候可以停止枚举后面的
j，优化一下常数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, unordered_set &amp;dict)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> *dp = <span class="keyword">new</span> <span class="type">bool</span>[s.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">bool</span>) * (s.<span class="built_in">length</span>() + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[j] &amp;&amp; dict.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i - j));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">length</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="copy-list-with-random-pointer"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/copy-list-with-random-pointer/">138.Copy
List with Random Pointer</a></h3>
<p>第一次遍历，把每个节点复制一份放到对应节点的下一个，即组成二倍长的链表：<code>ori1-&gt;copy1-&gt;ori2-&gt;copy2-&gt;...</code></p>
<p>第二次遍历，利用<code>复制节点总是对应节点的下一个节点</code>特性，将每个<code>ori-&gt;next-&gt;random</code>指向<code>ori-&gt;random-&gt;next</code>，中间判断一下空指针。</p>
<p>第三次遍历，把两个链表拆开，恢复原链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        RandomListNode *p = head, *newhead = <span class="literal">NULL</span>, *tmp;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(p-&gt;label);</span><br><span class="line">            tmp-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = tmp;</span><br><span class="line">            p = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newhead = head-&gt;next;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            tmp-&gt;random = p-&gt;random == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : p-&gt;random-&gt;next;</span><br><span class="line">            p = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = tmp-&gt;next;</span><br><span class="line">            p = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = p == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="single-number-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/single-number-ii/">137.Single
Number II</a></h3>
<p>方法一：设置cnt[32]记录
32个比特位的1的个数，出现3次的数的对应位的1总数为3的倍数，则统计之后每个位对3取模，剩下的位为1的则对应个数为1的那个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = A[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">33</span>; tmp &gt;&gt;= <span class="number">1</span>, j ++)</span><br><span class="line">                cnt[j] += tmp &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i ++)</span><br><span class="line">            ans |= (cnt[i] % <span class="number">3</span>) &lt;&lt; i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：设置int one,
two模拟两位二进制来统计各比特位1次数，每当one和two对应二进制位都为1的时候把one和two都清零，最后剩下的one就是要求的数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>, two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            two |= one &amp; A[i];</span><br><span class="line">            one ^= A[i];</span><br><span class="line">            <span class="type">int</span> tmp = one &amp; two;</span><br><span class="line">            two ^= tmp;</span><br><span class="line">            one ^= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="single-number"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/single-number/">136.Single
Number</a></h3>
<p>一路异或过去就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            tmp ^= A[i];</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="candy"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/candy/">135.Candy</a></h3>
<p>时间复杂度
<code>O(n)</code>的方法还是容易想了，优化为空间复杂度<code>O(1)</code>的话也不难，只是思考代码的时候会有点绕。</p>
<p>上坡一步步来，下坡走个等差数列，波峰位置比较一下上坡时候记录的最大值和下坡求的的最大值，取较大的，具体看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector &amp;ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, i, j, start, nownum;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ratings.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || ratings[i] == ratings[i - <span class="number">1</span>]) </span><br><span class="line">                nownum = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])</span><br><span class="line">                nownum ++;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; ratings.<span class="built_in">size</span>() &amp;&amp; ratings[i + <span class="number">1</span>] &lt; ratings[i])</span><br><span class="line">            &#123;</span><br><span class="line">                start = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; ratings.<span class="built_in">size</span>() &amp;&amp; ratings[j] &lt; ratings[j - <span class="number">1</span>]; start++, j ++); </span><br><span class="line">                <span class="keyword">if</span>(start &gt; nownum)</span><br><span class="line">                    cnt += (start + <span class="number">1</span>) * start &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt += ((start - <span class="number">1</span>) * start &gt;&gt; <span class="number">1</span>) + nownum;</span><br><span class="line">                nownum = <span class="number">1</span>;</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt += nownum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="gas-station"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/gas-station/">134.Gas
Station</a></h3>
<p>证明题。</p>
<p>一、如果从 i 到 j 的时候理论计算气量刚好为负数，则 i ~ j
的加气站都不可以作为起点。</p>
<p>反证一下，从前往后去掉站，如果去掉的站能增加气，即正数，则结果更糟。如果去掉的站是负数，那么负数如果抵消了之前的正数，则在到
j 之前已经负数了，如果不能抵消之前的正数，那么结果还是更糟。</p>
<p>二、判断是否能成行，一个环的和为非负就可以。</p>
<p>假设环为正， 0 ~ j 刚好为负， j + 1 ~ k 刚好为负数，k + 1
之后为正，则 k + 1 为答案。</p>
<p>也反证一下，k + 1 出发，到gas.size() - 1都为正，则转回来到 j - 1
都会为正。如果到 j 时候为负，则整个环不可能为正，所以到 j
的时候也为正，剩下的一样。这样就能够成功转一圈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector &amp;gas, vector &amp;cost)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> i, ans, sum, all;</span><br><span class="line">       <span class="keyword">for</span>(i = ans = sum = all = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i ++)</span><br><span class="line">       &#123;</span><br><span class="line">           sum += gas[i] - cost[i];</span><br><span class="line">           all += gas[i] - cost[i];</span><br><span class="line">           <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123; sum = <span class="number">0</span>; ans = i + <span class="number">1</span>; &#125; &#125; <span class="keyword">return</span> all &gt;= <span class="number">0</span> ? ans : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="clone-graph"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/clone-graph/">133.Clone
Graph</a></h3>
<p>label是唯一的，递归，用unordered_map标记。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, UndirectedGraphNode *&gt; mp;</span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span> || mp.<span class="built_in">count</span>(node-&gt;label)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        UndirectedGraphNode *tmp = <span class="keyword">new</span> <span class="built_in">UndirectedGraphNode</span>(node-&gt;label);</span><br><span class="line">        mp[node-&gt;label] = tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cloneGraph</span>(node-&gt;neighbors[i]);</span><br><span class="line">            tmp-&gt;neighbors.<span class="built_in">push_back</span>(mp[node-&gt;neighbors[i]-&gt;label]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="palindrome-partitioning-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/palindrome-partitioning-ii/">132.Palindrome
Partitioning II</a></h3>
<p>O(n^2)的动态规划。</p>
<p><code>cutdp[i]</code> 表示前 <code>i</code> 个字符最小切割几次。</p>
<p><code>paldp[i][j] == true</code> 表示 <code>i ~ j</code> 是回文。</p>
<p>在枚举 i 和 i 之前的所有 j 的过程中就得到了 paldp[j][i]
的所有回文判断，而对于 i + 1，paldp[j][i + 1]可由 s[j]、s[i + 1]、dp[j +
1][i]在O(1)判断。</p>
<p>cutdp[i]为所有 j (j &lt; i)，当paldp[j + 1][i] true的 cutdp[j] +
1的最小值。注意一下边界。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> paldp[s.<span class="built_in">length</span>()][s.<span class="built_in">length</span>()];</span><br><span class="line">        <span class="type">int</span> cutdp[s.<span class="built_in">length</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123; cutdp[i] = <span class="number">0x3f3f3f3f</span>; <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">-1</span>; j --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">at</span>(j + <span class="number">1</span>) == s.<span class="built_in">at</span>(i) &amp;&amp; (j + <span class="number">2</span> &gt;= i - <span class="number">1</span> || paldp[j + <span class="number">2</span>][i - <span class="number">1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    paldp[j + <span class="number">1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                    cutdp[i] = <span class="built_in">min</span>(cutdp[i], (j &gt;= <span class="number">0</span> ? (cutdp[j] + <span class="number">1</span>) : <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    paldp[j + <span class="number">1</span>][i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cutdp[s.<span class="built_in">length</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="palindrome-partitioning"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/palindrome-partitioning/">131.Palindrome
Partitioning</a></h3>
<p>O(n^2)动态规划，<code>paldp[i][j] == true</code>表示
<code>i ~ j</code> 是回文。这里DP的方法是基本的，不再多说。</p>
<p>得到paldp之后，DFS一下就可以了。因为单字符是回文，所以DFS的终点肯定都是解，所以不必利用其他的结构存储答案信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vectorres;</span><br><span class="line">    vector tmp;</span><br><span class="line">    <span class="type">bool</span> **paldp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(string s, <span class="type">int</span> ith)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ith == s.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = ith; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(paldp[ith][i])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(ith, i - ith + <span class="number">1</span>));</span><br><span class="line">                <span class="built_in">DFS</span>(s, i + <span class="number">1</span>);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">partition</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        paldp = <span class="keyword">new</span> <span class="type">bool</span>*[s.<span class="built_in">length</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            paldp[i] = <span class="keyword">new</span> <span class="type">bool</span>[s.<span class="built_in">length</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">                paldp[j][i] = s.<span class="built_in">at</span>(i) == s.<span class="built_in">at</span>(j) &amp;&amp; (j + <span class="number">1</span> &gt;= i - <span class="number">1</span> || paldp[j + <span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">DFS</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="surrounded-regions"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/surrounded-regions/">130.Surrounded
Regions</a></h3>
<p>周围四条边的O做起点搜索替换为第三种符号，再遍历所有符号把O换成X，第三种符号换回O。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    queue q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> width = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> height = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; width; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[<span class="number">0</span>][i] = <span class="string">&#x27;#&#x27;</span>, q.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">if</span>(board[height - <span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[height - <span class="number">1</span>][i] = <span class="string">&#x27;#&#x27;</span>, q.<span class="built_in">push</span>(<span class="built_in">pii</span>(height - <span class="number">1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; height - <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[i][<span class="number">0</span>] = <span class="string">&#x27;#&#x27;</span>, q.<span class="built_in">push</span>(<span class="built_in">pii</span>(i, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(board[i][width - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                board[i][width - <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>, q.<span class="built_in">push</span>(<span class="built_in">pii</span>(i, width - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pii now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) </span><br><span class="line">            &#123; </span><br><span class="line">               <span class="type">int</span> ty = now.first + dx[i]; </span><br><span class="line">               <span class="type">int</span> tx = now.second + dy[i]; </span><br><span class="line">               <span class="keyword">if</span>(tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; width &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; height &amp;&amp; board[ty][tx] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   board[ty][tx] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                   q.<span class="built_in">push</span>(<span class="built_in">pii</span>(ty, tx));</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sum-root-to-leaf-numbers"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/sum-root-to-leaf-numbers/">129.Sum
Root to Leaf Numbers</a></h3>
<p>遍历一遍加起来。。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(TreeNode *now, <span class="type">int</span> tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left == <span class="literal">NULL</span> &amp;&amp; now-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += tmp * <span class="number">10</span> + now-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(now-&gt;left, tmp * <span class="number">10</span> + now-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(now-&gt;right, tmp * <span class="number">10</span> + now-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-consecutive-sequence"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/longest-consecutive-sequence/">128.Longest
Consecutive Sequence</a></h3>
<p>方法一：一开始竟然想了并查集，其实绕弯了，多此一举。哈希+并查集，把每个数哈希，枚举每个数看相邻的数在不在数组里，并查集合并，只是并查集的复杂度要比O(1)大一些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp, cnt;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fa</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i == mp[i] ? i : (mp[i] = <span class="built_in">fa</span>(mp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            mp[num[i]] = num[i], cnt[num[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(num[i] + <span class="number">1</span>) &amp;&amp; <span class="built_in">fa</span>(num[i]) != <span class="built_in">fa</span>(num[i] + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[<span class="built_in">fa</span>(num[i] + <span class="number">1</span>)] += cnt[<span class="built_in">fa</span>(num[i])];</span><br><span class="line">                ans = <span class="built_in">max</span>(cnt[<span class="built_in">fa</span>(num[i] + <span class="number">1</span>)], ans);</span><br><span class="line">                mp[<span class="built_in">fa</span>(num[i])] = <span class="built_in">fa</span>(num[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：哈希+枚举相邻数。相邻的数在数组里的话，每个数至多访问一次；相邻的数不在数组里的话，枚举会中断。所以设哈希复杂度为O(1)的话，这个方法是严格的O(n)。</p>
<p>其实这个题的数据挺善良，如果出了<code>2147483647</code>,
<code>-2147483648</code>，那还是用long long 稳妥些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            vis[num[i]] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[num[i]] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = num[i]; vis.<span class="built_in">count</span>(j); j ++, cnt ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = num[i] - <span class="number">1</span>; vis.<span class="built_in">count</span>(j); j --, cnt ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-ladder-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/word-ladder-ii/">127.Word Ladder
II</a></h3>
<p>用数组类型的队列，BFS过程中记录pre路径，搜完后迭代回去保存路径。</p>
<p>似乎卡了常数，用queue队列，另外存路径的方法超时了。</p>
<p>想更快就双向广搜吧。让我想起了POJ那个八数码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">int</span> pace;</span><br><span class="line">    <span class="type">int</span> pre;</span><br><span class="line">    <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(string s, <span class="type">int</span> pa, <span class="type">int</span> pr)</span><br><span class="line">    &#123;</span><br><span class="line">        str = s;</span><br><span class="line">        pace = pa;</span><br><span class="line">        pre = pr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">findLadders</span><span class="params">(string start, string end, unordered_set &amp;dict)</span> </span>&#123;</span><br><span class="line">        vector q;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(end, <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; dis;</span><br><span class="line">        dis[end] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">            Node now = q[i]; </span><br><span class="line">            <span class="keyword">if</span>(dis.<span class="built_in">count</span>(start) &amp;&amp; now.pace &gt;= dis[start])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; now.str.<span class="built_in">length</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                string tmp = now.str;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c ++) </span><br><span class="line">                &#123; </span><br><span class="line">                   tmp[j] = c; </span><br><span class="line">                   <span class="keyword">if</span>((dict.<span class="built_in">count</span>(tmp) || tmp == start) &amp;&amp; (!dis.<span class="built_in">count</span>(tmp) || dis[tmp] == now.pace + <span class="number">1</span>)) </span><br><span class="line">                   &#123; </span><br><span class="line">                       dis[tmp] = now.pace + <span class="number">1</span>; </span><br><span class="line">                       q.<span class="built_in">push_back</span>(<span class="built_in">Node</span>(tmp, now.pace + <span class="number">1</span>, i)); </span><br><span class="line">                   &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; q[i].pace == dis[start]; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].str == start)</span><br><span class="line">            &#123;</span><br><span class="line">                vector tmp;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i; j != <span class="number">-1</span>; j = q[j].pre)</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(q[j].str);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-ladder"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/word-ladder/">126.Word
Ladder</a></h3>
<p>直接BFS。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(string start, string end, unordered_set &amp;dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;string, <span class="type">int</span>&gt; pii;</span><br><span class="line">        unordered_set flag;</span><br><span class="line">        queue q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">pii</span>(start, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pii now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; now.first.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                string tmp = now.first;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> j = <span class="string">&#x27;a&#x27;</span>; j &lt;= <span class="string">&#x27;z&#x27;</span>; j ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp[i] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tmp == end) <span class="keyword">return</span> now.second + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dict.<span class="built_in">count</span>(tmp) &amp;&amp; !flag.<span class="built_in">count</span>(tmp))</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">pii</span>(tmp, now.second + <span class="number">1</span>));</span><br><span class="line">                        flag.<span class="built_in">insert</span>(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="valid-palindrome"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/valid-palindrome/">125.Valid
Palindrome</a></h3>
<p>做过刘汝佳 白书的人想必都知道ctype.h和isdigit(), isalpha(),
tolower(), toupper()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(<span class="type">char</span> &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="built_in">tolower</span>(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isdigit</span>(x) || <span class="built_in">isalpha</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &lt; j; i ++, j --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">valid</span>(s[i]) &amp;&amp; i &lt; s.<span class="built_in">length</span>()) i ++; <span class="keyword">while</span>(!<span class="built_in">valid</span>(s[j]) &amp;&amp; j &gt;= <span class="number">0</span>) j --;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j &amp;&amp; s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-maximum-path-sum"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/binary-tree-maximum-path-sum/">124.Binary
Tree Maximum Path Sum</a></h3>
<p>后续遍历，子问题为子树根节点向叶子节点出发的最大路径和。</p>
<p>即 l = DFS(now-&gt;left), r = DFS(now-&gt;right)。</p>
<p>此时，ans可能是
now-&gt;valid,可能是左边一路上来加上now-&gt;valid，可能是右边一路上来，也可能是左边上来经过now再右边一路下去，四种情况。</p>
<p>四种情况更新完ans后，now返回上一层只能是
now-&gt;valid或左边一路上来或右边一路上来，三种情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">max</span>(<span class="built_in">DFS</span>(now-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">max</span>(<span class="built_in">DFS</span>(now-&gt;right), <span class="number">0</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, l + r + now-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l + now-&gt;val, r + now-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="best-time-to-buy-and-sell-stock-iii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">123.Best
Time to Buy and Sell Stock III</a></h3>
<p>前缀pre[i]处理 0 ~ i 买卖一次最优解，后缀suf[i]处理 i ~ prices.size()
- 1 买卖一次最优解。</p>
<p>所有位置pre[i] + suf[i]最大值为答案O(n)。</p>
<p>处理最优解的时候是维护前（后）缀prices最小（大）值，与当前prices做差后和前（后）缀最优解比较取最优，O(n)。</p>
<p>总复杂度O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">pre</span><span class="params">(prices.size())</span>, <span class="title">suf</span><span class="params">(prices.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, mtmp = <span class="number">0x3f3f3f3f</span>; i &lt; prices.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">           mtmp = i ? <span class="built_in">min</span>(mtmp, prices[i]) : prices[i]; </span><br><span class="line">           pre[i] = <span class="built_in">max</span>(prices[i] - mtmp, i ? pre[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = prices.<span class="built_in">size</span>() - <span class="number">1</span>, mtmp = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            mtmp = i != prices.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="built_in">max</span>(mtmp, prices[i]) : prices[i];</span><br><span class="line">            suf[i] = <span class="built_in">max</span>(mtmp - prices[i], i != prices.<span class="built_in">size</span>() - <span class="number">1</span> ? suf[i + <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pre[i] + suf[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="best-time-to-buy-and-sell-stock-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122.Best
Time to Buy and Sell Stock II</a></h3>
<p>可以买卖多次，把所有上坡差累加即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i ++) &#123; <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                ans += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="best-time-to-buy-and-sell-stock"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/">121.Best
Time to Buy and Sell Stock</a></h3>
<p>维护前（后）缀最小（大）值，和当前prices做差更新答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = prices.<span class="built_in">size</span>() - <span class="number">1</span>, mtmp = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            mtmp = <span class="built_in">max</span>(mtmp, prices[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(mtmp - prices[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="triangle"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/triangle/">120.Triangle</a></h3>
<p>竟然遇到了ACM递推入门题，想必无数ACMer对这题太熟悉了。</p>
<p>从下往上递推，一维数组滚动更新即可。这里懒省事，直接把原数组改了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector &amp;triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = triangle.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; triangle[i].<span class="built_in">size</span>(); j ++)</span><br><span class="line">                triangle[i][j] = <span class="built_in">min</span>(triangle[i][j] + triangle[i + <span class="number">1</span>][j], triangle[i][j] + triangle[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle.<span class="built_in">size</span>() == <span class="number">0</span> ? <span class="number">0</span> : triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="pascals-triangle-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/pascals-triangle-ii/">119.Pascal's
Triangle II</a></h3>
<p>滚动数组递推，从后往前以便不破坏上一层递推数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">ans</span><span class="params">(rowIndex + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i ++) &#123; <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[j] = (i == <span class="number">0</span> || j == <span class="number">0</span> || j == i ? <span class="number">1</span> : ans[j] + ans[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="pascals-triangle"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/pascals-triangle/">118.Pascal's
Triangle</a></h3>
<p>递推。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">generate</span><span class="params">(<span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        vector v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numRows; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(i == <span class="number">0</span> || j == <span class="number">0</span> || j == i ? <span class="number">1</span> : v[i - <span class="number">1</span>][j] + v[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            v.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="populating-next-right-pointers-in-each-node-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">117.Populating
Next Right Pointers in Each Node II</a></h3>
<p>题目要求空间复杂度O(1)，所以递归、队列等传统方法不应该用。</p>
<p>本题可以利用生成的next指针来横向扫描，即得到一层的next指针之后，可以利用这一层的next指针来给下一层的next指针赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode *<span class="title">findNext</span><span class="params">(TreeLinkNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span> &amp;&amp; head-&gt;left == <span class="literal">NULL</span> &amp;&amp; head-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode *head, *last, *nexhead;</span><br><span class="line">        <span class="keyword">for</span>(head = root; head != <span class="literal">NULL</span>; head = nexhead)</span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="built_in">findNext</span>(head);</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;left != <span class="literal">NULL</span>) nexhead = head-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> nexhead = head-&gt;right;</span><br><span class="line">            <span class="keyword">for</span>(last = <span class="literal">NULL</span>; head != <span class="literal">NULL</span>; last = head, head = <span class="built_in">findNext</span>(head-&gt;next))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;left != <span class="literal">NULL</span> &amp;&amp; head-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(last == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(last-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">                    last-&gt;right-&gt;next = head-&gt;left != <span class="literal">NULL</span> ? head-&gt;left : head-&gt;right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                    last-&gt;left-&gt;next = head-&gt;left != <span class="literal">NULL</span> ? head-&gt;left : head-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="populating-next-right-pointers-in-each-node"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node/">116.Populating
Next Right Pointers in Each Node</a></h3>
<p>不用考虑连续的空指针，就不用额外实现找下一个子树非空节点，比Populating
Next Right Pointers in Each Node II 容易处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode *head, *nexhead, *last;</span><br><span class="line">        <span class="keyword">for</span>(head = root; head-&gt;left != <span class="literal">NULL</span>; head = nexhead)</span><br><span class="line">        &#123;</span><br><span class="line">            nexhead = head-&gt;left;</span><br><span class="line">            last = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(last != <span class="literal">NULL</span>) last-&gt;right-&gt;next = head-&gt;left;</span><br><span class="line">                last = head;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="distinct-subsequences"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/distinct-subsequences/">115.Distinct
Subsequences</a></h3>
<p>典型动态规划。dp[i][j] 表示 T 的前 j 个字符在 S 的前 i
个字符中的解。</p>
<p>对于dp[i + 1][j + 1]，由两部分组成：</p>
<p>一、 j + 1 对应到 S 前 i 个字符中的解，忽略 S 的第 i + 1 个字符。</p>
<p>二、判断 S 的第 i + 1 个字符是否和 T 的第 j + 1
个字符相同，如果相同，则加上dp[i][j]，否则不加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.<span class="built_in">length</span>() &lt; T.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">dp</span><span class="params">(S.length() + <span class="number">1</span>, vector(T.length() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; T.<span class="built_in">length</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(S[i] == T[j]) dp[i + <span class="number">1</span>][j + <span class="number">1</span>] += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[S.<span class="built_in">length</span>()][T.<span class="built_in">length</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="flatten-binary-tree-to-linked-list"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">114.Flatten
Binary Tree to Linked List</a></h3>
<p>题意是优先左子树靠前，且排成一列用右子树指针，不管val的大小关系。</p>
<p>后序遍历一遍即可，递归返回子树中尾节点指针，注意各种条件判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">DFS</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left == <span class="literal">NULL</span> &amp;&amp; now-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> now;</span><br><span class="line">        TreeNode *leftok = <span class="literal">NULL</span>, *rightok = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>) leftok = <span class="built_in">DFS</span>(now-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>) rightok = <span class="built_in">DFS</span>(now-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftok != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            leftok-&gt;right = now-&gt;right;</span><br><span class="line">            now-&gt;right = now-&gt;left;</span><br><span class="line">            now-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> rightok ? rightok : leftok;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> rightok;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="path-sum-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/path-sum-ii/">113.Path Sum
II</a></h3>
<p>传统递归，把路径上的数字插入vector，终点判断是否插入答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> goal;</span><br><span class="line">    vectorv;</span><br><span class="line">    vector curv;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(TreeNode *now, <span class="type">int</span> cursum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        curv.<span class="built_in">push_back</span>(now-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left == <span class="literal">NULL</span> &amp;&amp; now-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cursum + now-&gt;val == goal)</span><br><span class="line">            &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(curv);</span><br><span class="line">                curv.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>) <span class="built_in">DFS</span>(now-&gt;left, cursum + now-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>) <span class="built_in">DFS</span>(now-&gt;right, cursum + now-&gt;val);</span><br><span class="line">        curv.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">pathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        goal = sum;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="built_in">DFS</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="path-sum"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/path-sum/">112.Path Sum</a></h3>
<p>遍历树。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> goal;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode *now, <span class="type">int</span> cursum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left == <span class="literal">NULL</span> &amp;&amp; now-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> cursum + now-&gt;val == goal;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">DFS</span>(now-&gt;left, cursum + now-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">DFS</span>(now-&gt;right, cursum + now-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        goal = sum;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFS</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="minimum-depth-of-binary-tree"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/minimum-depth-of-binary-tree/">111.Minimum
Depth of Binary Tree</a></h3>
<p>还是遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="balanced-binary-tree"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/balanced-binary-tree/">110.Balanced
Binary Tree</a></h3>
<p>遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">maxDepth</span>(now-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">maxDepth</span>(now-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(l - r) &gt; <span class="number">1</span> || l &lt; <span class="number">0</span> || r &lt; <span class="number">0</span> ? <span class="number">-2</span> : <span class="built_in">max</span>(l, r); &#125; <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">maxDepth</span>(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="convert-sorted-list-to-binary-search-tree"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">109.Convert
Sorted List to Binary Search Tree</a></h3>
<p>每次找中点作为根节点，将两边递归，返回根节点指针作为左右节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedListToBST</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *p, *mid, *pre;</span><br><span class="line">        <span class="keyword">for</span>(p = mid = head, pre = <span class="literal">NULL</span>; p-&gt;next != <span class="literal">NULL</span>; mid = mid-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre = mid;</span><br><span class="line">        &#125;;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span>) pre-&gt;next = <span class="literal">NULL</span>, root-&gt;left = <span class="built_in">sortedListToBST</span>(head);</span><br><span class="line">        <span class="keyword">else</span> root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="built_in">sortedListToBST</span>(mid-&gt;next);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span>) pre-&gt;next = mid;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="convert-sorted-array-to-binary-search-tree"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">108.Convert
Sorted Array to Binary Search Tree</a></h3>
<p>递归做，比链表的容易些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">convert</span><span class="params">(vector &amp;num, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == left) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> mid = right + left &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">convert</span>(num, left, mid);</span><br><span class="line">        root-&gt;right = <span class="built_in">convert</span>(num, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">convert</span>(num, <span class="number">0</span>, num.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-level-order-traversal-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/">107.Binary
Tree Level Order Traversal II</a></h3>
<p>宽搜和深搜都可以，找对层数就行了。</p>
<p>本以为这题亮点是如何一遍实现从底向上顺序的vector，AC之后上网一查也全是最后把vector翻转的。。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vectorv;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(TreeNode *now, <span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">size</span>() &lt;= depth) v.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>)); v[depth].<span class="built_in">push_back</span>(now-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>) <span class="built_in">DFS</span>(now-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>) <span class="built_in">DFS</span>(now-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">levelOrderBottom</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="built_in">DFS</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = v.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i ++, j --)</span><br><span class="line">            <span class="built_in">swap</span>(v[i], v[j]);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="construct-binary-tree-from-inorder-and-postorder-traversal"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106.Construct
Binary Tree from Inorder and Postorder Traversal</a></h3>
<p>数据结构经典题。后序遍历的结尾是根节点
Proot，在中序遍历中找到这个节点 Iroot，则
Iroot两边即为左右子树。根据左右子树节点个数，在后序遍历中找到左右子树分界（左右子树肯定不交叉），则几个关键分界点都找到了，对左右子树递归。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">build</span><span class="params">(vector &amp;inorder, <span class="type">int</span> ileft, <span class="type">int</span> iright, vector &amp;postorder, <span class="type">int</span> pleft, <span class="type">int</span> pright)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(iright == ileft)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> root;</span><br><span class="line">        <span class="keyword">for</span>(root = ileft; inorder[root] != postorder[pright - <span class="number">1</span>]; root ++);</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(inorder[root]);</span><br><span class="line">        node-&gt;left = <span class="built_in">build</span>(inorder, ileft, root, postorder, pleft, pleft + root - ileft);</span><br><span class="line">        node-&gt;right = <span class="built_in">build</span>(inorder, root + <span class="number">1</span>, iright, postorder, pleft + root - ileft, pright - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector &amp;inorder, vector &amp;postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="construct-binary-tree-from-preorder-and-inorder-traversal"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.Construct
Binary Tree from Preorder and Inorder Traversal</a></h3>
<p>和上一题Construct Binary Tree from Inorder and Postorder
Traversal方法一样，前序和后序的信息作用相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">build</span><span class="params">(vector &amp;inorder, <span class="type">int</span> ileft, <span class="type">int</span> iright, vector &amp;preorder, <span class="type">int</span> pleft, <span class="type">int</span> pright)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(iright == ileft)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> root;</span><br><span class="line">        <span class="keyword">for</span>(root = ileft; inorder[root] != preorder[pleft]; root ++);</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(inorder[root]);</span><br><span class="line">        node-&gt;left = <span class="built_in">build</span>(inorder, ileft, root, preorder, pleft + <span class="number">1</span>, pleft + root - ileft);</span><br><span class="line">        node-&gt;right = <span class="built_in">build</span>(inorder, root + <span class="number">1</span>, iright, preorder, pleft + root - ileft + <span class="number">1</span>, pright);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector &amp;preorder, vector &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximum-depth-of-binary-tree"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/maximum-depth-of-binary-tree/">104.Maximum
Depth of Binary Tree</a></h3>
<p>遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">maxDepth</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">maxDepth</span>(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-zigzag-level-order-traversal"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">103.Binary
Tree Zigzag Level Order Traversal</a></h3>
<p>BFS，奇偶层轮流走，一层左到右，一层右到左。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        vector&lt;TreeNode*&gt; q1, q2;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q<span class="number">1.</span><span class="built_in">empty</span>() || !q<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = q<span class="number">1.</span><span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[depth].<span class="built_in">push_back</span>(q1[i]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q1[i]-&gt;left != <span class="literal">NULL</span>) q<span class="number">2.</span><span class="built_in">push_back</span>(q1[i]-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(q1[i]-&gt;right != <span class="literal">NULL</span>) q<span class="number">2.</span><span class="built_in">push_back</span>(q1[i]-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth ++;</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span>(q<span class="number">2.</span><span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = q<span class="number">2.</span><span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[depth].<span class="built_in">push_back</span>(q2[i]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q2[i]-&gt;right != <span class="literal">NULL</span>) q<span class="number">1.</span><span class="built_in">push_back</span>(q2[i]-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(q2[i]-&gt;left != <span class="literal">NULL</span>) q<span class="number">1.</span><span class="built_in">push_back</span>(q2[i]-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">clear</span>();</span><br><span class="line">            depth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-level-order-traversal"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/binary-tree-level-order-traversal/">102.Binary
Tree Level Order Traversal</a></h3>
<p>懒省事直接在上一题Binary Tree Zigzag Level Order
Traversal的代码上改了一下。</p>
<p>只用一个队列的话，增加个层数信息存队列里即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">levelOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        vector&lt;TreeNode*&gt; q1, q2;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q<span class="number">1.</span><span class="built_in">empty</span>() || !q<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q<span class="number">1.</span><span class="built_in">size</span>(); i ++) &#123; ans[depth].<span class="built_in">push_back</span>(q1[i]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q1[i]-&gt;left != <span class="literal">NULL</span>) q<span class="number">2.</span><span class="built_in">push_back</span>(q1[i]-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(q1[i]-&gt;right != <span class="literal">NULL</span>) q<span class="number">2.</span><span class="built_in">push_back</span>(q1[i]-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth ++;</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span>(q<span class="number">2.</span><span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q<span class="number">2.</span><span class="built_in">size</span>(); i ++) &#123; ans[depth].<span class="built_in">push_back</span>(q2[i]-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q2[i]-&gt;left != <span class="literal">NULL</span>) q<span class="number">1.</span><span class="built_in">push_back</span>(q2[i]-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(q2[i]-&gt;right != <span class="literal">NULL</span>) q<span class="number">1.</span><span class="built_in">push_back</span>(q2[i]-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">clear</span>();</span><br><span class="line">            depth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="symmetric-tree"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/symmetric-tree/">101.Symmetric
Tree</a></h3>
<p>递归：左指针和右指针，对称递归，即(左的左)和(右的右)对应，(左的右)和(右的左)对应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(TreeNode *l, TreeNode *r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;val != r-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;left != r-&gt;right &amp;&amp; (l-&gt;left == <span class="literal">NULL</span> || r-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        || l-&gt;right != r-&gt;left &amp;&amp; (l-&gt;right == <span class="literal">NULL</span> || r-&gt;left == <span class="literal">NULL</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;left != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">judge</span>(l-&gt;left, r-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;right != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">judge</span>(l-&gt;right, r-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span></span><br><span class="line">            || root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>非递归：左右子树分别做一个队列，同步遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span></span><br><span class="line">            || root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue q1, q2;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!q<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *now1 = q<span class="number">1.f</span>ront(), *now2 = q<span class="number">2.f</span>ront();</span><br><span class="line">            q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(now1-&gt;val != now2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(now1-&gt;left != <span class="literal">NULL</span> || now2-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now1-&gt;left == <span class="literal">NULL</span> || now2-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q<span class="number">1.</span><span class="built_in">push</span>(now1-&gt;left);</span><br><span class="line">                q<span class="number">2.</span><span class="built_in">push</span>(now2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now1-&gt;right != <span class="literal">NULL</span> || now2-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now1-&gt;right == <span class="literal">NULL</span> || now2-&gt;left == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q<span class="number">1.</span><span class="built_in">push</span>(now1-&gt;right);</span><br><span class="line">                q<span class="number">2.</span><span class="built_in">push</span>(now2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="same-tree"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/same-tree/">100.Same Tree</a></h3>
<p>同步遍历，比较判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p != q &amp;&amp; (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) || p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="recover-binary-search-tree"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/recover-binary-search-tree/">99.Recover
Binary Search Tree</a></h3>
<p>中序遍历是二叉查找树的顺序遍历，<em>a,
<em>b表示前驱节点和当前节点，因为只有一对数值翻转了，所以肯定会遇到前驱节点val比当前节点val大的情况一次或两次，遇到一次表示翻转的是相邻的两个节点。</em>ans1和</em>ans2指向两个被翻转的节点，当遇到前驱val比当前val大的情况时候，根据第一次还是第二次给ans1和ans2赋值，最终翻转回来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *a, *b;</span><br><span class="line">    TreeNode *ans1, *ans2;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">DFS</span>(now-&gt;left);</span><br><span class="line">        a = b;</span><br><span class="line">        b = now;</span><br><span class="line">        <span class="keyword">if</span>(a != <span class="literal">NULL</span> &amp;&amp; a-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans1 == <span class="literal">NULL</span>) ans1 = a;</span><br><span class="line">            ans2 = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">DFS</span>(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        a = b = ans1 = ans2 = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(ans1-&gt;val, ans2-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="validate-binary-search-tree"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/validate-binary-search-tree/">98.Validate
Binary Search Tree</a></h3>
<p>中序遍历，更新前驱节点，与当前节点比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">isValidBST</span>(root-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">isValidBST</span>(root-&gt;right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="interleaving-string"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/interleaving-string/">97.Interleaving
String</a></h3>
<p>动态规划。如果结果是true，则任意 <code>i</code>,
<code>j</code>，<code>s1[i]</code> 之前的字符 和
<code>s2[j]</code>之前的字符，都能够交叉为 <code>s3[i + j]</code>
之前的字符。</p>
<p>由此，当<code>dp[i][j]</code>时，如果<code>s1[i]==s3[i+j]</code>，则尝试<code>s1[i]</code>与<code>s3[i+j]</code>对应，如果<code>dp[i-1][j]</code>是<code>true</code>，则<code>dp[i][j]</code>也为<code>true</code>。如果<code>s2[j]==s3[i+j]</code>则同样处理。</p>
<p>直到最后，判断<code>dp[s1.length()-1][s2.length()-1]</code>是否为true。为方便初始化，坐标后移了一位。</p>
<p>题目不厚道的出了<code>s1.length()+s2.length() != s3.length()</code>的数据，特判一下。</p>
<p>看到网上也都是<code>O(n^2)</code>的解法，我也就放心了。。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s<span class="number">1.l</span>ength() + s<span class="number">2.l</span>ength() != s<span class="number">3.l</span>ength())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector <span class="title">dp</span><span class="params">(s<span class="number">1.l</span>ength() + <span class="number">1</span>, vector(s<span class="number">2.l</span>ength() + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s<span class="number">1.l</span>ength(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= s<span class="number">2.l</span>ength(); j ++) </span><br><span class="line">            &#123; </span><br><span class="line">               <span class="keyword">if</span>(!i &amp;&amp; !j) dp[i][j] = <span class="literal">true</span>; </span><br><span class="line">               dp[i][j] = dp[i][j] || i &gt; <span class="number">0</span> &amp;&amp; s3[i + j - <span class="number">1</span>] == s1[i - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j];</span><br><span class="line">               dp[i][j] = dp[i][j] || j &gt; <span class="number">0</span> &amp;&amp; s3[i + j - <span class="number">1</span>] == s2[j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s<span class="number">1.l</span>ength()][s<span class="number">2.l</span>ength()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="unique-binary-search-trees-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/unique-binary-search-trees-ii/">96.Unique
Binary Search Trees II</a></h3>
<p>LeetCode目前为止感觉最暴力的。递归遍历所有情况，每次返回子问题（左右子树）的vector的解，两层循环组合这些解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">generate</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vectorres;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *tmp = <span class="literal">NULL</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt;= end; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector l = <span class="built_in">generate</span>(start, i - <span class="number">1</span>), r = <span class="built_in">generate</span>(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; l.<span class="built_in">size</span>(); j ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; r.<span class="built_in">size</span>(); k ++) &#123; TreeNode *tmp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i); tmp-&gt;left = l[j];</span><br><span class="line">                    tmp-&gt;right = r[k];</span><br><span class="line">                    res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generate</span>(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="unique-binary-search-trees"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/unique-binary-search-trees/">95.Unique
Binary Search Trees</a></h3>
<p>经典问题，卡特兰数，可递推，可用公式（公式用组合数，也要写循环）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">COM</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m = n - m &lt; m ? n - m : m;</span><br><span class="line">        <span class="type">int</span> res, i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = n, res = j = <span class="number">1</span>; i &gt; n - m; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            res *= i;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt;= m &amp;&amp; res % j == <span class="number">0</span>; j ++)</span><br><span class="line">                res /= j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">COM</span>(n &lt;&lt; <span class="number">1</span>, n) / (n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binary-tree-inorder-traversal"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/binary-tree-inorder-traversal/">94.Binary
Tree Inorder Traversal</a></h3>
<p>数据结构基础</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode *now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(now-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(now-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="restore-ip-addresses"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/restore-ip-addresses/">93.Restore
IP Addresses</a></h3>
<p>四层递归枚举分割位置，判断数字范围和前导零，处理字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(string s, <span class="type">int</span> last, <span class="type">int</span> cur, string now)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(last == s.<span class="built_in">length</span>()) <span class="keyword">return</span>;</span><br><span class="line">            string tmp = s.<span class="built_in">substr</span>(last, s.<span class="built_in">length</span>() - last);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">atoi</span>(tmp.<span class="built_in">c_str</span>()) &lt;= <span class="number">255</span> &amp;&amp; (tmp.<span class="built_in">length</span>() == <span class="number">1</span> || tmp[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">                res.<span class="built_in">push_back</span>(now + tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string lin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = last; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp = s.<span class="built_in">substr</span>(last, i - last + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">atoi</span>(tmp.<span class="built_in">c_str</span>()) &lt;= <span class="number">255</span> &amp;&amp; (tmp.<span class="built_in">length</span>() == <span class="number">1</span> || tmp[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">                <span class="built_in">DFS</span>(s, i + <span class="number">1</span>, cur + <span class="number">1</span>, now + tmp + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-linked-list-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/reverse-linked-list-ii/">92.Reverse
Linked List II</a></h3>
<p>在表头添加一个(哨兵)会好写很多，额外的newhead可以帮助标记翻转之后更换了的头指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        newhead-&gt;next = head;</span><br><span class="line">        ListNode *pre = newhead, *p = head, *start = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; p != <span class="literal">NULL</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(i == m)</span><br><span class="line">                start = pre;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m &amp;&amp; i &lt;= n) p-&gt;next = pre;</span><br><span class="line">            <span class="keyword">if</span>(i == n)</span><br><span class="line">            &#123;</span><br><span class="line">                start-&gt;next-&gt;next = tmp;</span><br><span class="line">                start-&gt;next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = newhead-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(newhead);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="decode-ways"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/decode-ways/">91.Decode
Ways</a></h3>
<p>递推：<code>dp[i]</code>表示前 <code>i</code> 个数字的解码种数。</p>
<p>`dp[i] = if(一)dp[i-1] + if(二)dp[i-2]``</p>
<p>当 <code>i</code> 位置不为<code>0</code>，可加上
<code>i - 1</code>位置的解。当当前位置和前一位置组成的两位数满足解码且高位不为<code>0</code>，可加上
<code>i - 2</code> 位置的解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDecodings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">dp</span><span class="params">(s.length() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">           dp[i + <span class="number">1</span>] = (s[i] != <span class="string">&#x27;0&#x27;</span> ? dp[i] : <span class="number">0</span>) + </span><br><span class="line">               (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">atoi</span>(s.<span class="built_in">substr</span>(i - <span class="number">1</span>, <span class="number">2</span>).<span class="built_in">c_str</span>()) &lt;= <span class="number">26</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">length</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="subsets-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/subsets-ii/">90.Subsets
II</a></h3>
<p>统计地存map里，map[i]= j 表示 S 中有 j 个
i。map是有序的，用迭代器递归枚举放入集合的个数。</p>
<p>也可以先排序，用set标记每个数时候被放入过，第一次放入之后才可以继续放同一个数。</p>
<p>代码是用map的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    vector now;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == mp.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator tmp = i;</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="built_in">DFS</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; tmp-&gt;second; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            now.<span class="built_in">push_back</span>(tmp-&gt;first);</span><br><span class="line">            <span class="built_in">DFS</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; tmp-&gt;second; j ++)</span><br><span class="line">            now.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">subsetsWithDup</span><span class="params">(vector &amp;S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            !mp.<span class="built_in">count</span>(S[i]) ? (mp[S[i]] = <span class="number">1</span>) : mp[S[i]] ++;</span><br><span class="line">        <span class="built_in">DFS</span>(mp.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="gray-code"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/gray-code/">89.Gray Code</a></h3>
<p>格雷码有多种生成方法，可参考<a
target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81">维基百科</a>
。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">grayCode</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) res.<span class="built_in">push_back</span>((i &gt;&gt; <span class="number">1</span>) ^ i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="merge-sorted-array"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/merge-sorted-array/">88.Merge
Sorted Array</a></h3>
<p>从后往前，对 A
来说一个萝卜一个坑，肯定不会破坏前面的数据。具体看代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> m, <span class="type">int</span> B[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = m + n - <span class="number">1</span>, i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; B[j]) A[p --] = A[i --];</span><br><span class="line">            <span class="keyword">else</span> A[p --] = B[j --];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) A[p --] = A[i --];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) A[p --] = B[j --];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="scramble-string"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/scramble-string/">87.Scramble
String</a></h3>
<p>直接搜索可以过，记忆化搜索可提高效率。</p>
<p>dp[i][j][k]表示从 s1[i] 和 s2[j] 开始长度为 k 的字符串是否是scrambled
string。</p>
<p>枚举分割位置，scrambled
string要求字符串对应字母的个数是一致的，可以直接排序对比。递归终点是刚好只有一个字母。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string S1, S2;</span><br><span class="line">    vector&lt;vector &gt; dp;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> s1start, <span class="type">int</span> s2start, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> &amp;ans = dp[s1start][s2start][len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> ans = S1[s1start] == S2[s2start];</span><br><span class="line">        <span class="keyword">if</span>(ans != <span class="number">-1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">judge</span>(S<span class="number">1.</span><span class="built_in">substr</span>(s1start, len), S<span class="number">2.</span><span class="built_in">substr</span>(s2start, len)))</span><br><span class="line">            <span class="keyword">return</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans</span><br><span class="line">            || <span class="built_in">DFS</span>(s1start, s2start, i) &amp;&amp; <span class="built_in">DFS</span>(s1start + i, s2start + i, len - i)</span><br><span class="line">            || <span class="built_in">DFS</span>(s1start, s2start + len - i, i) &amp;&amp; <span class="built_in">DFS</span>(s1start + i, s2start, len - i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isScramble</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        S1 = s1, S2 = s2;</span><br><span class="line">        dp = <span class="built_in">vector</span>&lt;vector &gt;</span><br><span class="line">            (s<span class="number">1.l</span>ength(), <span class="built_in">vector</span></span><br><span class="line">                (s<span class="number">1.l</span>ength(), <span class="built_in">vector</span></span><br><span class="line">                    (s<span class="number">1.l</span>ength(), <span class="number">-1</span>)));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, s<span class="number">1.l</span>ength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="partition-list"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/partition-list/">86.Partition
List</a></h3>
<p>分存大小最后合并。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *shead, *bhead, *smaller, *bigger, *p;</span><br><span class="line">        <span class="keyword">for</span>(shead = bhead = smaller = bigger = <span class="literal">NULL</span>, p = head; p != <span class="literal">NULL</span>; p = p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val &lt; x) &#123; <span class="keyword">if</span>(shead == <span class="literal">NULL</span>) shead = p; <span class="keyword">if</span>(smaller != <span class="literal">NULL</span>) smaller-&gt;next = p;</span><br><span class="line">                smaller = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(bhead == <span class="literal">NULL</span>)</span><br><span class="line">                    bhead = p;</span><br><span class="line">                <span class="keyword">if</span>(bigger != <span class="literal">NULL</span>)</span><br><span class="line">                    bigger-&gt;next = p;</span><br><span class="line">                bigger = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(smaller != <span class="literal">NULL</span>) smaller-&gt;next = bhead;</span><br><span class="line">        <span class="keyword">if</span>(bigger != <span class="literal">NULL</span>) bigger-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> shead != <span class="literal">NULL</span> ? shead : bhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximal-rectangle"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/maximal-rectangle/">85.Maximal
Rectangle</a></h3>
<p>方法一：<code>linecnt[i][j]</code>统计第 <code>i</code> 行到第
<code>j</code> 位置有多少个连续的
<code>'1'</code>，接下来枚举列，每一列相当于一次直方图最大矩形统计，计算每个位置向前和向后最远的不少于当前位置值的位置，每次更新结果，总复杂度<code>O(n^2)</code>。</p>
<p>找(最远位置)用迭代指针，理论复杂度略高于<code>O(n)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> H = matrix.<span class="built_in">size</span>(), W = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">left</span><span class="params">(H)</span>, <span class="title">right</span><span class="params">(H)</span></span>;</span><br><span class="line">        <span class="function">vector <span class="title">linecnt</span><span class="params">(H, vector(W, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; W; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) last ++;</span><br><span class="line">                <span class="keyword">else</span> last = <span class="number">0</span>;</span><br><span class="line">                linecnt[i][j] = last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; W; k ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i ++) </span><br><span class="line">            &#123; </span><br><span class="line">               <span class="keyword">if</span>(i == <span class="number">0</span>) left[i] = <span class="number">-1</span>; </span><br><span class="line">               <span class="keyword">else</span> </span><br><span class="line">               &#123; </span><br><span class="line">                   left[i] = i - <span class="number">1</span>; </span><br><span class="line">                   <span class="keyword">while</span>(left[i] &gt; <span class="number">-1</span> &amp;&amp; linecnt[left[i]][k] &gt;= linecnt[i][k])</span><br><span class="line">                        left[i] = left[left[i]];</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = H - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == H - <span class="number">1</span>) right[i] = H;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right[i] = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(right[i] &lt; H &amp;&amp; linecnt[right[i]][k] &gt;= linecnt[i][k])</span><br><span class="line">                        right[i] = right[right[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * linecnt[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用单调栈，理论复杂度O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">linecnt</span><span class="params">(matrix.size(), vector(matrix[<span class="number">0</span>].size(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) last ++;</span><br><span class="line">                <span class="keyword">else</span> last = <span class="number">0</span>;</span><br><span class="line">                linecnt[i][j] = last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); k ++)</span><br><span class="line">        &#123;</span><br><span class="line">            stack s, site;</span><br><span class="line">            <span class="built_in">vectorlast</span>(matrix.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++) &#123; <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &gt;= linecnt[i][k])</span><br><span class="line">                    s.<span class="built_in">pop</span>(), site.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) last[i] = site.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> last[i] = <span class="number">0</span>;</span><br><span class="line">                s.<span class="built_in">push</span>(linecnt[i][k]);</span><br><span class="line">                site.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>(), site.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &gt;= linecnt[i][k])</span><br><span class="line">                    s.<span class="built_in">pop</span>(), site.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) ans = <span class="built_in">max</span>(ans, (site.<span class="built_in">top</span>() - last[i]) * linecnt[i][k]);</span><br><span class="line">                <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, (<span class="type">int</span>)(matrix.<span class="built_in">size</span>() - last[i]) * linecnt[i][k]);</span><br><span class="line">                s.<span class="built_in">push</span>(linecnt[i][k]);</span><br><span class="line">                site.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：每个 <code>1</code>
的点当作一个矩形的底部，<code>left[j]、right[j]、height[j]</code>表示当前行第
<code>j</code>个位置这个点向左、右、上伸展的最大矩形的边界，作为滚动数组，下一行的数据可以由上一行结果得到，总复杂度O(n^2)。</p>
<p><code>left[j] = max(这一行最左, left[j]（上一行最左） );</code></p>
<p><code>right[j] = min(这一行最右，right[j]（上一行最右） );</code></p>
<p><code>height[j] = height[j - 1] + 1;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> H = matrix.<span class="built_in">size</span>(), W = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector <span class="title">left</span><span class="params">(W, <span class="number">-1</span>)</span>, <span class="title">right</span><span class="params">(W, W)</span>, <span class="title">height</span><span class="params">(W, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; W; j ++) </span><br><span class="line">            &#123; </span><br><span class="line">               <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">               &#123; </span><br><span class="line">                   <span class="keyword">if</span>(last == <span class="number">-1</span>) last = j; </span><br><span class="line">                   left[j] = <span class="built_in">max</span>(left[j], last); </span><br><span class="line">                   height[j] ++;</span><br><span class="line">               &#125; </span><br><span class="line">               <span class="keyword">else</span> </span><br><span class="line">               &#123; </span><br><span class="line">                   last = <span class="number">-1</span>; left[j] = <span class="number">-1</span>; height[j] = <span class="number">0</span>; </span><br><span class="line">               &#125; </span><br><span class="line">             &#125; last = <span class="number">-1</span>; </span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = W - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(last == <span class="number">-1</span>) last = j;</span><br><span class="line">                    right[j] = <span class="built_in">min</span>(right[j], last);</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, height[j] * (right[j] - left[j] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    last = <span class="number">-1</span>;</span><br><span class="line">                    right[j] = W;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="largest-rectangle-in-histogram"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/largest-rectangle-in-histogram/">84.Largest
Rectangle in Histogram</a></h3>
<p>参考上一题Maximal Rectangle方法一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector <span class="title">left</span><span class="params">(height.size())</span>, <span class="title">right</span><span class="params">(height.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i ++) </span><br><span class="line">        &#123; </span><br><span class="line">           <span class="keyword">if</span>(i == <span class="number">0</span>) left[i] = <span class="number">-1</span>; </span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">           &#123; </span><br><span class="line">               left[i] = i - <span class="number">1</span>; </span><br><span class="line">               <span class="keyword">while</span>(left[i] &gt; <span class="number">-1</span> &amp;&amp; height[i] &lt;= height[left[i]])</span><br><span class="line">                   left[i] = left[left[i]]; </span><br><span class="line">           &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = height.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == height.<span class="built_in">size</span>() - <span class="number">1</span>) right[i] = height.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(right[i] &lt; height.<span class="built_in">size</span>() &amp;&amp; height[i] &lt;= height[right[i]])</span><br><span class="line">                    right[i] = right[right[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-duplicates-from-sorted-list-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">83.Remove
Duplicates from Sorted List II</a></h3>
<p>加个表头乱搞吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        newhead-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(ListNode *pre = newhead, *now = head, *nex = head-&gt;next; nex != <span class="literal">NULL</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;val == nex-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(nex != <span class="literal">NULL</span> &amp;&amp; now-&gt;val == nex-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">free</span>(now);</span><br><span class="line">                    now = nex;</span><br><span class="line">                    nex = nex-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">free</span>(now);</span><br><span class="line">                pre-&gt;next = nex;</span><br><span class="line">                <span class="keyword">if</span>(nex == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> pre = now;</span><br><span class="line">            now = nex;</span><br><span class="line">            nex = nex-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = newhead-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(newhead);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-duplicates-from-sorted-list"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">82.Remove
Duplicates from Sorted List</a></h3>
<p>直接操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">for</span>(ListNode *pre = head, *p = head-&gt;next; p != <span class="literal">NULL</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val == p-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = p-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(p);</span><br><span class="line">                p = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-in-rotated-sorted-array-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/search-in-rotated-sorted-array-ii/">81.Search
in Rotated Sorted Array II</a></h3>
<p>以mid为界，左右两边至少有一边是有序的。由于不可避免地会有O(n)的可能性，所以确定的时候二分，不确定的时候单位缩减边界。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; A[mid] &amp;&amp; A[left] &lt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; A[right] &amp;&amp; A[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[left] == target || A[right] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(A[left] &lt; target) left ++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; A[right]) right --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[left] == target ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-duplicates-from-sorted-array-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">80.Remove
Duplicates from Sorted Array II</a></h3>
<p>记下放了几个，多了不放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j, cnt;</span><br><span class="line">        <span class="keyword">for</span>(i = j = cnt = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; A[j - <span class="number">1</span>] == A[i]) cnt ++;</span><br><span class="line">            <span class="keyword">else</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">2</span>) A[j ++] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="word-search"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/word-search/">79.Word
Search</a></h3>
<p>基础DFS。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, vector &amp;board, string word, <span class="type">int</span> ith)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[x][y] != word[ith]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ith == word.<span class="built_in">length</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) </span><br><span class="line">        &#123; </span><br><span class="line">           <span class="type">int</span> nx = x + dx[i]; <span class="type">int</span> ny = y + dy[i]; </span><br><span class="line">           <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; board.<span class="built_in">size</span>() &amp;&amp; ny &lt; board[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">DFS</span>(nx, ny, board, word, ith + <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    board[x][y] = word[ith];</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = word[ith];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector &amp;board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">DFS</span>(i, j, board, word, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="subsets"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/subsets/">78.Subsets</a></h3>
<p>基础DFS。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector now;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector &amp;S, <span class="type">int</span> ith)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ith == S.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DFS</span>(S, ith + <span class="number">1</span>);</span><br><span class="line">        now.<span class="built_in">push_back</span>(S[ith]);</span><br><span class="line">        <span class="built_in">DFS</span>(S, ith + <span class="number">1</span>);</span><br><span class="line">        now.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">subsets</span><span class="params">(vector &amp;S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(S.<span class="built_in">begin</span>(), S.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">DFS</span>(S, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="combinations"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/combinations/">77.Combinations</a></h3>
<p>基础DFS。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector now;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> ith, <span class="type">int</span> sum, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum + n - ith + <span class="number">1</span> &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(n, ith + <span class="number">1</span>, sum, k);</span><br><span class="line">        &#125;</span><br><span class="line">        now.<span class="built_in">push_back</span>(ith);</span><br><span class="line">        <span class="built_in">DFS</span>(n, ith + <span class="number">1</span>, sum + <span class="number">1</span>, k);</span><br><span class="line">        now.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(n, <span class="number">1</span>, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="minimum-window-substring"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/minimum-window-substring/">76.Minimum
Window Substring</a></h3>
<p>先统计 <code>T</code>
中各字符都有多少个，然后两个下标一前(<code>i</code>)一后(<code>j</code>)在
<code>S</code> 上跑， 当 <code>i</code> 跑到把 <code>T</code>
中字符都包含的位置时候，让 <code>j</code> 追到第一个包含 <code>T</code>
的字符的地方，更新结果，去掉 <code>j</code> 这个位置字符的统计，让
<code>i</code> 继续跑，如此反复。</p>
<p><code>i</code> 和 <code>j</code> 都只遍历一遍 <code>S</code>，复杂度
<code>O(n)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">cnt</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span>, <span class="title">need</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, len = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            need[T[i]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; S.<span class="built_in">length</span>(); j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; S.<span class="built_in">length</span>() &amp;&amp; sum &lt; T.<span class="built_in">length</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[S[i]] &lt; need[S[i]])</span><br><span class="line">                    sum ++;</span><br><span class="line">                cnt[S[i]] ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(sum == T.<span class="built_in">length</span>() &amp;&amp; j &lt; S.<span class="built_in">length</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[S[j]] --;</span><br><span class="line">                <span class="keyword">if</span>(cnt[S[j]] &lt; need[S[j]])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; T.<span class="built_in">length</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i - j &lt; len)</span><br><span class="line">                ans = S.<span class="built_in">substr</span>(j, i - j), len = i - j;</span><br><span class="line">            sum --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sort-colors"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/sort-colors/">75.Sort
Colors</a></h3>
<p>轮流找：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> find = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n; i ++) &#123; <span class="keyword">if</span>(A[i] == find) <span class="keyword">continue</span>; <span class="keyword">while</span>(j &gt; i &amp;&amp; A[j] != find) j --;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; i) <span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">            <span class="keyword">else</span> i --, j = n - <span class="number">1</span>, find ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>找到哪个放哪个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p0, p1, p2;</span><br><span class="line">        <span class="keyword">for</span>(p0 = <span class="number">0</span>, p1 = p2 = n - <span class="number">1</span>; p0 &lt; p1; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[p0] == <span class="number">0</span>) p0 ++;</span><br><span class="line">            <span class="keyword">if</span>(A[p0] == <span class="number">1</span>) <span class="built_in">swap</span>(A[p0], A[p1 --]);</span><br><span class="line">            <span class="keyword">if</span>(A[p0] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[p0], A[p2 --]);</span><br><span class="line">                p1 = p2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-a-2d-matrix"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/search-a-2d-matrix/">74.Search a
2D Matrix</a></h3>
<p>写两个二分查找。或者把整个矩阵看作一维，直接二分，换算坐标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector &amp;matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid;</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = matrix.<span class="built_in">size</span>(); left &lt; right - <span class="number">1</span>; ) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] &gt; target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == matrix.<span class="built_in">size</span>() || right == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vector &amp;a = matrix[left];</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = a.<span class="built_in">size</span>(); left &lt; right - <span class="number">1</span>;) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &gt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == a.<span class="built_in">size</span>() || right == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> a[left] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="set-matrix-zeroes"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/set-matrix-zeroes/">73.Set Matrix
Zeroes</a></h3>
<p><code>O(m+n)</code>的方法是容易想到的，而空间复杂度<code>O(1)</code>，只要利用原矩阵的一行和一列来使用<code>O(m+n)</code>的方法就行了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>, y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = i, y = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        matrix[x][j] = <span class="number">0</span>;</span><br><span class="line">                        matrix[i][y] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j ++)</span><br><span class="line">                <span class="keyword">if</span>((matrix[x][j] == <span class="number">0</span> || matrix[i][y] == <span class="number">0</span>) &amp;&amp; (i != x &amp;&amp; j != y))</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i ++) matrix[i][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) matrix[x][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="edit-distance"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/edit-distance/">72.Edit
Distance</a></h3>
<p>动态规划，先初始化 <code>dp[i][0]</code> 和
<code>dp[0][i]</code>，即每个字符串对应空串的编辑距离为串长度，之后对每个位置取子问题加上当前位置
改、删、增得解的最小值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">dp</span><span class="params">(word<span class="number">1.l</span>ength() + <span class="number">1</span>, vector(word<span class="number">2.l</span>ength() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word<span class="number">1.l</span>ength(); i ++) dp[i + <span class="number">1</span>][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word<span class="number">2.l</span>ength(); i ++) dp[<span class="number">0</span>][i + <span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word<span class="number">1.l</span>ength(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; word<span class="number">2.l</span>ength(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i] != word2[j])</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j] + <span class="number">1</span>, <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>] + <span class="number">1</span>, dp[i + <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j], <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>] + <span class="number">1</span>, dp[i + <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word<span class="number">1.l</span>ength()][word<span class="number">2.l</span>ength()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="simplify-path"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/simplify-path/">71.Simplify
Path</a></h3>
<p>好烦人的题，没什么好说的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        stack s;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str == <span class="string">&quot;..&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line"></span><br><span class="line">                        s.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str != <span class="string">&quot;.&quot;</span> &amp;&amp; str != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                    s.<span class="built_in">push</span>(str);</span><br><span class="line">                str.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str += path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;..&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str != <span class="string">&quot;.&quot;</span> &amp;&amp; str != <span class="string">&quot;&quot;</span>)</span><br><span class="line">            s.<span class="built_in">push</span>(str);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(str.<span class="built_in">clear</span>(); !s.<span class="built_in">empty</span>(); s.<span class="built_in">pop</span>())</span><br><span class="line">            str = <span class="string">&quot;/&quot;</span> + s.<span class="built_in">top</span>() + str;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="climbing-stairs"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/climbing-stairs/">70.Climbing
Stairs</a></h3>
<p>递推，就是斐波那契数列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)</span><br><span class="line">            (<span class="built_in">pow</span>((<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>, n + <span class="number">1</span>) / <span class="built_in">sqrt</span>(<span class="number">5</span>) -</span><br><span class="line">            <span class="built_in">pow</span>((<span class="number">1</span>-<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>, n + <span class="number">1</span>) / <span class="built_in">sqrt</span>(<span class="number">5</span>) + <span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sqrtx"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/sqrtx/">69.Sqrt(x)</a></h3>
<p>牛顿迭代。
设输入为n，<code>f(x)=x^2-n</code>，解就是<code>f(x)=0</code>时的<code>x</code>。
设猜了一数<code>x[0]</code>，那么在<code>f(x)</code>在<code>x[0]</code>处的切线与x轴的交点<code>x[1]</code>更接近目标解（可画图看看）。
那么递推下去，<code>x[i]=(x[i-1]+n/x[i-1])/2</code>，用double，越推越精确，直到自己想要的精度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> now, last;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(now = last = (<span class="type">double</span>)x; ; last = now)</span><br><span class="line">        &#123;</span><br><span class="line">            now = (last + (x / last)) * <span class="number">0.5</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(last - now) &lt; <span class="number">1e-5</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(now + <span class="number">1e-6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="text-justification"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/text-justification/">68.Text
Justification</a></h3>
<p>每行限制长度，空格均匀插入，不能完全平均的情况下优先靠前的单词间隔。</p>
<p>最后一行特别处理，单词间只有一个空格，剩下的放在末尾。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">fullJustify</span><span class="params">(vector &amp;words, <span class="type">int</span> L)</span> </span>&#123;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, i, j, k, l;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; words.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; words.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cnt += words[i].<span class="built_in">length</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == words.<span class="built_in">size</span>() || (L - cnt) / (i - j) &lt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> blank = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; words.<span class="built_in">size</span>())</span><br><span class="line">                    blank = (i - j - <span class="number">1</span>) ? (L - cnt + words[i].<span class="built_in">length</span>()) / (i - j - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">                string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                l = i &lt; words.<span class="built_in">size</span>() ? (L - cnt + words[i].<span class="built_in">length</span>() - blank * (i - j - <span class="number">1</span>)) : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(k = j; k &lt; i; k ++, l --)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp += words[k];</span><br><span class="line">                    <span class="keyword">if</span>(k != i - <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i != words.<span class="built_in">size</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> bl = <span class="number">0</span>; bl &lt; blank; bl ++) tmp += <span class="string">&quot; &quot;</span>; <span class="keyword">if</span>(l &gt; <span class="number">0</span>) tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(tmp.<span class="built_in">length</span>() &lt; L) tmp += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                j = i;</span><br><span class="line">                i --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="plus-one"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/plus-one/">67.Plus One</a></h3>
<p>大整数加法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">plusOne</span><span class="params">(vector &amp;digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur, i;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        <span class="keyword">for</span>(i = digits.<span class="built_in">size</span>() - <span class="number">1</span>, cur = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = digits[i] + cur;</span><br><span class="line">            cur = tmp / <span class="number">10</span>;</span><br><span class="line">            digits[i] = tmp % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur) digits.<span class="built_in">insert</span>(digits.<span class="built_in">begin</span>(), cur);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="valid-number"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/valid-number/">66.Valid
Number</a></h3>
<p>用DFA也不麻烦，题目定义太模糊，为了理解规则错很多次也没办法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> f[<span class="number">11</span>][<span class="number">129</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> fail = <span class="number">-1</span>;    <span class="comment">//非法</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> st = <span class="number">0</span>;       <span class="comment">//起始</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> pn = <span class="number">1</span>;       <span class="comment">//正负号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> di = <span class="number">2</span>;       <span class="comment">//整数部分</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> del = <span class="number">3</span>;      <span class="comment">//前面无数字小数点</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ddi = <span class="number">4</span>;      <span class="comment">//小数部分</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ndel = <span class="number">5</span>;     <span class="comment">//前面有数字小数点</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dibl = <span class="number">6</span>;     <span class="comment">//数后空格</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ex = <span class="number">7</span>;       <span class="comment">//进入指数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> epn = <span class="number">8</span>;      <span class="comment">//指数符号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> edi = <span class="number">9</span>;      <span class="comment">//指数数字</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> end = <span class="number">10</span>;     <span class="comment">//正确结束</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildDFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[st][<span class="string">&#x27; &#x27;</span>] = st;</span><br><span class="line">        f[st][<span class="string">&#x27;+&#x27;</span>] = f[st][<span class="string">&#x27;-&#x27;</span>] = pn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="string">&#x27;0&#x27;</span>; i &lt;= <span class="string">&#x27;9&#x27;</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[st][i] = f[pn][i] = f[di][i] = di;</span><br><span class="line">            f[del][i] = f[ndel][i] = f[ddi][i] = ddi;</span><br><span class="line">            f[ex][i] = f[epn][i] = f[edi][i] = edi;</span><br><span class="line">        &#125;</span><br><span class="line">        f[di][<span class="string">&#x27;.&#x27;</span>] = ndel;</span><br><span class="line">        f[st][<span class="string">&#x27;.&#x27;</span>] = f[pn][<span class="string">&#x27;.&#x27;</span>] = del;</span><br><span class="line">        f[di][<span class="string">&#x27; &#x27;</span>] = f[ndel][<span class="string">&#x27; &#x27;</span>] = f[ddi][<span class="string">&#x27; &#x27;</span>] = f[dibl][<span class="string">&#x27; &#x27;</span>] = f[edi][<span class="string">&#x27; &#x27;</span>] = dibl;</span><br><span class="line">        f[di][<span class="number">0</span>] = f[ndel][<span class="number">0</span>] = f[dibl][<span class="number">0</span>] = f[ddi][<span class="number">0</span>] = f[edi][<span class="number">0</span>] = end;</span><br><span class="line">        f[di][<span class="string">&#x27;e&#x27;</span>] = f[ndel][<span class="string">&#x27;e&#x27;</span>] = f[ddi][<span class="string">&#x27;e&#x27;</span>] = ex;</span><br><span class="line">        f[ex][<span class="string">&#x27; &#x27;</span>] = ex;</span><br><span class="line">        f[ex][<span class="string">&#x27;+&#x27;</span>] = f[ex][<span class="string">&#x27;-&#x27;</span>] = epn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DFA</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> situ = st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            situ = f[situ][s[i]];</span><br><span class="line">            <span class="keyword">if</span>(situ == end) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(situ == fail) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">buildDFA</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DFA</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="add-binary"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/add-binary/">65.Add
Binary</a></h3>
<p>翻转，大整数加法，再翻转。无心情优化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        string c;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(a.<span class="built_in">length</span>(), b.<span class="built_in">length</span>()); i ++) &#123; <span class="type">int</span> tmp = a[i] - <span class="string">&#x27;0&#x27;</span> + b[i] - <span class="string">&#x27;0&#x27;</span> + cur; cur = tmp &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            c += (tmp &amp; <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string &amp;t = a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>() ? a : b;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; t.<span class="built_in">length</span>(); i ++) &#123; <span class="type">int</span> tmp = t[i] - <span class="string">&#x27;0&#x27;</span> + cur; cur = tmp &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            c += (tmp &amp; <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur) c += <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="minimum-path-sum"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/minimum-path-sum/">64.Minimum Path
Sum</a></h3>
<p>递推</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123; <span class="type">int</span> tmp = <span class="number">0x3f3f3f3f</span>; <span class="keyword">if</span>(i &gt; <span class="number">0</span>) tmp = <span class="built_in">min</span>(tmp, grid[i][j] + grid[i - <span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>) tmp = <span class="built_in">min</span>(tmp, grid[i][j] + grid[i][j - <span class="number">1</span>]);</span><br><span class="line">                grid[i][j] = tmp == <span class="number">0x3f3f3f3f</span> ? grid[i][j] : tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.<span class="built_in">size</span>() - <span class="number">1</span>][grid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="unique-paths-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/unique-paths-ii/">63.Unique Paths
II</a></h3>
<p>递推</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector &amp;obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; obstacleGrid.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>(); j ++) &#123; <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>) &#123; obstacleGrid[i][j] = <span class="number">0</span>; <span class="keyword">continue</span>; &#125; <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                    obstacleGrid[i][j] += obstacleGrid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                    obstacleGrid[i][j] += obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[obstacleGrid.<span class="built_in">size</span>() - <span class="number">1</span>][obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="unique-paths"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/unique-paths/">62.Unique
Paths</a></h3>
<p>这是当年学组合数时候的经典题型吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">COM</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b = <span class="built_in">min</span>(b, a - b);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>, i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = a, j = <span class="number">1</span>; i &gt; a - b; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            ret *= i;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt;= b &amp;&amp; ret % j == <span class="number">0</span>; j ++)</span><br><span class="line">                ret /= j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">COM</span>(m + n - <span class="number">2</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-list"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/rotate-list/">61.Rotate
List</a></h3>
<p>因为k可能比长度大，需要求长度然后k对长度取模。那么就不要矫情地追求双指针一遍扫描了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        ListNode *en, *p;</span><br><span class="line">        <span class="keyword">for</span>(cnt = <span class="number">1</span>, en = head; en-&gt;next != <span class="literal">NULL</span>; cnt ++, en = en-&gt;next);</span><br><span class="line">        k %= cnt;</span><br><span class="line">        <span class="keyword">for</span>(p = head, cnt --; cnt != k; cnt --, p = p-&gt;next);</span><br><span class="line">        en-&gt;next = head;</span><br><span class="line">        en = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> en;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="permutation-sequence"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/permutation-sequence/">60.Permutation
Sequence</a></h3>
<p>一位一位算，每一位优先没使用过的较小的数字，而其后剩下的m个位置有 m!
种排列方法，用 k
减去，直到k不大于这个方法数，则这一位就是枚举到的这个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> permu[<span class="number">10</span>];</span><br><span class="line">    <span class="type">bool</span> vis[<span class="number">10</span>];</span><br><span class="line">    <span class="function">string <span class="title">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        permu[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++) permu[i] = permu[i - <span class="number">1</span>] * i;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123; <span class="keyword">if</span>(!vis[j]) &#123; <span class="keyword">if</span>(k &gt; permu[n - i])</span><br><span class="line">                        k -= permu[n - i];</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        ans += <span class="string">&#x27;0&#x27;</span> + j;</span><br><span class="line">                        vis[j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="spiral-matrix-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/spiral-matrix-ii/">59.Spiral
Matrix II</a></h3>
<p>直接算每个位置的数是多少有木有很霸气→_→。
先看当前位置之外有几个嵌套的正方形，再看当前位置在当前正方形四条边的第几条，求出坐标(x,y)位置的数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    vector nsq;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calnum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> num, tmp;</span><br><span class="line">        tmp = <span class="built_in">min</span>(<span class="built_in">min</span>(i, j), <span class="built_in">min</span>(n - <span class="number">1</span> - i, n - <span class="number">1</span> - j));</span><br><span class="line">        num = nsq[tmp];</span><br><span class="line">        <span class="keyword">if</span>(i == tmp) <span class="keyword">return</span> num + j - tmp + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n - j - <span class="number">1</span> == tmp) <span class="keyword">return</span> num + n - <span class="number">2</span> * tmp + i - tmp;</span><br><span class="line">        <span class="keyword">if</span>(n - i - <span class="number">1</span> == tmp) <span class="keyword">return</span> num + <span class="number">2</span> * (n - <span class="number">2</span> * tmp) - <span class="number">2</span> + n - j - tmp;</span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">3</span> * (n - <span class="number">2</span> * tmp) - <span class="number">3</span> + n - i - tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">generateMatrix</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        nsq.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>) nsq.<span class="built_in">push_back</span>(<span class="number">4</span> * i - <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nsq.<span class="built_in">size</span>(); i ++) nsq[i] += nsq[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(<span class="built_in">calnum</span>(i, j, n));</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="length-of-last-word"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/length-of-last-word/">58.Length of
Last Word</a></h3>
<p>从后往前找。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="built_in">strlen</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>; i --);</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>; j --);</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">0</span> ? <span class="number">0</span> : i - j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="insert-interval"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/insert-interval/">57.Insert
Interval</a></h3>
<p>end 比 newInterval 的 start 小的 intervals 直接插入，从 end 比
newInterval 的 start 大的 intervals 开始，到 start 比 newInterval 的 end
大的 intervals 结束，对这部分区间合并，再把之后的
intervals直接插入，特判 newInterval 最小和最大两种极端情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function">vector <span class="title">insert</span><span class="params">(vector &amp;intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; newInterval.start &gt; intervals[i].end; i ++)</span><br><span class="line">            res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; intervals.<span class="built_in">size</span>() &amp;&amp; newInterval.end &gt;= intervals[j].start; j ++);</span><br><span class="line">        <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; i != intervals.<span class="built_in">size</span>())</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">Interval</span>(<span class="built_in">min</span>(intervals[i].start, newInterval.start),</span><br><span class="line">                                <span class="built_in">max</span>(intervals[j - <span class="number">1</span>].end, newInterval.end)));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; intervals.<span class="built_in">size</span>(); j ++)</span><br><span class="line">            res.<span class="built_in">push_back</span>(intervals[j]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="merge-intervals"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/merge-intervals/">56.Merge
Intervals</a></h3>
<p>先按start排个序，然后慢慢合并。。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cxompp</span><span class="params">(<span class="type">const</span> Interval &amp;a, <span class="type">const</span> Interval &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;</span><br><span class="line">    <span class="function">vector <span class="title">merge</span><span class="params">(vector &amp;intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cxompp);</span><br><span class="line">        Interval last = intervals[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i ++) &#123; <span class="keyword">if</span>(last.end &gt;= intervals[i].start)</span><br><span class="line">                last.end = <span class="built_in">max</span>(last.end, intervals[i].end);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(last), last = intervals[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(last);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="jump-game"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/jump-game/">55.Jump Game</a></h3>
<p>维护最大可跳距离，每个位置都枚举一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i, jumpdis;</span><br><span class="line">        <span class="keyword">for</span>(i = jumpdis = <span class="number">0</span>; i &lt; n &amp;&amp; jumpdis &gt;= <span class="number">0</span>; i ++, jumpdis --)</span><br><span class="line">            jumpdis = <span class="built_in">max</span>(A[i], jumpdis);</span><br><span class="line">        <span class="keyword">return</span> i == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="spiral-matrix"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/spiral-matrix/">54.Spiral
Matrix</a></h3>
<p>模拟转一遍吧。写了俩代码，差不多，处理拐弯的方式略有不同。</p>
<p>代码一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">JudgeValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y,</span></span></span><br><span class="line"><span class="params"><span class="function">        vector &amp;vis, vector &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; matrix.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; </span><br><span class="line">           vis[x][y] == <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">spiralOrder</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dir, x, y, nx, ny;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector <span class="title">vis</span><span class="params">(matrix.size(), vector(matrix[<span class="number">0</span>].size(), <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(dir = x = y = <span class="number">0</span>; <span class="built_in">JudgeValid</span>(x, y, vis, matrix); x = nx, y = ny)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">            nx = x + dx[dir];</span><br><span class="line">            ny = y + dy[dir];</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">JudgeValid</span>(nx, ny, vis, matrix))</span><br><span class="line">            &#123;</span><br><span class="line">                dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                nx = x + dx[dir];</span><br><span class="line">                ny = y + dy[dir];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function">vector <span class="title">spiralOrder</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dir, x, y, nx, ny;</span><br><span class="line">        <span class="type">int</span> l, r, u, d;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        l = u = <span class="number">-1</span>;</span><br><span class="line">        r = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        d = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(dir = x = y = <span class="number">0</span>; res.<span class="built_in">size</span>() &lt; matrix.<span class="built_in">size</span>() * matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            x = nx, y = ny)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            nx = x + dx[dir];</span><br><span class="line">            ny = y + dy[dir];</span><br><span class="line">            <span class="keyword">if</span>(nx == d || nx == u || ny == r || ny == l)</span><br><span class="line">            &#123;</span><br><span class="line">                dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span>(dir == <span class="number">0</span>) l ++, r --, d --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dir == <span class="number">3</span>) u ++;</span><br><span class="line">                nx = x + dx[dir];</span><br><span class="line">                ny = y + dy[dir];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="maximum-subarray"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/maximum-subarray/">53.Maximum
Subarray</a></h3>
<p>最大子串和，子串要求至少包含一个数字。</p>
<p>一个变量 sum 表示当前求得的子串和，当 sum
小于0时，对后面的子串没有贡献，则把 sum
置零，中间处理一下要求至少包含一个数字的要求即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = A[<span class="number">0</span>], sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">                sum = <span class="number">0</span>, ans = <span class="built_in">max</span>(ans, A[i]);</span><br><span class="line">            <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="n-queens-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/n-queens-ii/">52.N-Queens
II</a></h3>
<p>题目没说 n 的取值范围，就不用 位运算 做标记了。</p>
<p>老老实实开三个 bool
数组，一个标记纵列，另外两个标记两个斜列，一行一行DFS。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector col, lc, rc;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans ++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!col[i] &amp;&amp; !lc[n - cur - <span class="number">1</span> + i] &amp;&amp; !rc[cur + i])</span><br><span class="line">            &#123;</span><br><span class="line">                col[i] = lc[n - cur - <span class="number">1</span> + i] = rc[cur + i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">DFS</span>(cur + <span class="number">1</span>, n);</span><br><span class="line">                col[i] = lc[n - cur - <span class="number">1</span> + i] = rc[cur + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        col.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        lc.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        rc.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="n-queens"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/n-queens/">51.N-Queens</a></h3>
<p>同上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector tmp;</span><br><span class="line">    vector res;</span><br><span class="line">    vector col, lc, rc;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == n)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">now</span><span class="params">(n, <span class="string">&#x27;.&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!col[i] &amp;&amp; !lc[n - cur - <span class="number">1</span> + i] &amp;&amp; !rc[cur + i])</span><br><span class="line">            &#123;</span><br><span class="line">                col[i] = lc[n - cur - <span class="number">1</span> + i] = rc[cur + i] = <span class="literal">true</span>;</span><br><span class="line">                now[i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(now);</span><br><span class="line">                <span class="built_in">DFS</span>(cur + <span class="number">1</span>, n);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                now[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                col[i] = lc[n - cur - <span class="number">1</span> + i] = rc[cur + i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        col.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        lc.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        rc.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="powx-n"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/powx-n/">50.Pow(x, n)</a></h3>
<p>很多人用特判错过了 <code>n=-2147483648</code> 这么优美的
trick，而不特判的话，似乎只能 long long 了。</p>
<p>经典的快速幂，用二进制理解也好，用折半理解也好，网上很多资料。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> nn = n;</span><br><span class="line">        <span class="keyword">if</span>(nn &lt; <span class="number">0</span>) x = <span class="number">1</span> / x, nn = -nn; <span class="keyword">while</span>(nn) &#123; <span class="keyword">if</span>(nn &amp; <span class="number">1</span>) res *= x; x *= x; nn &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="anagrams"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/anagrams/">49.Anagrams</a></h3>
<p>这概念以前没听过诶。。题也没看到样例，不知道以后会不会更新，网上查了才明白啥意思。</p>
<p>调换单词字母顺序能一致的单词集合全放进答案。比如有tea, eat,
aet，就都要放进答案，有cat,
atc，就都要放进答案，而如果孤零零有个dog，没其他可和他一组的，那么就不放进答案。</p>
<p>手写hash能更快些，但是题目没给数据范围，给hash数组定多大都没合理性，干脆用unordered_map好了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function">vector <span class="title">anagrams</span><span class="params">(vector &amp;strs)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp = strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(tmp)) mp[tmp] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[tmp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i ++) &#123; string tmp = strs[i]; <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>()); <span class="keyword">if</span>(mp.<span class="built_in">count</span>(tmp) &amp;&amp; mp[tmp] &gt; <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="rotate-image"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/rotate-image/">48.Rotate
Image</a></h3>
<p>四个一组，就地旋转。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> len = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> lenlimi = len + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenlimi; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; (len &amp; <span class="number">1</span> ? lenlimi - <span class="number">1</span> : lenlimi); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[len - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[len - j - <span class="number">1</span>][i] = matrix[len - i - <span class="number">1</span>][len - j - <span class="number">1</span>];</span><br><span class="line">                matrix[len - i - <span class="number">1</span>][len - j - <span class="number">1</span>] = matrix[j][len - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][len - i - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="permutations-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/permutations-ii/">47.Permutations
II</a></h3>
<p>有重复数字，把数字统计起来好了。因为题目没说数字大小，所以统计用了unordered_map。</p>
<p>也可以把数组排序，DFS时跳过重复的数字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    vector tmp;</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="type">int</span> numsize;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == numsize)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(it-&gt;first);</span><br><span class="line">                it-&gt;second --;</span><br><span class="line">                <span class="built_in">DFS</span>(cnt + <span class="number">1</span>);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                it-&gt;second ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">permute</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        numsize = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(num[i])) mp[num[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[num[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="permutations"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/permutations/">46.Permutations</a></h3>
<p>虽然题目没说有没有重复数字。。既然 Permutations II
说有了，那就当这个没有吧。</p>
<p>传统DFS。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, vector &amp;num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == num.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = cur; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(num[cur], num[i]);</span><br><span class="line">            <span class="built_in">DFS</span>(cur + <span class="number">1</span>, num);</span><br><span class="line">            <span class="built_in">swap</span>(num[cur], num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">permute</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, num);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="jump-game-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/jump-game-ii/">45.Jump Game
II</a></h3>
<p>维护一步最远到达的位置，到达这个位置之前的位置需要的步数都是一样的，到达这个位置的时候，下一步的最远位置已经更新完毕。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nex = <span class="number">0</span>, pace = <span class="number">0</span>, far = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nex &amp;&amp; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            far = <span class="built_in">max</span>(far, A[i] + i);</span><br><span class="line">            <span class="keyword">if</span>(i == nex)</span><br><span class="line">            &#123;</span><br><span class="line">                pace ++;</span><br><span class="line">                nex = far;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="wildcard-matching"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/wildcard-matching/">44.Wildcard
Matching</a></h3>
<p>同步扫描两个字符串，每当 p 遇到 <code>*</code>
，记录s和p的当前扫描位置，当 s 与 p 不匹配时，跑扫描指针回到
<code>*</code> 后一个字符， s 扫描指针回到上次遇到 <code>*</code> 之后与
p 开始匹配位置的下一个位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> last_star = <span class="number">-1</span>, last_s = <span class="number">-1</span>, i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">0</span>; s[i]; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) i ++, j ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">&#x27;*&#x27;</span>) last_star = ++ j, last_s = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(last_star != <span class="number">-1</span>) i = ++ last_s, j = last_star;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p[j] == <span class="string">&#x27;*&#x27;</span>) j ++;</span><br><span class="line">        <span class="keyword">return</span> !s[i] &amp;&amp; !p[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="multiply-strings"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/multiply-strings/">43.Multiply
Strings</a></h3>
<p>翻转num1和num2，大整数乘法，把结果再翻转。注意 int 和 char
的转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="function">string <span class="title">ans</span><span class="params">(num<span class="number">1.l</span>ength() + num<span class="number">2.l</span>ength() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">1.</span><span class="built_in">begin</span>(), num<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">2.</span><span class="built_in">begin</span>(), num<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>, i, j, k;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num<span class="number">1.l</span>ength(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; num<span class="number">2.l</span>ength(); j ++) &#123; ans[i + j] += cur + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>); cur = ans[i + j] / <span class="number">10</span>; ans[i + j] %= <span class="number">10</span>; &#125; <span class="keyword">for</span>(k = i + j; cur; k ++) &#123; ans[k] += cur; cur = ans[k] / <span class="number">10</span>; ans[k] %= <span class="number">10</span>; &#125; &#125; <span class="keyword">for</span>(k = ans.<span class="built_in">length</span>() - <span class="number">1</span>; k &gt; <span class="number">0</span> &amp;&amp; ans[k] == <span class="number">0</span>; k --);</span><br><span class="line">        ans.<span class="built_in">resize</span>(k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            ans[i] += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="trapping-rain-water"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/trapping-rain-water/">42.Trapping
Rain Water</a></h3>
<p>对于每个位置，取这个位置<code>左边最高的</code>和<code>右边最高的</code>的较低者，如果<code>较低者</code>比这个位置高，则这个位置存水高度为<code>较低者</code>减该位置高度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector pre;</span><br><span class="line">        <span class="type">int</span> i, maxheight, ans;</span><br><span class="line">        <span class="keyword">for</span>(i = maxheight = <span class="number">0</span>; i &lt; n; i ++) &#123; maxheight = <span class="built_in">max</span>(A[i], maxheight); pre.<span class="built_in">push_back</span>(maxheight); &#125; <span class="keyword">for</span>(maxheight = ans = <span class="number">0</span>, i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            maxheight = <span class="built_in">max</span>(A[i], maxheight);</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(pre[i] - A[i], maxheight - A[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="first-missing-positive"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/first-missing-positive/">41.First
Missing Positive</a></h3>
<p>题目要求时间O(n)，空间O(1)，经分析，不得不破坏原数组 A。</p>
<p>方法一：</p>
<p>剔除非整数，把原数组 A 当作存在标记，存在的数 x 则 A[x-1]取负数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">0</span>; i &lt; n; i ++) <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>)</span><br><span class="line">                A[j ++] = A[i];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; j; i ++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(A[i]) &lt;= j)</span><br><span class="line">                A[<span class="built_in">abs</span>(A[i]) - <span class="number">1</span>] = -<span class="built_in">abs</span>(A[<span class="built_in">abs</span>(A[i]) - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; j; i ++) <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：把出现的符合范围的数swap到下标和数对应的位置，再次遍历，数和下标不对应则是第一个没出现的数。注意处理有重复数字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">while</span>(A[i] &lt;= n &amp;&amp; A[i] &gt; <span class="number">0</span> &amp;&amp; A[i] != i + <span class="number">1</span> &amp;&amp; A[A[i] - <span class="number">1</span>] != A[i])</span><br><span class="line">                <span class="built_in">swap</span>(A[i], A[A[i] - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="combination-sum"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/combination-sum/">40.Combination
Sum</a></h3>
<p>基础DFS</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector tmp;</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector &amp;num, <span class="type">int</span> ith, <span class="type">int</span> now, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ith == num.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(now &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(num, ith + <span class="number">1</span>, now, target);</span><br><span class="line">            now += num[ith];</span><br><span class="line">            cnt ++;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(num[ith]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cnt --) tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">combinationSum</span><span class="params">(vector &amp;candidates, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">DFS</span>(candidates, <span class="number">0</span>, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="combination-sum-ii"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/combination-sum-ii/">39.Combination
Sum II</a></h3>
<p>如果一个数没有被用，那么后面重复的这个数就别用，避免重复解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector tmp;</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(vector &amp;num, <span class="type">int</span> ith, <span class="type">int</span> now, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == target)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ith == num.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> nex;</span><br><span class="line">        <span class="keyword">for</span>(nex = ith + <span class="number">1</span>; nex &lt; num.<span class="built_in">size</span>() &amp;&amp; num[nex] == num[ith]; nex ++);</span><br><span class="line">        <span class="built_in">DFS</span>(num, nex, now, target);</span><br><span class="line">        <span class="keyword">if</span>(num[ith] + now &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            now += num[ith];</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(num[ith]);</span><br><span class="line">            <span class="built_in">DFS</span>(num, ith + <span class="number">1</span>, now, target);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">combinationSum2</span><span class="params">(vector &amp;num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">DFS</span>(num, <span class="number">0</span>, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="count-and-say"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/count-and-say/">38.Count and
Say</a></h3>
<p>直接模拟，递推。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string f[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i &amp; <span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; f[i &amp; <span class="number">1</span> ^ <span class="number">1</span>].<span class="built_in">length</span>();)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cnt;</span><br><span class="line">                <span class="type">char</span> x = f[i &amp; <span class="number">1</span> ^ <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span>(cnt = <span class="number">0</span>; j &lt; f[i &amp; <span class="number">1</span> ^ <span class="number">1</span>].<span class="built_in">length</span>() &amp;&amp; f[i &amp; <span class="number">1</span> ^ <span class="number">1</span>][j] == x; cnt ++, j ++);</span><br><span class="line">                f[i &amp; <span class="number">1</span>] += <span class="string">&#x27;0&#x27;</span> + cnt;</span><br><span class="line">                f[i &amp; <span class="number">1</span>] += x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n &amp; <span class="number">1</span> ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sudoku-solver"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/sudoku-solver/">37.Sudoku
Solver</a></h3>
<p>这道题考察回溯和数独结果的判断。ACM做过，就直接拿dancing
links代码了，4ms。</p>
<p>关于dancing links，对于面试题来说变态了些，应该不至于考察。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> rw[<span class="number">10</span>], cl[<span class="number">10</span>], in[<span class="number">10</span>], RW[<span class="number">81</span>], CL[<span class="number">81</span>], IN[<span class="number">81</span>], goal;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Mark</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rw[RW[i]] ^= <span class="number">1</span> &lt;&lt; num;</span><br><span class="line">        cl[CL[i]] ^= <span class="number">1</span> &lt;&lt; num;</span><br><span class="line">        in[IN[i]] ^= <span class="number">1</span> &lt;&lt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i)</span><br><span class="line">            cl[i] = rw[i] = in[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = goal = <span class="number">0</span>; buf[i]; ++ i)</span><br><span class="line">            goal += buf[i] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">81</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            RW[i] = i / <span class="number">9</span>, CL[i] = i % <span class="number">9</span>, IN[i] = i / <span class="number">3</span> % <span class="number">3</span> + i / <span class="number">27</span> * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(buf[i] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="built_in">Mark</span>(i, buf[i] - <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Judge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> ~(rw[RW[i]] | cl[CL[i]] | in[IN[i]]) &amp; (<span class="number">1</span> &lt;&lt; num);&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Oper</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> k, <span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Mark</span>(sx, k), buf[sx] = k + <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(cur + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Mark</span>(sx, k), buf[sx] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">JudgeRWCLIN</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j, k, x, cnt, sx;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++ i)</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++ k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(~rw[i] &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(j = cnt = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = i * <span class="number">9</span> + j;</span><br><span class="line">                        <span class="keyword">if</span>(buf[x] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; <span class="built_in">Judge</span>(x, k)) ++ cnt, sx = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">Oper</span>(sx, k, cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(~cl[i] &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(j = cnt = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = j * <span class="number">9</span> + i;</span><br><span class="line">                        <span class="keyword">if</span>(buf[x] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; <span class="built_in">Judge</span>(x, k)) ++ cnt, sx = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">Oper</span>(sx, k, cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(~in[i] &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(j = cnt = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = i / <span class="number">3</span> * <span class="number">27</span> + j / <span class="number">3</span> * <span class="number">9</span> + i % <span class="number">3</span> * <span class="number">3</span> + j % <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">if</span>(buf[x] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; <span class="built_in">Judge</span>(x, k)) ++ cnt, sx = x;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">Oper</span>(sx, k, cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j, num, cnt;</span><br><span class="line">        <span class="keyword">if</span>(cur == goal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">81</span>; ++ i)</span><br><span class="line">            <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j = cnt = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">Judge</span>(i, j)) ++ cnt, num = j;</span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">Oper</span>(i, num, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>((num = <span class="built_in">JudgeRWCLIN</span>(cur)) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">81</span>; ++ i)</span><br><span class="line">            <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++ j)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">Judge</span>(i, j))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">Mark</span>(i, j), buf[i] = j + <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">dfs</span>(cur + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">Mark</span>(i, j), buf[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> site = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++)</span><br><span class="line">                buf[site ++] = board[i][j];</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        site = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++)</span><br><span class="line">                board[i][j] = buf[site ++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="valid-sudoku"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/valid-sudoku/">36.Valid
Sudoku</a></h3>
<p>行列九宫格都判断一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag[<span class="number">3</span>][<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="literal">false</span>, <span class="built_in">sizeof</span>(flag));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> x = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(flag[<span class="number">0</span>][i][x] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    flag[<span class="number">0</span>][i][x] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(flag[<span class="number">1</span>][j][x] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    flag[<span class="number">1</span>][j][x] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(flag[<span class="number">2</span>][i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>][x] == <span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    flag[<span class="number">2</span>][i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-insert-position"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/search-insert-position/">35.Search
Insert Position</a></h3>
<p>二分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid;</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = n; left &lt; right; ) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-for-a-range"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/search-for-a-range/">34.Search for
a Range</a></h3>
<p>二分，容易错。可以用lower_bound和upper_bound。</p>
<p>手工代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">searchRange</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left, right, mid, l, r;</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = n; left &lt; right; ) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt;= target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l = left;</span><br><span class="line">        <span class="keyword">for</span>(left = <span class="number">0</span>, right = n; left &lt; right; ) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; target) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= n || A[l] != target) <span class="keyword">return</span> <span class="built_in">vector</span>(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        vector ans = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>STL：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">searchRange</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">lower_bound</span>(A, A + n, target) - A;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">upper_bound</span>(A, A + n, target) - A;</span><br><span class="line">        <span class="keyword">if</span>(l == n || A[l] != target) <span class="keyword">return</span> <span class="built_in">vector</span>(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        vector ans = &#123;l, r - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="search-in-rotated-sorted-array"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/search-in-rotated-sorted-array/">33.Search
in Rotated Sorted Array</a></h3>
<p>还是二分，但是要判断一下 mid 在哪部分里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123; mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt;= A[left])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; A[mid] &amp;&amp; A[left] &lt;= target) right = mid;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt;= A[right] &amp;&amp; A[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-valid-parentheses"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/longest-valid-parentheses/">32.Longest
Valid Parentheses</a></h3>
<p>这道题时间限制在<code>O(n)</code>，用一个 stack 实现括号配对+统计,
为了方便实现，写成数组的形式。</p>
<p>对不同深度的括号配对统计个数，一层配对成功把该层统计结果加给上一层，这一层清空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">cnt</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i, ans;</span><br><span class="line">        <span class="keyword">for</span>(i = ans = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123; <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) cnt.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="keyword">else</span> &#123; <span class="keyword">if</span>(cnt.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt[cnt.<span class="built_in">size</span>() - <span class="number">2</span>] += *cnt.<span class="built_in">rbegin</span>() + <span class="number">2</span>;</span><br><span class="line">                    cnt.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, *cnt.<span class="built_in">rbegin</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="next-permutation"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/next-permutation/">31.Next
Permutation</a></h3>
<p>从后往前找到第一个非降序的
<code>num[i]</code>，再重新从后往前找到第一个比 <code>num[i]</code>
大的，<code>swap(num[i], num[j])</code>，再把 <code>i</code>
之后的排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = num.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span> &amp;&amp; num[i] &gt;= num[i + <span class="number">1</span>]; i --);</span><br><span class="line">        <span class="keyword">for</span>(j = num.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i &amp;&amp; num[j] &lt;= num[i]; j --);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(num[i], num[j]);</span><br><span class="line">            <span class="built_in">sort</span>(num.<span class="built_in">begin</span>() + i + <span class="number">1</span>, num.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">reverse</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="substring-with-concatenation-of-all-words"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/">30.Substring
with Concatenation of All Words</a></h3>
<p>直观的方法是枚举起点，判断这个起点下的子串是否合法，<code>O(S.length()*L.size())</code>。</p>
<p>其实可以把 S 分成 <code>L[0].length()</code>
个序列，每个序列都是元素间相隔 <code>L[0].length()</code>
的(string开头)，这些序列互不相干。</p>
<p>如下表，假设
<code>L[0].length()=4</code>，第一行数字为分组组号，第二行数字表示 S
的序号。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(0)|(1)|(2)|(3)|(0)|(1)|(2)|(3)|(0)|(1)|(2)|(3)|(0)|(1)|(2)|(3)|(0)|(1)|(2)|(3)|(0)|</span><br><span class="line"> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| 14| 15| 16| 17| 18| 19| 20|</span><br></pre></td></tr></table></figure>
对每个序列，用单调队列的思路来处理，一个一个子串入队，当包含了 L 中所有
string 的时候，保存答案。当新元素入队时超出统计允许时————即 L 中有 3 个
"str", 而这时候遇到第 4 个————则开始出队，一直出到队列里不足 3 个
"str"，然后继续。</p>
<p>这样复杂度为<code>O(L[0].length() * S.length() / L[0].length()) = O(S.length())</code>。目前提交结果是180ms。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">findSubstring</span><span class="params">(string S, vector &amp;L)</span> </span>&#123;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="keyword">if</span>(L.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; mp, sum;</span><br><span class="line">        <span class="type">int</span> llen = L[<span class="number">0</span>].<span class="built_in">length</span>(), i, front, rear;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(L[i])) mp[L[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[L[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; llen; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = mp;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(front = rear = i; front + llen &lt;= S.<span class="built_in">length</span>(); front += llen) &#123; </span><br><span class="line">               string tmp = S.<span class="built_in">substr</span>(front, llen); </span><br><span class="line">               <span class="keyword">if</span>(sum.<span class="built_in">count</span>(tmp)) </span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="keyword">if</span>(sum[tmp] &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum[tmp] --;</span><br><span class="line">                        cnt ++;</span><br><span class="line">                        <span class="keyword">if</span>(cnt == L.<span class="built_in">size</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans.<span class="built_in">push_back</span>(rear);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">while</span>(sum[tmp] == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            string ntmp = S.<span class="built_in">substr</span>(rear, llen);</span><br><span class="line">                            sum[ntmp] ++;</span><br><span class="line">                            cnt --;</span><br><span class="line">                            rear += llen;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sum[tmp] --;</span><br><span class="line">                        cnt ++;</span><br><span class="line">                        <span class="keyword">if</span>(cnt == L.<span class="built_in">size</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans.<span class="built_in">push_back</span>(rear);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(rear &lt; front)</span><br><span class="line">                    &#123;</span><br><span class="line">                        string ntmp = S.<span class="built_in">substr</span>(rear, llen);</span><br><span class="line">                        sum[ntmp] ++;</span><br><span class="line">                        cnt --;</span><br><span class="line">                        rear += llen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rear += llen;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="divide-two-integers"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/divide-two-integers/">29.Divide
Two Integers</a></h3>
<p>假设 dividend 与 divisor 正负一致， <code>divisor^(2^n)</code>
为最接近 dividend 的 divisor 的幂，那么令
<code>newdividend = dividend - divisor^(2^n)</code>，<code>ans = ans + 2^n</code>，问题就更新为
newdividend 除以 divisor，如此迭代。用 divisor<sup>(2</sup>n) 是因为
divisor 不停地辗转加自己就可以得到了。</p>
<p>有 <code>-2147483648</code> 这样的极限数据，因为 int 范围是
<code>-2147483648~+2147483647</code>，发现负数比正数范围(多1)，干脆把所有数都转成负数算，这样就避免用
long long 了。最后考察一下flag。</p>
<p>（如果转成正数的话，int 的 -(-2147483648)还是 -2147483648。。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor &gt; <span class="number">0</span>) divisor = -divisor, flag ^= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dividend &gt; <span class="number">0</span>) dividend = -dividend, flag ^= <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, res = divisor, ex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor &lt; dividend) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">while</span>(res &gt;= dividend - res)</span><br><span class="line">        &#123;</span><br><span class="line">            res += res;</span><br><span class="line">            ex += ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res &lt;= divisor &amp;&amp; dividend) &#123; <span class="keyword">if</span>(res &gt;= dividend)</span><br><span class="line">            &#123;</span><br><span class="line">                dividend -= res;</span><br><span class="line">                ans += ex;</span><br><span class="line">            &#125;</span><br><span class="line">            res &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ex &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="implement-strstr"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/implement-strstr/">28.Implement
strStr()</a></h3>
<p>KMP。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">strStr</span><span class="params">(<span class="type">char</span> *haystack, <span class="type">char</span> *needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hlen = (<span class="type">int</span>)<span class="built_in">strlen</span>(haystack), nlen = (<span class="type">int</span>)<span class="built_in">strlen</span>(needle);</span><br><span class="line">        <span class="keyword">if</span>(nlen == <span class="number">0</span>) <span class="keyword">return</span> haystack;</span><br><span class="line">        <span class="function">vector <span class="title">next</span><span class="params">(nlen + <span class="number">1</span>)</span></span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; nlen;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || needle[i] == needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i ++, j ++;</span><br><span class="line">                <span class="keyword">if</span>(needle[i] != needle[j]) next[i] = j;</span><br><span class="line">                <span class="keyword">else</span> next[i] = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; hlen;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || haystack[i] == needle[j])</span><br><span class="line">                i ++, j ++;</span><br><span class="line">            <span class="keyword">else</span> j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(j == nlen) <span class="keyword">return</span> haystack + i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-element"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/remove-element/">27.Remove
Element</a></h3>
<p>两个游标 i, j 异步挪动，把不等于给定值的数往前挪。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> elem)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] != elem) A[j ++] = A[i];</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-duplicates-from-sorted-array"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/">26.Remove
Duplicates from Sorted Array</a></h3>
<p>两个游标 i, j 异步挪动，不重复值往前挪。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] != A[i - <span class="number">1</span>]) A[j ++] = A[i];</span><br><span class="line">        <span class="keyword">return</span> n ? j : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-nodes-in-k-group"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/reverse-nodes-in-k-group/">25.Reverse
Nodes in k-Group</a></h3>
<p>用头插法来做的，顺序插入到首节点之后，就反转了。每 k
个节点处理之后，把首节指针点移动到下 k 个的开头。最后面不足 k
个的话，再反转回来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Reverse</span><span class="params">(ListNode *&amp;pre, ListNode *&amp;p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        ListNode *nex, *tmp;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; p != <span class="literal">NULL</span>; i ++, p = tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) nex = p;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="keyword">if</span>(i == k) i = <span class="number">0</span>, pre = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        nex-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *tmphead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *pre = tmphead, *p = head;</span><br><span class="line">        tmphead-&gt;next = head;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Reverse</span>(pre, p, k) != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            <span class="built_in">Reverse</span>(pre, p, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="swap-nodes-in-pairs"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/swap-nodes-in-pairs/">24.Swap
Nodes in Pairs</a></h3>
<p>Reverse Nodes in k-Group的简化版。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">swapPairs</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *tmphead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *pre = tmphead, *p = head, *tmp, *nex;</span><br><span class="line">        tmphead-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; p != <span class="literal">NULL</span>; i ++, p = tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span> ^ <span class="number">1</span>) nex = p;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>) pre = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        nex-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> tmphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="merge-k-sorted-lists"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/merge-k-sorted-lists/">23.Merge k
Sorted Lists</a></h3>
<p>一个堆（这里用了优先级队列），把所有 list
的首元素放堆里，O(logn)取得最小值插入新队列，异步推进。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">comp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(vector &amp;lists)</span> </span>&#123;</span><br><span class="line">        ListNode *tmphead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = tmphead;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, comp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); i ++) <span class="keyword">if</span>(lists[i] != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(lists[i]); <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123; p-&gt;next = q.<span class="built_in">top</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p -&gt;next != <span class="literal">NULL</span>) q.<span class="built_in">push</span>(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="generate-parentheses"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/generate-parentheses/">22.Generate
Parentheses</a></h3>
<p>DFS，保持当前右括号不多于左括号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string tmp;</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right &amp;&amp; left == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[left + right] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(left + <span class="number">1</span>, right, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[left + right] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(left, right + <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="merge-two-sorted-lists"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/merge-two-sorted-lists/">21.Merge
Two Sorted Lists</a></h3>
<p>归并排序的一次操作，设个哨兵头结点，结束后free。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *thead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = thead;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) p-&gt;next = l1, p = l1, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p-&gt;next = l2, p = l2, l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span>) p-&gt;next = l1, p = l1, l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">NULL</span>) p-&gt;next = l2, p = l2, l2 = l2-&gt;next;</span><br><span class="line">        p = thead-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(thead);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="valid-parentheses"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/valid-parentheses/">20.Valid
Parentheses</a></h3>
<p>用栈配对。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: st.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: st.<span class="built_in">push</span>(<span class="string">&#x27;[&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: st.<span class="built_in">push</span>(<span class="string">&#x27;&#123;&#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    st.<span class="built_in">pop</span>(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    st.<span class="built_in">pop</span>(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    st.<span class="built_in">pop</span>(); <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="remove-nth-node-from-end-of-list"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">19.Remove
Nth Node From End of List</a></h3>
<p>两个指针相隔 n
距离，前面的指针到了末尾，后面的指针就是删除的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *pre, *slow, *quick;</span><br><span class="line">        ListNode *newhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        newhead-&gt;next = head;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(pre = slow = quick = newhead; quick != <span class="literal">NULL</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= n) slow = slow-&gt;next;</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = slow-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(slow);</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sum"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/4sum/">18.4Sum</a></h3>
<p>尝试了<code>O(n^2)</code>的，但是应该常数很大吧，超时了。就是哈希存两两的和，然后通过查哈希表找到
两两+两两，要判断数字重复情况。这题数据量挺大的，<code>O(n^3)</code>如果用不太好的方式实现的话也会超。</p>
<p><code>O(n^3)</code>方法：先对num排序，然后从两头枚举两个数，<code>O(n^2)</code>，后两个数在前两个数之间的两端开始，和小了左边的往右，和大了右边的往左调整，<code>O(n)</code>，总共<code>O(n^3)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">fourSum</span><span class="params">(vector &amp;num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>() &lt; <span class="number">4</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left = <span class="number">0</span>; left &lt; num.<span class="built_in">size</span>() - <span class="number">3</span>;) &#123; <span class="keyword">for</span>(<span class="type">int</span> right = num.<span class="built_in">size</span>() - <span class="number">1</span>; right &gt; left + <span class="number">2</span>;) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> ml = left + <span class="number">1</span>, mr = right - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(ml &lt; mr) </span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="type">int</span> tmpsum = num[left] + num[right] + num[ml] + num[mr]; </span><br><span class="line">                    <span class="keyword">if</span>(tmpsum &gt; target) mr --;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &lt; target) ml ++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        vector tmp = &#123;num[left], num[ml], num[mr], num[right]&#125;;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                        ml ++;</span><br><span class="line">                        mr --;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(; ml != left + <span class="number">1</span> &amp;&amp; ml &lt; mr &amp;&amp; num[ml] == num[ml - <span class="number">1</span>]; ml ++);</span><br><span class="line">                    <span class="keyword">for</span>(; mr != right - <span class="number">1</span> &amp;&amp; ml &lt; mr &amp;&amp; num[mr] == num[mr + <span class="number">1</span>]; mr --); </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">for</span>(right --; right &gt; left + <span class="number">2</span> &amp;&amp; num[right] == num[right + <span class="number">1</span>]; right --);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(left ++; left &lt; num.<span class="built_in">size</span>() - <span class="number">3</span> &amp;&amp; num[left] == num[left - <span class="number">1</span>]; left ++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="letter-combinations-of-a-phone-number"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/">17.Letter
Combinations of a Phone Number</a></h3>
<p>基础DFS。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> vector v = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    vector ans;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> cur, string d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == d.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[d[cur] - <span class="string">&#x27;0&#x27;</span>].<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[cur] = v[d[cur] - <span class="string">&#x27;0&#x27;</span>][i];</span><br><span class="line">            <span class="built_in">DFS</span>(cur + <span class="number">1</span>, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">resize</span>(digits.<span class="built_in">length</span>());</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sum-closest"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/3sum-closest/">16.3Sum
Closest</a></h3>
<p><code>O(n^2)</code>，先排序，枚举第一个数，后两个数一个在第一个数后边一个开始，一个从
末尾开始，和4Sum类似调整。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector &amp;num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> findans = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> left = i + <span class="number">1</span>, right = num.<span class="built_in">size</span>() - <span class="number">1</span>; left &lt; right;) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="type">int</span> tmpsum = num[i] + num[left] + num[right]; </span><br><span class="line">                <span class="keyword">if</span>(tmpsum &gt; target) right --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &lt; target) left ++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> tmpsum;</span><br><span class="line">                <span class="keyword">if</span>(!findans || <span class="built_in">abs</span>(tmpsum - target) &lt; <span class="built_in">abs</span>(ans - target))</span><br><span class="line">                    ans = tmpsum, findans = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="sum-1"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/3sum/">15.3Sum</a></h3>
<p>同上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector ans;</span><br><span class="line">    <span class="function">vector <span class="title">threeSum</span><span class="params">(vector &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> left = i + <span class="number">1</span>, right = num.<span class="built_in">size</span>() - <span class="number">1</span>; left &lt;right;)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmpsum = num[i] + num[left] + num[right];</span><br><span class="line">                <span class="keyword">if</span>(tmpsum &lt; <span class="number">0</span>) left ++; <span class="keyword">else</span> <span class="keyword">if</span>(tmpsum &gt; <span class="number">0</span>) right --;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vector tmp = &#123;num[i], num[left], num[right]&#125;;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                    left ++;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(; left != i + <span class="number">1</span> &amp;&amp; left &lt; right &amp;&amp; num[left] == num[left - <span class="number">1</span>]; left ++);</span><br><span class="line">                <span class="keyword">for</span>(; right != num.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; left &lt; right &amp;&amp; num[right] == num[right + <span class="number">1</span>]; right --);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i ++; i &lt; num.<span class="built_in">size</span>() &amp;&amp; num[i] == num[i - <span class="number">1</span>]; i ++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-common-prefix"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/longest-common-prefix/">14.Longest
Common Prefix</a></h3>
<p>一个一个扫</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector &amp;strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; ; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i ++)</span><br><span class="line">                <span class="keyword">if</span>(strs[i].<span class="built_in">size</span>() == j || strs[i][j] != strs[i - <span class="number">1</span>][j]) <span class="keyword">return</span> ans;</span><br><span class="line">            ans += strs[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="roman-to-integer"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/roman-to-integer/">13.Roman to
Integer</a></h3>
<p>各有各的方法，重点是记录(上一个)数比(这个)数大或小，来确定谁减谁。基本是右结合的，所以从后往前扫好处理些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> ro[<span class="number">128</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        ro[<span class="string">&#x27;I&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        ro[<span class="string">&#x27;V&#x27;</span>] = <span class="number">5</span>;</span><br><span class="line">        ro[<span class="string">&#x27;X&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">        ro[<span class="string">&#x27;L&#x27;</span>] = <span class="number">50</span>;</span><br><span class="line">        ro[<span class="string">&#x27;C&#x27;</span>] = <span class="number">100</span>;</span><br><span class="line">        ro[<span class="string">&#x27;D&#x27;</span>] = <span class="number">500</span>;</span><br><span class="line">        ro[<span class="string">&#x27;M&#x27;</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>, last;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">-1</span>) ans = ro[s[i]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(last &gt; ro[s[i]]) ans -= ro[s[i]];</span><br><span class="line">                <span class="keyword">else</span> ans += ro[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            last = ro[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="integer-to-roman"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/integer-to-roman/">12.Integer to
Roman</a></h3>
<p>每个十进制位格式是一样的，只是字母替换一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector table = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;II&quot;</span>, <span class="string">&quot;III&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;VI&quot;</span>, <span class="string">&quot;VII&quot;</span>, <span class="string">&quot;VIII&quot;</span>, <span class="string">&quot;IX&quot;</span>&#125;;</span><br><span class="line">    string ro = <span class="string">&quot;IVXLCDM&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">convert</span><span class="params">(<span class="type">char</span> x, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;I&#x27;</span>) <span class="keyword">return</span> ro[i];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;V&#x27;</span>) <span class="keyword">return</span> ro[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span> ro[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; num; i += <span class="number">2</span>, num /= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = num % <span class="number">10</span>;</span><br><span class="line">            string tmp = table[x];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; tmp.<span class="built_in">size</span>(); j ++)</span><br><span class="line">                tmp[j] = <span class="built_in">convert</span>(tmp[j], i);</span><br><span class="line">            ans = tmp + ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="container-with-most-water"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/container-with-most-water/">11.Container
With Most Water</a></h3>
<p>从两端开始枚举，较高的挡板往中间枚举的话一定无法得到更优解，故反复从较低挡板向中间枚举，O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[left], height[right]) * (right - left));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) left ++;</span><br><span class="line">            <span class="keyword">else</span> right --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="regular-expression-matching"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/regular-expression-matching/">10.Regular
Expression Matching</a></h3>
<p>每遇到一个 <code>*</code>
，问题都会出现分枝，需要用到栈或者递归。</p>
<p>没有 <code>*</code> 的情况好处理，遇到 <code>*</code>
的时候，穷举所有匹配长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == <span class="number">0</span>) <span class="keyword">return</span> *s == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(*(p + <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*s &amp;&amp; (*s == *p || *p == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">isMatch</span>(s + <span class="number">1</span>, p + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(; *s &amp;&amp; (*s == *p || *p == <span class="string">&#x27;.&#x27;</span>); s ++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isMatch</span>(s, p + <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isMatch</span>(s, p + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="palindrome-number"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/palindrome-number/">9.Palindrome
Number</a></h3>
<p>首先处理负数的trick。然后主要思路就是通过
<code>while(...) a = a * 10 + x % 10;</code> 来将 x 翻转。</p>
<p>但是注意到 x 很大的时候，翻转的 x 会超出 int
范围，也许会刚好成为另一个和 a
得出的数相等的正数，所以不能完全翻转后判断，而可以在翻转恰好一半的时候判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = x, cnt = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(x /= <span class="number">10</span>) cnt ++; </span><br><span class="line">        <span class="keyword">for</span>(; b &amp;&amp; cnt &gt;= <span class="number">0</span>; b /= <span class="number">10</span>, cnt -= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) <span class="keyword">return</span> a == b / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> a == b;</span><br><span class="line">            a = a * <span class="number">10</span> + b % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="string-to-integer-atoi"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/string-to-integer-atoi/">8.String
to Integer (atoi)</a></h3>
<p>任何类似多符号、符号数字间有空格的小问题都直接输出
0，这就好办了。处理越界用 long long。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(; *str == <span class="string">&#x27; &#x27;</span>; str ++);</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">&#x27;+&#x27;</span>) str ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str == <span class="string">&#x27;-&#x27;</span>) flag = <span class="literal">true</span>, str ++;</span><br><span class="line">        <span class="keyword">for</span>(; <span class="built_in">isdigit</span>(*str); str ++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + *str - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>((flag ? -ans : ans) &gt; INT_MAX) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((flag ? -ans : ans) &lt; INT_MIN) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(flag ? -ans : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reverse-integer"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/reverse-integer/">7.Reverse
Integer</a></h3>
<p>还是关于越界的讨论，不过这道题本身没有设置处理方式，重点在于面试时的交流。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> b = x &gt;= <span class="number">0</span> ? x : -x; b; b /= <span class="number">10</span>)</span><br><span class="line">            a = a * <span class="number">10</span> + b % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? a : -a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="zigzag-conversion"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/zigzag-conversion/">6.ZigZag
Conversion</a></h3>
<p>题意的 "z"
字形指一列nRows个，然后斜着往右上一格一个回到第一行，然后再一列nRows个。比如nRows=5，如下：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1          9          17          25</span><br><span class="line">2       8 10       16 18       24 26</span><br><span class="line">3    7    11    15    19    23    27    …</span><br><span class="line">4 6       12 14       20 22       28 30</span><br><span class="line">5         13          21          29</span><br></pre></td></tr></table></figure>
每行字母在原字符串中的间隔是有规律的，虽然两层for循环，但是s中每个字母只访问了一次，O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> nRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="type">int</span> a = (nRows &lt;&lt; <span class="number">1</span>) - <span class="number">2</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nRows; i ++, a -= <span class="number">2</span>, b += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">                    j += flag ? (b ? b : a) : (a ? a : b), flag ^= <span class="number">1</span>)</span><br><span class="line">                ans += s[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-palindromic-substring"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/longest-palindromic-substring/">5.Longest
Palindromic Substring</a></h3>
<p>网上O(n)的方法是厉害啊。。。简单解释如下：</p>
<p>1、预处理字符串，前后加(哨兵)字符比如
<code>!</code>，每个字母旁边加辅助字符比如<code>#</code>，这样例如字符串
<code>s="ababbcbb"</code> 就变成
<code>tmp="!#a#b#a#b#b#c#b#b#!"</code>。这样的好处是不用讨论回文串长度的奇偶。</p>
<p>2、对转化后的串，维护一个 center 和一个 reach，center 是当前已发现的
reach 最远的回文串中心位置，reach
是这个回文串最右端的位置，center和reach可初始化为
1，即第一个<code>#</code>的位置。</p>
<p>3、维护一个数组<code>vector r(tmp.length())</code>，<code>r[i]</code>
表示 i 位置为中心的回文串半径。</p>
<p>4、在考察位置 i 的时候，所有 j &lt; i 的 r[j] 都是已知的子问题。如果
i 在 reach 的左边，则 i 包含在以 center
为中心的回文串中，那么可以想到，如果和 i 关于 center 对称位置的 mirrori
为中心的回文串覆盖范围没有到达 center 为中心的回文串边缘，则 i
为中心的回文串肯定和 mirrori 的一样。而如果 mirrori
的回文串到达了边缘甚至超过，或者 i 本来就在 reach 的右边，那么对 i
为中心的回文串进行一次扩展，则结果
或者刚好不扩展，或者一定更新了reach。无论怎样，这里都得到了
r[i]。知道了所有 r[i]，答案就出来了。</p>
<p>核心问题在于第4步“对 i 为中心的回文串进行扩展”的复杂度。每次发生“对 i
扩展”，必然是对 reach 的扩展(也可能刚好不扩展，这个不影响复杂度），而
reach 的扩展范围是 tmp 的长度大约 2n，所以总复杂度为 O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> center = <span class="number">1</span>, reach = <span class="number">1</span>, ansstart = <span class="number">0</span>, anslength = <span class="number">0</span>;</span><br><span class="line">        string tmp = <span class="string">&quot;!#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)</span><br><span class="line">            tmp += s[i], tmp += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        tmp + <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">        <span class="function">vector <span class="title">r</span><span class="params">(tmp.length())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; tmp.<span class="built_in">length</span>(); i ++) &#123; <span class="type">int</span> mirrori = center * <span class="number">2</span> - i; r[i] = reach &gt; i ? <span class="built_in">min</span>(r[mirrori], reach - i) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; tmp[i + r[i] + <span class="number">1</span>] == tmp[i - r[i] - <span class="number">1</span>]; r[i] ++);</span><br><span class="line">            <span class="keyword">if</span>(i + r[i] &gt; reach)</span><br><span class="line">                reach = i + r[i], center = i;</span><br><span class="line">            <span class="keyword">if</span>(r[i] &gt; anslength)</span><br><span class="line">            &#123;</span><br><span class="line">                ansstart = i - r[i] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                anslength = r[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(ansstart, anslength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="median-of-two-sorted-arrays"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/median-of-two-sorted-arrays/">4.Median
of Two Sorted Arrays</a></h3>
<p>如果 A[pa] &lt; B[pb]，那么 A[pa] 一定在 A 与 B 合并后的前 pa + pb +
2 个数中。</p>
<p>证明： A 中有 pa + 1 个数 &lt;= A[pa]，B 中有小于 pb + 1 个数 &lt;=
A[pa]，合并后有少于pa + pb + 2 个数 &lt;= A[pa]。</p>
<p>利用这个性质迭代找 A 与 B 合并后的第 k 大数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> m, <span class="type">int</span> B[], <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> pm, pn;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> B[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> A[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(A[k - <span class="number">1</span>], B[k - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(m &lt;= n) pm = <span class="built_in">min</span>(k &gt;&gt; <span class="number">1</span>, m), pn = k - pm;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pn = <span class="built_in">min</span>(k &gt;&gt; <span class="number">1</span>, n), pm = k - pn;</span><br><span class="line">            <span class="keyword">if</span>(A[pm - <span class="number">1</span>] &lt; B[pn - <span class="number">1</span>]) A += pm, m -= pm, k -= pm; <span class="keyword">else</span> <span class="keyword">if</span>(A[pm - <span class="number">1</span>] &gt; B[pn - <span class="number">1</span>]) </span><br><span class="line">                B += pn, n -= pn, k-= pn;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[pm - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> m, <span class="type">int</span> B[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((m + n) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">findKth</span>(A, m, B, n, (m + n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">return</span> (<span class="built_in">findKth</span>(A, m, B, n, m + n &gt;&gt; <span class="number">1</span>) +</span><br><span class="line"></span><br><span class="line">            <span class="built_in">findKth</span>(A, m, B, n, (m + n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="longest-substring-without-repeating-characters"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/">3.Longest
Substring Without Repeating Characters</a></h3>
<p>维护一个不重复字符的区间。</p>
<p>代码一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">isin</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>; front &lt; s.<span class="built_in">length</span>(); front ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isin[s[front]])</span><br><span class="line">                <span class="keyword">for</span>(; rear &lt; front &amp;&amp; isin[s[front]]; isin[s[rear]] = <span class="literal">false</span>, rear ++);</span><br><span class="line">            isin[s[front]] = <span class="literal">true</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, front - rear + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector <span class="title">site</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> nowstart = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123; <span class="keyword">if</span>(site[s[i]] &gt;= nowstart)</span><br><span class="line">                nowstart = site[s[i]] + <span class="number">1</span>;</span><br><span class="line">            site[s[i]] = i;</span><br><span class="line">            ans = <span class="built_in">max</span>(i - nowstart + <span class="number">1</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="add-two-numbers"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/add-two-numbers/">2.Add Two
Numbers</a></h3>
<p>大整数加法的链表版。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = ans;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span> || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;val = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + cur;</span><br><span class="line">            cur = p-&gt;val / <span class="number">10</span>;</span><br><span class="line">            p-&gt;val %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1 || l2 || cur)</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="two-sum"><a
target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/two-sum/">1.Two Sum</a></h3>
<p>哈希存位置，O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">twoSum</span><span class="params">(vector &amp;numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        vector ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(target - numbers[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(mp[target - numbers[i]] + <span class="number">1</span>);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(numbers[i])) mp[numbers[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode%E9%A2%98%E8%A7%A3/" rel="tag"># LeetCode题解</a>
              <a href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag"># 题解</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2013-07-07-About-ACM-About-CSU/" rel="prev" title="关于ACM，关于CSU">
                  <i class="fa fa-angle-left"></i> 关于ACM，关于CSU
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2015-05-20-CSGrandeur's-WebGL-Learning--WebGL-Tutorial/" rel="next" title="CSGrandeur的WebGL学习——WebGL教程">
                  CSGrandeur的WebGL学习——WebGL教程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">CSGrandeur</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://fastly.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://fastly.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://fastly.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://fastly.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"CSGrandeur/csgrandeur.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
